// Code generated by http://github.com/gojuno/minimock (v3.4.5). DO NOT EDIT.

package mocks

//go:generate minimock -i route256/loms/internal/service.StockRepository -o stock_repository_mock.go -n StockRepositoryMock -p mocks

import (
	"context"
	"route256/loms/internal/domain"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
)

// StockRepositoryMock implements mm_service.StockRepository
type StockRepositoryMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcAddReserve          func(ctx context.Context, skuID int64, delta uint32) (err error)
	funcAddReserveOrigin    string
	inspectFuncAddReserve   func(ctx context.Context, skuID int64, delta uint32)
	afterAddReserveCounter  uint64
	beforeAddReserveCounter uint64
	AddReserveMock          mStockRepositoryMockAddReserve

	funcGetBySkuID          func(ctx context.Context, skuID int64) (sp1 *domain.Stock, err error)
	funcGetBySkuIDOrigin    string
	inspectFuncGetBySkuID   func(ctx context.Context, skuID int64)
	afterGetBySkuIDCounter  uint64
	beforeGetBySkuIDCounter uint64
	GetBySkuIDMock          mStockRepositoryMockGetBySkuID

	funcReduceReserveAndTotal          func(ctx context.Context, skuID int64, delta uint32) (err error)
	funcReduceReserveAndTotalOrigin    string
	inspectFuncReduceReserveAndTotal   func(ctx context.Context, skuID int64, delta uint32)
	afterReduceReserveAndTotalCounter  uint64
	beforeReduceReserveAndTotalCounter uint64
	ReduceReserveAndTotalMock          mStockRepositoryMockReduceReserveAndTotal

	funcRemoveReserve          func(ctx context.Context, skuID int64, delta uint32) (err error)
	funcRemoveReserveOrigin    string
	inspectFuncRemoveReserve   func(ctx context.Context, skuID int64, delta uint32)
	afterRemoveReserveCounter  uint64
	beforeRemoveReserveCounter uint64
	RemoveReserveMock          mStockRepositoryMockRemoveReserve

	funcUpsert          func(ctx context.Context, stock *domain.Stock) (err error)
	funcUpsertOrigin    string
	inspectFuncUpsert   func(ctx context.Context, stock *domain.Stock)
	afterUpsertCounter  uint64
	beforeUpsertCounter uint64
	UpsertMock          mStockRepositoryMockUpsert
}

// NewStockRepositoryMock returns a mock for mm_service.StockRepository
func NewStockRepositoryMock(t minimock.Tester) *StockRepositoryMock {
	m := &StockRepositoryMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.AddReserveMock = mStockRepositoryMockAddReserve{mock: m}
	m.AddReserveMock.callArgs = []*StockRepositoryMockAddReserveParams{}

	m.GetBySkuIDMock = mStockRepositoryMockGetBySkuID{mock: m}
	m.GetBySkuIDMock.callArgs = []*StockRepositoryMockGetBySkuIDParams{}

	m.ReduceReserveAndTotalMock = mStockRepositoryMockReduceReserveAndTotal{mock: m}
	m.ReduceReserveAndTotalMock.callArgs = []*StockRepositoryMockReduceReserveAndTotalParams{}

	m.RemoveReserveMock = mStockRepositoryMockRemoveReserve{mock: m}
	m.RemoveReserveMock.callArgs = []*StockRepositoryMockRemoveReserveParams{}

	m.UpsertMock = mStockRepositoryMockUpsert{mock: m}
	m.UpsertMock.callArgs = []*StockRepositoryMockUpsertParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mStockRepositoryMockAddReserve struct {
	optional           bool
	mock               *StockRepositoryMock
	defaultExpectation *StockRepositoryMockAddReserveExpectation
	expectations       []*StockRepositoryMockAddReserveExpectation

	callArgs []*StockRepositoryMockAddReserveParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// StockRepositoryMockAddReserveExpectation specifies expectation struct of the StockRepository.AddReserve
type StockRepositoryMockAddReserveExpectation struct {
	mock               *StockRepositoryMock
	params             *StockRepositoryMockAddReserveParams
	paramPtrs          *StockRepositoryMockAddReserveParamPtrs
	expectationOrigins StockRepositoryMockAddReserveExpectationOrigins
	results            *StockRepositoryMockAddReserveResults
	returnOrigin       string
	Counter            uint64
}

// StockRepositoryMockAddReserveParams contains parameters of the StockRepository.AddReserve
type StockRepositoryMockAddReserveParams struct {
	ctx   context.Context
	skuID int64
	delta uint32
}

// StockRepositoryMockAddReserveParamPtrs contains pointers to parameters of the StockRepository.AddReserve
type StockRepositoryMockAddReserveParamPtrs struct {
	ctx   *context.Context
	skuID *int64
	delta *uint32
}

// StockRepositoryMockAddReserveResults contains results of the StockRepository.AddReserve
type StockRepositoryMockAddReserveResults struct {
	err error
}

// StockRepositoryMockAddReserveOrigins contains origins of expectations of the StockRepository.AddReserve
type StockRepositoryMockAddReserveExpectationOrigins struct {
	origin      string
	originCtx   string
	originSkuID string
	originDelta string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmAddReserve *mStockRepositoryMockAddReserve) Optional() *mStockRepositoryMockAddReserve {
	mmAddReserve.optional = true
	return mmAddReserve
}

// Expect sets up expected params for StockRepository.AddReserve
func (mmAddReserve *mStockRepositoryMockAddReserve) Expect(ctx context.Context, skuID int64, delta uint32) *mStockRepositoryMockAddReserve {
	if mmAddReserve.mock.funcAddReserve != nil {
		mmAddReserve.mock.t.Fatalf("StockRepositoryMock.AddReserve mock is already set by Set")
	}

	if mmAddReserve.defaultExpectation == nil {
		mmAddReserve.defaultExpectation = &StockRepositoryMockAddReserveExpectation{}
	}

	if mmAddReserve.defaultExpectation.paramPtrs != nil {
		mmAddReserve.mock.t.Fatalf("StockRepositoryMock.AddReserve mock is already set by ExpectParams functions")
	}

	mmAddReserve.defaultExpectation.params = &StockRepositoryMockAddReserveParams{ctx, skuID, delta}
	mmAddReserve.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmAddReserve.expectations {
		if minimock.Equal(e.params, mmAddReserve.defaultExpectation.params) {
			mmAddReserve.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmAddReserve.defaultExpectation.params)
		}
	}

	return mmAddReserve
}

// ExpectCtxParam1 sets up expected param ctx for StockRepository.AddReserve
func (mmAddReserve *mStockRepositoryMockAddReserve) ExpectCtxParam1(ctx context.Context) *mStockRepositoryMockAddReserve {
	if mmAddReserve.mock.funcAddReserve != nil {
		mmAddReserve.mock.t.Fatalf("StockRepositoryMock.AddReserve mock is already set by Set")
	}

	if mmAddReserve.defaultExpectation == nil {
		mmAddReserve.defaultExpectation = &StockRepositoryMockAddReserveExpectation{}
	}

	if mmAddReserve.defaultExpectation.params != nil {
		mmAddReserve.mock.t.Fatalf("StockRepositoryMock.AddReserve mock is already set by Expect")
	}

	if mmAddReserve.defaultExpectation.paramPtrs == nil {
		mmAddReserve.defaultExpectation.paramPtrs = &StockRepositoryMockAddReserveParamPtrs{}
	}
	mmAddReserve.defaultExpectation.paramPtrs.ctx = &ctx
	mmAddReserve.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmAddReserve
}

// ExpectSkuIDParam2 sets up expected param skuID for StockRepository.AddReserve
func (mmAddReserve *mStockRepositoryMockAddReserve) ExpectSkuIDParam2(skuID int64) *mStockRepositoryMockAddReserve {
	if mmAddReserve.mock.funcAddReserve != nil {
		mmAddReserve.mock.t.Fatalf("StockRepositoryMock.AddReserve mock is already set by Set")
	}

	if mmAddReserve.defaultExpectation == nil {
		mmAddReserve.defaultExpectation = &StockRepositoryMockAddReserveExpectation{}
	}

	if mmAddReserve.defaultExpectation.params != nil {
		mmAddReserve.mock.t.Fatalf("StockRepositoryMock.AddReserve mock is already set by Expect")
	}

	if mmAddReserve.defaultExpectation.paramPtrs == nil {
		mmAddReserve.defaultExpectation.paramPtrs = &StockRepositoryMockAddReserveParamPtrs{}
	}
	mmAddReserve.defaultExpectation.paramPtrs.skuID = &skuID
	mmAddReserve.defaultExpectation.expectationOrigins.originSkuID = minimock.CallerInfo(1)

	return mmAddReserve
}

// ExpectDeltaParam3 sets up expected param delta for StockRepository.AddReserve
func (mmAddReserve *mStockRepositoryMockAddReserve) ExpectDeltaParam3(delta uint32) *mStockRepositoryMockAddReserve {
	if mmAddReserve.mock.funcAddReserve != nil {
		mmAddReserve.mock.t.Fatalf("StockRepositoryMock.AddReserve mock is already set by Set")
	}

	if mmAddReserve.defaultExpectation == nil {
		mmAddReserve.defaultExpectation = &StockRepositoryMockAddReserveExpectation{}
	}

	if mmAddReserve.defaultExpectation.params != nil {
		mmAddReserve.mock.t.Fatalf("StockRepositoryMock.AddReserve mock is already set by Expect")
	}

	if mmAddReserve.defaultExpectation.paramPtrs == nil {
		mmAddReserve.defaultExpectation.paramPtrs = &StockRepositoryMockAddReserveParamPtrs{}
	}
	mmAddReserve.defaultExpectation.paramPtrs.delta = &delta
	mmAddReserve.defaultExpectation.expectationOrigins.originDelta = minimock.CallerInfo(1)

	return mmAddReserve
}

// Inspect accepts an inspector function that has same arguments as the StockRepository.AddReserve
func (mmAddReserve *mStockRepositoryMockAddReserve) Inspect(f func(ctx context.Context, skuID int64, delta uint32)) *mStockRepositoryMockAddReserve {
	if mmAddReserve.mock.inspectFuncAddReserve != nil {
		mmAddReserve.mock.t.Fatalf("Inspect function is already set for StockRepositoryMock.AddReserve")
	}

	mmAddReserve.mock.inspectFuncAddReserve = f

	return mmAddReserve
}

// Return sets up results that will be returned by StockRepository.AddReserve
func (mmAddReserve *mStockRepositoryMockAddReserve) Return(err error) *StockRepositoryMock {
	if mmAddReserve.mock.funcAddReserve != nil {
		mmAddReserve.mock.t.Fatalf("StockRepositoryMock.AddReserve mock is already set by Set")
	}

	if mmAddReserve.defaultExpectation == nil {
		mmAddReserve.defaultExpectation = &StockRepositoryMockAddReserveExpectation{mock: mmAddReserve.mock}
	}
	mmAddReserve.defaultExpectation.results = &StockRepositoryMockAddReserveResults{err}
	mmAddReserve.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmAddReserve.mock
}

// Set uses given function f to mock the StockRepository.AddReserve method
func (mmAddReserve *mStockRepositoryMockAddReserve) Set(f func(ctx context.Context, skuID int64, delta uint32) (err error)) *StockRepositoryMock {
	if mmAddReserve.defaultExpectation != nil {
		mmAddReserve.mock.t.Fatalf("Default expectation is already set for the StockRepository.AddReserve method")
	}

	if len(mmAddReserve.expectations) > 0 {
		mmAddReserve.mock.t.Fatalf("Some expectations are already set for the StockRepository.AddReserve method")
	}

	mmAddReserve.mock.funcAddReserve = f
	mmAddReserve.mock.funcAddReserveOrigin = minimock.CallerInfo(1)
	return mmAddReserve.mock
}

// When sets expectation for the StockRepository.AddReserve which will trigger the result defined by the following
// Then helper
func (mmAddReserve *mStockRepositoryMockAddReserve) When(ctx context.Context, skuID int64, delta uint32) *StockRepositoryMockAddReserveExpectation {
	if mmAddReserve.mock.funcAddReserve != nil {
		mmAddReserve.mock.t.Fatalf("StockRepositoryMock.AddReserve mock is already set by Set")
	}

	expectation := &StockRepositoryMockAddReserveExpectation{
		mock:               mmAddReserve.mock,
		params:             &StockRepositoryMockAddReserveParams{ctx, skuID, delta},
		expectationOrigins: StockRepositoryMockAddReserveExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmAddReserve.expectations = append(mmAddReserve.expectations, expectation)
	return expectation
}

// Then sets up StockRepository.AddReserve return parameters for the expectation previously defined by the When method
func (e *StockRepositoryMockAddReserveExpectation) Then(err error) *StockRepositoryMock {
	e.results = &StockRepositoryMockAddReserveResults{err}
	return e.mock
}

// Times sets number of times StockRepository.AddReserve should be invoked
func (mmAddReserve *mStockRepositoryMockAddReserve) Times(n uint64) *mStockRepositoryMockAddReserve {
	if n == 0 {
		mmAddReserve.mock.t.Fatalf("Times of StockRepositoryMock.AddReserve mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmAddReserve.expectedInvocations, n)
	mmAddReserve.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmAddReserve
}

func (mmAddReserve *mStockRepositoryMockAddReserve) invocationsDone() bool {
	if len(mmAddReserve.expectations) == 0 && mmAddReserve.defaultExpectation == nil && mmAddReserve.mock.funcAddReserve == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmAddReserve.mock.afterAddReserveCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmAddReserve.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// AddReserve implements mm_service.StockRepository
func (mmAddReserve *StockRepositoryMock) AddReserve(ctx context.Context, skuID int64, delta uint32) (err error) {
	mm_atomic.AddUint64(&mmAddReserve.beforeAddReserveCounter, 1)
	defer mm_atomic.AddUint64(&mmAddReserve.afterAddReserveCounter, 1)

	mmAddReserve.t.Helper()

	if mmAddReserve.inspectFuncAddReserve != nil {
		mmAddReserve.inspectFuncAddReserve(ctx, skuID, delta)
	}

	mm_params := StockRepositoryMockAddReserveParams{ctx, skuID, delta}

	// Record call args
	mmAddReserve.AddReserveMock.mutex.Lock()
	mmAddReserve.AddReserveMock.callArgs = append(mmAddReserve.AddReserveMock.callArgs, &mm_params)
	mmAddReserve.AddReserveMock.mutex.Unlock()

	for _, e := range mmAddReserve.AddReserveMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmAddReserve.AddReserveMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmAddReserve.AddReserveMock.defaultExpectation.Counter, 1)
		mm_want := mmAddReserve.AddReserveMock.defaultExpectation.params
		mm_want_ptrs := mmAddReserve.AddReserveMock.defaultExpectation.paramPtrs

		mm_got := StockRepositoryMockAddReserveParams{ctx, skuID, delta}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmAddReserve.t.Errorf("StockRepositoryMock.AddReserve got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmAddReserve.AddReserveMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.skuID != nil && !minimock.Equal(*mm_want_ptrs.skuID, mm_got.skuID) {
				mmAddReserve.t.Errorf("StockRepositoryMock.AddReserve got unexpected parameter skuID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmAddReserve.AddReserveMock.defaultExpectation.expectationOrigins.originSkuID, *mm_want_ptrs.skuID, mm_got.skuID, minimock.Diff(*mm_want_ptrs.skuID, mm_got.skuID))
			}

			if mm_want_ptrs.delta != nil && !minimock.Equal(*mm_want_ptrs.delta, mm_got.delta) {
				mmAddReserve.t.Errorf("StockRepositoryMock.AddReserve got unexpected parameter delta, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmAddReserve.AddReserveMock.defaultExpectation.expectationOrigins.originDelta, *mm_want_ptrs.delta, mm_got.delta, minimock.Diff(*mm_want_ptrs.delta, mm_got.delta))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmAddReserve.t.Errorf("StockRepositoryMock.AddReserve got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmAddReserve.AddReserveMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmAddReserve.AddReserveMock.defaultExpectation.results
		if mm_results == nil {
			mmAddReserve.t.Fatal("No results are set for the StockRepositoryMock.AddReserve")
		}
		return (*mm_results).err
	}
	if mmAddReserve.funcAddReserve != nil {
		return mmAddReserve.funcAddReserve(ctx, skuID, delta)
	}
	mmAddReserve.t.Fatalf("Unexpected call to StockRepositoryMock.AddReserve. %v %v %v", ctx, skuID, delta)
	return
}

// AddReserveAfterCounter returns a count of finished StockRepositoryMock.AddReserve invocations
func (mmAddReserve *StockRepositoryMock) AddReserveAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAddReserve.afterAddReserveCounter)
}

// AddReserveBeforeCounter returns a count of StockRepositoryMock.AddReserve invocations
func (mmAddReserve *StockRepositoryMock) AddReserveBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAddReserve.beforeAddReserveCounter)
}

// Calls returns a list of arguments used in each call to StockRepositoryMock.AddReserve.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmAddReserve *mStockRepositoryMockAddReserve) Calls() []*StockRepositoryMockAddReserveParams {
	mmAddReserve.mutex.RLock()

	argCopy := make([]*StockRepositoryMockAddReserveParams, len(mmAddReserve.callArgs))
	copy(argCopy, mmAddReserve.callArgs)

	mmAddReserve.mutex.RUnlock()

	return argCopy
}

// MinimockAddReserveDone returns true if the count of the AddReserve invocations corresponds
// the number of defined expectations
func (m *StockRepositoryMock) MinimockAddReserveDone() bool {
	if m.AddReserveMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.AddReserveMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.AddReserveMock.invocationsDone()
}

// MinimockAddReserveInspect logs each unmet expectation
func (m *StockRepositoryMock) MinimockAddReserveInspect() {
	for _, e := range m.AddReserveMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to StockRepositoryMock.AddReserve at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterAddReserveCounter := mm_atomic.LoadUint64(&m.afterAddReserveCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.AddReserveMock.defaultExpectation != nil && afterAddReserveCounter < 1 {
		if m.AddReserveMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to StockRepositoryMock.AddReserve at\n%s", m.AddReserveMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to StockRepositoryMock.AddReserve at\n%s with params: %#v", m.AddReserveMock.defaultExpectation.expectationOrigins.origin, *m.AddReserveMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAddReserve != nil && afterAddReserveCounter < 1 {
		m.t.Errorf("Expected call to StockRepositoryMock.AddReserve at\n%s", m.funcAddReserveOrigin)
	}

	if !m.AddReserveMock.invocationsDone() && afterAddReserveCounter > 0 {
		m.t.Errorf("Expected %d calls to StockRepositoryMock.AddReserve at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.AddReserveMock.expectedInvocations), m.AddReserveMock.expectedInvocationsOrigin, afterAddReserveCounter)
	}
}

type mStockRepositoryMockGetBySkuID struct {
	optional           bool
	mock               *StockRepositoryMock
	defaultExpectation *StockRepositoryMockGetBySkuIDExpectation
	expectations       []*StockRepositoryMockGetBySkuIDExpectation

	callArgs []*StockRepositoryMockGetBySkuIDParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// StockRepositoryMockGetBySkuIDExpectation specifies expectation struct of the StockRepository.GetBySkuID
type StockRepositoryMockGetBySkuIDExpectation struct {
	mock               *StockRepositoryMock
	params             *StockRepositoryMockGetBySkuIDParams
	paramPtrs          *StockRepositoryMockGetBySkuIDParamPtrs
	expectationOrigins StockRepositoryMockGetBySkuIDExpectationOrigins
	results            *StockRepositoryMockGetBySkuIDResults
	returnOrigin       string
	Counter            uint64
}

// StockRepositoryMockGetBySkuIDParams contains parameters of the StockRepository.GetBySkuID
type StockRepositoryMockGetBySkuIDParams struct {
	ctx   context.Context
	skuID int64
}

// StockRepositoryMockGetBySkuIDParamPtrs contains pointers to parameters of the StockRepository.GetBySkuID
type StockRepositoryMockGetBySkuIDParamPtrs struct {
	ctx   *context.Context
	skuID *int64
}

// StockRepositoryMockGetBySkuIDResults contains results of the StockRepository.GetBySkuID
type StockRepositoryMockGetBySkuIDResults struct {
	sp1 *domain.Stock
	err error
}

// StockRepositoryMockGetBySkuIDOrigins contains origins of expectations of the StockRepository.GetBySkuID
type StockRepositoryMockGetBySkuIDExpectationOrigins struct {
	origin      string
	originCtx   string
	originSkuID string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetBySkuID *mStockRepositoryMockGetBySkuID) Optional() *mStockRepositoryMockGetBySkuID {
	mmGetBySkuID.optional = true
	return mmGetBySkuID
}

// Expect sets up expected params for StockRepository.GetBySkuID
func (mmGetBySkuID *mStockRepositoryMockGetBySkuID) Expect(ctx context.Context, skuID int64) *mStockRepositoryMockGetBySkuID {
	if mmGetBySkuID.mock.funcGetBySkuID != nil {
		mmGetBySkuID.mock.t.Fatalf("StockRepositoryMock.GetBySkuID mock is already set by Set")
	}

	if mmGetBySkuID.defaultExpectation == nil {
		mmGetBySkuID.defaultExpectation = &StockRepositoryMockGetBySkuIDExpectation{}
	}

	if mmGetBySkuID.defaultExpectation.paramPtrs != nil {
		mmGetBySkuID.mock.t.Fatalf("StockRepositoryMock.GetBySkuID mock is already set by ExpectParams functions")
	}

	mmGetBySkuID.defaultExpectation.params = &StockRepositoryMockGetBySkuIDParams{ctx, skuID}
	mmGetBySkuID.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetBySkuID.expectations {
		if minimock.Equal(e.params, mmGetBySkuID.defaultExpectation.params) {
			mmGetBySkuID.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetBySkuID.defaultExpectation.params)
		}
	}

	return mmGetBySkuID
}

// ExpectCtxParam1 sets up expected param ctx for StockRepository.GetBySkuID
func (mmGetBySkuID *mStockRepositoryMockGetBySkuID) ExpectCtxParam1(ctx context.Context) *mStockRepositoryMockGetBySkuID {
	if mmGetBySkuID.mock.funcGetBySkuID != nil {
		mmGetBySkuID.mock.t.Fatalf("StockRepositoryMock.GetBySkuID mock is already set by Set")
	}

	if mmGetBySkuID.defaultExpectation == nil {
		mmGetBySkuID.defaultExpectation = &StockRepositoryMockGetBySkuIDExpectation{}
	}

	if mmGetBySkuID.defaultExpectation.params != nil {
		mmGetBySkuID.mock.t.Fatalf("StockRepositoryMock.GetBySkuID mock is already set by Expect")
	}

	if mmGetBySkuID.defaultExpectation.paramPtrs == nil {
		mmGetBySkuID.defaultExpectation.paramPtrs = &StockRepositoryMockGetBySkuIDParamPtrs{}
	}
	mmGetBySkuID.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetBySkuID.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetBySkuID
}

// ExpectSkuIDParam2 sets up expected param skuID for StockRepository.GetBySkuID
func (mmGetBySkuID *mStockRepositoryMockGetBySkuID) ExpectSkuIDParam2(skuID int64) *mStockRepositoryMockGetBySkuID {
	if mmGetBySkuID.mock.funcGetBySkuID != nil {
		mmGetBySkuID.mock.t.Fatalf("StockRepositoryMock.GetBySkuID mock is already set by Set")
	}

	if mmGetBySkuID.defaultExpectation == nil {
		mmGetBySkuID.defaultExpectation = &StockRepositoryMockGetBySkuIDExpectation{}
	}

	if mmGetBySkuID.defaultExpectation.params != nil {
		mmGetBySkuID.mock.t.Fatalf("StockRepositoryMock.GetBySkuID mock is already set by Expect")
	}

	if mmGetBySkuID.defaultExpectation.paramPtrs == nil {
		mmGetBySkuID.defaultExpectation.paramPtrs = &StockRepositoryMockGetBySkuIDParamPtrs{}
	}
	mmGetBySkuID.defaultExpectation.paramPtrs.skuID = &skuID
	mmGetBySkuID.defaultExpectation.expectationOrigins.originSkuID = minimock.CallerInfo(1)

	return mmGetBySkuID
}

// Inspect accepts an inspector function that has same arguments as the StockRepository.GetBySkuID
func (mmGetBySkuID *mStockRepositoryMockGetBySkuID) Inspect(f func(ctx context.Context, skuID int64)) *mStockRepositoryMockGetBySkuID {
	if mmGetBySkuID.mock.inspectFuncGetBySkuID != nil {
		mmGetBySkuID.mock.t.Fatalf("Inspect function is already set for StockRepositoryMock.GetBySkuID")
	}

	mmGetBySkuID.mock.inspectFuncGetBySkuID = f

	return mmGetBySkuID
}

// Return sets up results that will be returned by StockRepository.GetBySkuID
func (mmGetBySkuID *mStockRepositoryMockGetBySkuID) Return(sp1 *domain.Stock, err error) *StockRepositoryMock {
	if mmGetBySkuID.mock.funcGetBySkuID != nil {
		mmGetBySkuID.mock.t.Fatalf("StockRepositoryMock.GetBySkuID mock is already set by Set")
	}

	if mmGetBySkuID.defaultExpectation == nil {
		mmGetBySkuID.defaultExpectation = &StockRepositoryMockGetBySkuIDExpectation{mock: mmGetBySkuID.mock}
	}
	mmGetBySkuID.defaultExpectation.results = &StockRepositoryMockGetBySkuIDResults{sp1, err}
	mmGetBySkuID.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetBySkuID.mock
}

// Set uses given function f to mock the StockRepository.GetBySkuID method
func (mmGetBySkuID *mStockRepositoryMockGetBySkuID) Set(f func(ctx context.Context, skuID int64) (sp1 *domain.Stock, err error)) *StockRepositoryMock {
	if mmGetBySkuID.defaultExpectation != nil {
		mmGetBySkuID.mock.t.Fatalf("Default expectation is already set for the StockRepository.GetBySkuID method")
	}

	if len(mmGetBySkuID.expectations) > 0 {
		mmGetBySkuID.mock.t.Fatalf("Some expectations are already set for the StockRepository.GetBySkuID method")
	}

	mmGetBySkuID.mock.funcGetBySkuID = f
	mmGetBySkuID.mock.funcGetBySkuIDOrigin = minimock.CallerInfo(1)
	return mmGetBySkuID.mock
}

// When sets expectation for the StockRepository.GetBySkuID which will trigger the result defined by the following
// Then helper
func (mmGetBySkuID *mStockRepositoryMockGetBySkuID) When(ctx context.Context, skuID int64) *StockRepositoryMockGetBySkuIDExpectation {
	if mmGetBySkuID.mock.funcGetBySkuID != nil {
		mmGetBySkuID.mock.t.Fatalf("StockRepositoryMock.GetBySkuID mock is already set by Set")
	}

	expectation := &StockRepositoryMockGetBySkuIDExpectation{
		mock:               mmGetBySkuID.mock,
		params:             &StockRepositoryMockGetBySkuIDParams{ctx, skuID},
		expectationOrigins: StockRepositoryMockGetBySkuIDExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetBySkuID.expectations = append(mmGetBySkuID.expectations, expectation)
	return expectation
}

// Then sets up StockRepository.GetBySkuID return parameters for the expectation previously defined by the When method
func (e *StockRepositoryMockGetBySkuIDExpectation) Then(sp1 *domain.Stock, err error) *StockRepositoryMock {
	e.results = &StockRepositoryMockGetBySkuIDResults{sp1, err}
	return e.mock
}

// Times sets number of times StockRepository.GetBySkuID should be invoked
func (mmGetBySkuID *mStockRepositoryMockGetBySkuID) Times(n uint64) *mStockRepositoryMockGetBySkuID {
	if n == 0 {
		mmGetBySkuID.mock.t.Fatalf("Times of StockRepositoryMock.GetBySkuID mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetBySkuID.expectedInvocations, n)
	mmGetBySkuID.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetBySkuID
}

func (mmGetBySkuID *mStockRepositoryMockGetBySkuID) invocationsDone() bool {
	if len(mmGetBySkuID.expectations) == 0 && mmGetBySkuID.defaultExpectation == nil && mmGetBySkuID.mock.funcGetBySkuID == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetBySkuID.mock.afterGetBySkuIDCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetBySkuID.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetBySkuID implements mm_service.StockRepository
func (mmGetBySkuID *StockRepositoryMock) GetBySkuID(ctx context.Context, skuID int64) (sp1 *domain.Stock, err error) {
	mm_atomic.AddUint64(&mmGetBySkuID.beforeGetBySkuIDCounter, 1)
	defer mm_atomic.AddUint64(&mmGetBySkuID.afterGetBySkuIDCounter, 1)

	mmGetBySkuID.t.Helper()

	if mmGetBySkuID.inspectFuncGetBySkuID != nil {
		mmGetBySkuID.inspectFuncGetBySkuID(ctx, skuID)
	}

	mm_params := StockRepositoryMockGetBySkuIDParams{ctx, skuID}

	// Record call args
	mmGetBySkuID.GetBySkuIDMock.mutex.Lock()
	mmGetBySkuID.GetBySkuIDMock.callArgs = append(mmGetBySkuID.GetBySkuIDMock.callArgs, &mm_params)
	mmGetBySkuID.GetBySkuIDMock.mutex.Unlock()

	for _, e := range mmGetBySkuID.GetBySkuIDMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.sp1, e.results.err
		}
	}

	if mmGetBySkuID.GetBySkuIDMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetBySkuID.GetBySkuIDMock.defaultExpectation.Counter, 1)
		mm_want := mmGetBySkuID.GetBySkuIDMock.defaultExpectation.params
		mm_want_ptrs := mmGetBySkuID.GetBySkuIDMock.defaultExpectation.paramPtrs

		mm_got := StockRepositoryMockGetBySkuIDParams{ctx, skuID}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetBySkuID.t.Errorf("StockRepositoryMock.GetBySkuID got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetBySkuID.GetBySkuIDMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.skuID != nil && !minimock.Equal(*mm_want_ptrs.skuID, mm_got.skuID) {
				mmGetBySkuID.t.Errorf("StockRepositoryMock.GetBySkuID got unexpected parameter skuID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetBySkuID.GetBySkuIDMock.defaultExpectation.expectationOrigins.originSkuID, *mm_want_ptrs.skuID, mm_got.skuID, minimock.Diff(*mm_want_ptrs.skuID, mm_got.skuID))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetBySkuID.t.Errorf("StockRepositoryMock.GetBySkuID got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetBySkuID.GetBySkuIDMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetBySkuID.GetBySkuIDMock.defaultExpectation.results
		if mm_results == nil {
			mmGetBySkuID.t.Fatal("No results are set for the StockRepositoryMock.GetBySkuID")
		}
		return (*mm_results).sp1, (*mm_results).err
	}
	if mmGetBySkuID.funcGetBySkuID != nil {
		return mmGetBySkuID.funcGetBySkuID(ctx, skuID)
	}
	mmGetBySkuID.t.Fatalf("Unexpected call to StockRepositoryMock.GetBySkuID. %v %v", ctx, skuID)
	return
}

// GetBySkuIDAfterCounter returns a count of finished StockRepositoryMock.GetBySkuID invocations
func (mmGetBySkuID *StockRepositoryMock) GetBySkuIDAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetBySkuID.afterGetBySkuIDCounter)
}

// GetBySkuIDBeforeCounter returns a count of StockRepositoryMock.GetBySkuID invocations
func (mmGetBySkuID *StockRepositoryMock) GetBySkuIDBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetBySkuID.beforeGetBySkuIDCounter)
}

// Calls returns a list of arguments used in each call to StockRepositoryMock.GetBySkuID.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetBySkuID *mStockRepositoryMockGetBySkuID) Calls() []*StockRepositoryMockGetBySkuIDParams {
	mmGetBySkuID.mutex.RLock()

	argCopy := make([]*StockRepositoryMockGetBySkuIDParams, len(mmGetBySkuID.callArgs))
	copy(argCopy, mmGetBySkuID.callArgs)

	mmGetBySkuID.mutex.RUnlock()

	return argCopy
}

// MinimockGetBySkuIDDone returns true if the count of the GetBySkuID invocations corresponds
// the number of defined expectations
func (m *StockRepositoryMock) MinimockGetBySkuIDDone() bool {
	if m.GetBySkuIDMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetBySkuIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetBySkuIDMock.invocationsDone()
}

// MinimockGetBySkuIDInspect logs each unmet expectation
func (m *StockRepositoryMock) MinimockGetBySkuIDInspect() {
	for _, e := range m.GetBySkuIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to StockRepositoryMock.GetBySkuID at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetBySkuIDCounter := mm_atomic.LoadUint64(&m.afterGetBySkuIDCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetBySkuIDMock.defaultExpectation != nil && afterGetBySkuIDCounter < 1 {
		if m.GetBySkuIDMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to StockRepositoryMock.GetBySkuID at\n%s", m.GetBySkuIDMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to StockRepositoryMock.GetBySkuID at\n%s with params: %#v", m.GetBySkuIDMock.defaultExpectation.expectationOrigins.origin, *m.GetBySkuIDMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetBySkuID != nil && afterGetBySkuIDCounter < 1 {
		m.t.Errorf("Expected call to StockRepositoryMock.GetBySkuID at\n%s", m.funcGetBySkuIDOrigin)
	}

	if !m.GetBySkuIDMock.invocationsDone() && afterGetBySkuIDCounter > 0 {
		m.t.Errorf("Expected %d calls to StockRepositoryMock.GetBySkuID at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetBySkuIDMock.expectedInvocations), m.GetBySkuIDMock.expectedInvocationsOrigin, afterGetBySkuIDCounter)
	}
}

type mStockRepositoryMockReduceReserveAndTotal struct {
	optional           bool
	mock               *StockRepositoryMock
	defaultExpectation *StockRepositoryMockReduceReserveAndTotalExpectation
	expectations       []*StockRepositoryMockReduceReserveAndTotalExpectation

	callArgs []*StockRepositoryMockReduceReserveAndTotalParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// StockRepositoryMockReduceReserveAndTotalExpectation specifies expectation struct of the StockRepository.ReduceReserveAndTotal
type StockRepositoryMockReduceReserveAndTotalExpectation struct {
	mock               *StockRepositoryMock
	params             *StockRepositoryMockReduceReserveAndTotalParams
	paramPtrs          *StockRepositoryMockReduceReserveAndTotalParamPtrs
	expectationOrigins StockRepositoryMockReduceReserveAndTotalExpectationOrigins
	results            *StockRepositoryMockReduceReserveAndTotalResults
	returnOrigin       string
	Counter            uint64
}

// StockRepositoryMockReduceReserveAndTotalParams contains parameters of the StockRepository.ReduceReserveAndTotal
type StockRepositoryMockReduceReserveAndTotalParams struct {
	ctx   context.Context
	skuID int64
	delta uint32
}

// StockRepositoryMockReduceReserveAndTotalParamPtrs contains pointers to parameters of the StockRepository.ReduceReserveAndTotal
type StockRepositoryMockReduceReserveAndTotalParamPtrs struct {
	ctx   *context.Context
	skuID *int64
	delta *uint32
}

// StockRepositoryMockReduceReserveAndTotalResults contains results of the StockRepository.ReduceReserveAndTotal
type StockRepositoryMockReduceReserveAndTotalResults struct {
	err error
}

// StockRepositoryMockReduceReserveAndTotalOrigins contains origins of expectations of the StockRepository.ReduceReserveAndTotal
type StockRepositoryMockReduceReserveAndTotalExpectationOrigins struct {
	origin      string
	originCtx   string
	originSkuID string
	originDelta string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmReduceReserveAndTotal *mStockRepositoryMockReduceReserveAndTotal) Optional() *mStockRepositoryMockReduceReserveAndTotal {
	mmReduceReserveAndTotal.optional = true
	return mmReduceReserveAndTotal
}

// Expect sets up expected params for StockRepository.ReduceReserveAndTotal
func (mmReduceReserveAndTotal *mStockRepositoryMockReduceReserveAndTotal) Expect(ctx context.Context, skuID int64, delta uint32) *mStockRepositoryMockReduceReserveAndTotal {
	if mmReduceReserveAndTotal.mock.funcReduceReserveAndTotal != nil {
		mmReduceReserveAndTotal.mock.t.Fatalf("StockRepositoryMock.ReduceReserveAndTotal mock is already set by Set")
	}

	if mmReduceReserveAndTotal.defaultExpectation == nil {
		mmReduceReserveAndTotal.defaultExpectation = &StockRepositoryMockReduceReserveAndTotalExpectation{}
	}

	if mmReduceReserveAndTotal.defaultExpectation.paramPtrs != nil {
		mmReduceReserveAndTotal.mock.t.Fatalf("StockRepositoryMock.ReduceReserveAndTotal mock is already set by ExpectParams functions")
	}

	mmReduceReserveAndTotal.defaultExpectation.params = &StockRepositoryMockReduceReserveAndTotalParams{ctx, skuID, delta}
	mmReduceReserveAndTotal.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmReduceReserveAndTotal.expectations {
		if minimock.Equal(e.params, mmReduceReserveAndTotal.defaultExpectation.params) {
			mmReduceReserveAndTotal.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmReduceReserveAndTotal.defaultExpectation.params)
		}
	}

	return mmReduceReserveAndTotal
}

// ExpectCtxParam1 sets up expected param ctx for StockRepository.ReduceReserveAndTotal
func (mmReduceReserveAndTotal *mStockRepositoryMockReduceReserveAndTotal) ExpectCtxParam1(ctx context.Context) *mStockRepositoryMockReduceReserveAndTotal {
	if mmReduceReserveAndTotal.mock.funcReduceReserveAndTotal != nil {
		mmReduceReserveAndTotal.mock.t.Fatalf("StockRepositoryMock.ReduceReserveAndTotal mock is already set by Set")
	}

	if mmReduceReserveAndTotal.defaultExpectation == nil {
		mmReduceReserveAndTotal.defaultExpectation = &StockRepositoryMockReduceReserveAndTotalExpectation{}
	}

	if mmReduceReserveAndTotal.defaultExpectation.params != nil {
		mmReduceReserveAndTotal.mock.t.Fatalf("StockRepositoryMock.ReduceReserveAndTotal mock is already set by Expect")
	}

	if mmReduceReserveAndTotal.defaultExpectation.paramPtrs == nil {
		mmReduceReserveAndTotal.defaultExpectation.paramPtrs = &StockRepositoryMockReduceReserveAndTotalParamPtrs{}
	}
	mmReduceReserveAndTotal.defaultExpectation.paramPtrs.ctx = &ctx
	mmReduceReserveAndTotal.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmReduceReserveAndTotal
}

// ExpectSkuIDParam2 sets up expected param skuID for StockRepository.ReduceReserveAndTotal
func (mmReduceReserveAndTotal *mStockRepositoryMockReduceReserveAndTotal) ExpectSkuIDParam2(skuID int64) *mStockRepositoryMockReduceReserveAndTotal {
	if mmReduceReserveAndTotal.mock.funcReduceReserveAndTotal != nil {
		mmReduceReserveAndTotal.mock.t.Fatalf("StockRepositoryMock.ReduceReserveAndTotal mock is already set by Set")
	}

	if mmReduceReserveAndTotal.defaultExpectation == nil {
		mmReduceReserveAndTotal.defaultExpectation = &StockRepositoryMockReduceReserveAndTotalExpectation{}
	}

	if mmReduceReserveAndTotal.defaultExpectation.params != nil {
		mmReduceReserveAndTotal.mock.t.Fatalf("StockRepositoryMock.ReduceReserveAndTotal mock is already set by Expect")
	}

	if mmReduceReserveAndTotal.defaultExpectation.paramPtrs == nil {
		mmReduceReserveAndTotal.defaultExpectation.paramPtrs = &StockRepositoryMockReduceReserveAndTotalParamPtrs{}
	}
	mmReduceReserveAndTotal.defaultExpectation.paramPtrs.skuID = &skuID
	mmReduceReserveAndTotal.defaultExpectation.expectationOrigins.originSkuID = minimock.CallerInfo(1)

	return mmReduceReserveAndTotal
}

// ExpectDeltaParam3 sets up expected param delta for StockRepository.ReduceReserveAndTotal
func (mmReduceReserveAndTotal *mStockRepositoryMockReduceReserveAndTotal) ExpectDeltaParam3(delta uint32) *mStockRepositoryMockReduceReserveAndTotal {
	if mmReduceReserveAndTotal.mock.funcReduceReserveAndTotal != nil {
		mmReduceReserveAndTotal.mock.t.Fatalf("StockRepositoryMock.ReduceReserveAndTotal mock is already set by Set")
	}

	if mmReduceReserveAndTotal.defaultExpectation == nil {
		mmReduceReserveAndTotal.defaultExpectation = &StockRepositoryMockReduceReserveAndTotalExpectation{}
	}

	if mmReduceReserveAndTotal.defaultExpectation.params != nil {
		mmReduceReserveAndTotal.mock.t.Fatalf("StockRepositoryMock.ReduceReserveAndTotal mock is already set by Expect")
	}

	if mmReduceReserveAndTotal.defaultExpectation.paramPtrs == nil {
		mmReduceReserveAndTotal.defaultExpectation.paramPtrs = &StockRepositoryMockReduceReserveAndTotalParamPtrs{}
	}
	mmReduceReserveAndTotal.defaultExpectation.paramPtrs.delta = &delta
	mmReduceReserveAndTotal.defaultExpectation.expectationOrigins.originDelta = minimock.CallerInfo(1)

	return mmReduceReserveAndTotal
}

// Inspect accepts an inspector function that has same arguments as the StockRepository.ReduceReserveAndTotal
func (mmReduceReserveAndTotal *mStockRepositoryMockReduceReserveAndTotal) Inspect(f func(ctx context.Context, skuID int64, delta uint32)) *mStockRepositoryMockReduceReserveAndTotal {
	if mmReduceReserveAndTotal.mock.inspectFuncReduceReserveAndTotal != nil {
		mmReduceReserveAndTotal.mock.t.Fatalf("Inspect function is already set for StockRepositoryMock.ReduceReserveAndTotal")
	}

	mmReduceReserveAndTotal.mock.inspectFuncReduceReserveAndTotal = f

	return mmReduceReserveAndTotal
}

// Return sets up results that will be returned by StockRepository.ReduceReserveAndTotal
func (mmReduceReserveAndTotal *mStockRepositoryMockReduceReserveAndTotal) Return(err error) *StockRepositoryMock {
	if mmReduceReserveAndTotal.mock.funcReduceReserveAndTotal != nil {
		mmReduceReserveAndTotal.mock.t.Fatalf("StockRepositoryMock.ReduceReserveAndTotal mock is already set by Set")
	}

	if mmReduceReserveAndTotal.defaultExpectation == nil {
		mmReduceReserveAndTotal.defaultExpectation = &StockRepositoryMockReduceReserveAndTotalExpectation{mock: mmReduceReserveAndTotal.mock}
	}
	mmReduceReserveAndTotal.defaultExpectation.results = &StockRepositoryMockReduceReserveAndTotalResults{err}
	mmReduceReserveAndTotal.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmReduceReserveAndTotal.mock
}

// Set uses given function f to mock the StockRepository.ReduceReserveAndTotal method
func (mmReduceReserveAndTotal *mStockRepositoryMockReduceReserveAndTotal) Set(f func(ctx context.Context, skuID int64, delta uint32) (err error)) *StockRepositoryMock {
	if mmReduceReserveAndTotal.defaultExpectation != nil {
		mmReduceReserveAndTotal.mock.t.Fatalf("Default expectation is already set for the StockRepository.ReduceReserveAndTotal method")
	}

	if len(mmReduceReserveAndTotal.expectations) > 0 {
		mmReduceReserveAndTotal.mock.t.Fatalf("Some expectations are already set for the StockRepository.ReduceReserveAndTotal method")
	}

	mmReduceReserveAndTotal.mock.funcReduceReserveAndTotal = f
	mmReduceReserveAndTotal.mock.funcReduceReserveAndTotalOrigin = minimock.CallerInfo(1)
	return mmReduceReserveAndTotal.mock
}

// When sets expectation for the StockRepository.ReduceReserveAndTotal which will trigger the result defined by the following
// Then helper
func (mmReduceReserveAndTotal *mStockRepositoryMockReduceReserveAndTotal) When(ctx context.Context, skuID int64, delta uint32) *StockRepositoryMockReduceReserveAndTotalExpectation {
	if mmReduceReserveAndTotal.mock.funcReduceReserveAndTotal != nil {
		mmReduceReserveAndTotal.mock.t.Fatalf("StockRepositoryMock.ReduceReserveAndTotal mock is already set by Set")
	}

	expectation := &StockRepositoryMockReduceReserveAndTotalExpectation{
		mock:               mmReduceReserveAndTotal.mock,
		params:             &StockRepositoryMockReduceReserveAndTotalParams{ctx, skuID, delta},
		expectationOrigins: StockRepositoryMockReduceReserveAndTotalExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmReduceReserveAndTotal.expectations = append(mmReduceReserveAndTotal.expectations, expectation)
	return expectation
}

// Then sets up StockRepository.ReduceReserveAndTotal return parameters for the expectation previously defined by the When method
func (e *StockRepositoryMockReduceReserveAndTotalExpectation) Then(err error) *StockRepositoryMock {
	e.results = &StockRepositoryMockReduceReserveAndTotalResults{err}
	return e.mock
}

// Times sets number of times StockRepository.ReduceReserveAndTotal should be invoked
func (mmReduceReserveAndTotal *mStockRepositoryMockReduceReserveAndTotal) Times(n uint64) *mStockRepositoryMockReduceReserveAndTotal {
	if n == 0 {
		mmReduceReserveAndTotal.mock.t.Fatalf("Times of StockRepositoryMock.ReduceReserveAndTotal mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmReduceReserveAndTotal.expectedInvocations, n)
	mmReduceReserveAndTotal.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmReduceReserveAndTotal
}

func (mmReduceReserveAndTotal *mStockRepositoryMockReduceReserveAndTotal) invocationsDone() bool {
	if len(mmReduceReserveAndTotal.expectations) == 0 && mmReduceReserveAndTotal.defaultExpectation == nil && mmReduceReserveAndTotal.mock.funcReduceReserveAndTotal == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmReduceReserveAndTotal.mock.afterReduceReserveAndTotalCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmReduceReserveAndTotal.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// ReduceReserveAndTotal implements mm_service.StockRepository
func (mmReduceReserveAndTotal *StockRepositoryMock) ReduceReserveAndTotal(ctx context.Context, skuID int64, delta uint32) (err error) {
	mm_atomic.AddUint64(&mmReduceReserveAndTotal.beforeReduceReserveAndTotalCounter, 1)
	defer mm_atomic.AddUint64(&mmReduceReserveAndTotal.afterReduceReserveAndTotalCounter, 1)

	mmReduceReserveAndTotal.t.Helper()

	if mmReduceReserveAndTotal.inspectFuncReduceReserveAndTotal != nil {
		mmReduceReserveAndTotal.inspectFuncReduceReserveAndTotal(ctx, skuID, delta)
	}

	mm_params := StockRepositoryMockReduceReserveAndTotalParams{ctx, skuID, delta}

	// Record call args
	mmReduceReserveAndTotal.ReduceReserveAndTotalMock.mutex.Lock()
	mmReduceReserveAndTotal.ReduceReserveAndTotalMock.callArgs = append(mmReduceReserveAndTotal.ReduceReserveAndTotalMock.callArgs, &mm_params)
	mmReduceReserveAndTotal.ReduceReserveAndTotalMock.mutex.Unlock()

	for _, e := range mmReduceReserveAndTotal.ReduceReserveAndTotalMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmReduceReserveAndTotal.ReduceReserveAndTotalMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmReduceReserveAndTotal.ReduceReserveAndTotalMock.defaultExpectation.Counter, 1)
		mm_want := mmReduceReserveAndTotal.ReduceReserveAndTotalMock.defaultExpectation.params
		mm_want_ptrs := mmReduceReserveAndTotal.ReduceReserveAndTotalMock.defaultExpectation.paramPtrs

		mm_got := StockRepositoryMockReduceReserveAndTotalParams{ctx, skuID, delta}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmReduceReserveAndTotal.t.Errorf("StockRepositoryMock.ReduceReserveAndTotal got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmReduceReserveAndTotal.ReduceReserveAndTotalMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.skuID != nil && !minimock.Equal(*mm_want_ptrs.skuID, mm_got.skuID) {
				mmReduceReserveAndTotal.t.Errorf("StockRepositoryMock.ReduceReserveAndTotal got unexpected parameter skuID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmReduceReserveAndTotal.ReduceReserveAndTotalMock.defaultExpectation.expectationOrigins.originSkuID, *mm_want_ptrs.skuID, mm_got.skuID, minimock.Diff(*mm_want_ptrs.skuID, mm_got.skuID))
			}

			if mm_want_ptrs.delta != nil && !minimock.Equal(*mm_want_ptrs.delta, mm_got.delta) {
				mmReduceReserveAndTotal.t.Errorf("StockRepositoryMock.ReduceReserveAndTotal got unexpected parameter delta, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmReduceReserveAndTotal.ReduceReserveAndTotalMock.defaultExpectation.expectationOrigins.originDelta, *mm_want_ptrs.delta, mm_got.delta, minimock.Diff(*mm_want_ptrs.delta, mm_got.delta))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmReduceReserveAndTotal.t.Errorf("StockRepositoryMock.ReduceReserveAndTotal got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmReduceReserveAndTotal.ReduceReserveAndTotalMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmReduceReserveAndTotal.ReduceReserveAndTotalMock.defaultExpectation.results
		if mm_results == nil {
			mmReduceReserveAndTotal.t.Fatal("No results are set for the StockRepositoryMock.ReduceReserveAndTotal")
		}
		return (*mm_results).err
	}
	if mmReduceReserveAndTotal.funcReduceReserveAndTotal != nil {
		return mmReduceReserveAndTotal.funcReduceReserveAndTotal(ctx, skuID, delta)
	}
	mmReduceReserveAndTotal.t.Fatalf("Unexpected call to StockRepositoryMock.ReduceReserveAndTotal. %v %v %v", ctx, skuID, delta)
	return
}

// ReduceReserveAndTotalAfterCounter returns a count of finished StockRepositoryMock.ReduceReserveAndTotal invocations
func (mmReduceReserveAndTotal *StockRepositoryMock) ReduceReserveAndTotalAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmReduceReserveAndTotal.afterReduceReserveAndTotalCounter)
}

// ReduceReserveAndTotalBeforeCounter returns a count of StockRepositoryMock.ReduceReserveAndTotal invocations
func (mmReduceReserveAndTotal *StockRepositoryMock) ReduceReserveAndTotalBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmReduceReserveAndTotal.beforeReduceReserveAndTotalCounter)
}

// Calls returns a list of arguments used in each call to StockRepositoryMock.ReduceReserveAndTotal.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmReduceReserveAndTotal *mStockRepositoryMockReduceReserveAndTotal) Calls() []*StockRepositoryMockReduceReserveAndTotalParams {
	mmReduceReserveAndTotal.mutex.RLock()

	argCopy := make([]*StockRepositoryMockReduceReserveAndTotalParams, len(mmReduceReserveAndTotal.callArgs))
	copy(argCopy, mmReduceReserveAndTotal.callArgs)

	mmReduceReserveAndTotal.mutex.RUnlock()

	return argCopy
}

// MinimockReduceReserveAndTotalDone returns true if the count of the ReduceReserveAndTotal invocations corresponds
// the number of defined expectations
func (m *StockRepositoryMock) MinimockReduceReserveAndTotalDone() bool {
	if m.ReduceReserveAndTotalMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ReduceReserveAndTotalMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ReduceReserveAndTotalMock.invocationsDone()
}

// MinimockReduceReserveAndTotalInspect logs each unmet expectation
func (m *StockRepositoryMock) MinimockReduceReserveAndTotalInspect() {
	for _, e := range m.ReduceReserveAndTotalMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to StockRepositoryMock.ReduceReserveAndTotal at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterReduceReserveAndTotalCounter := mm_atomic.LoadUint64(&m.afterReduceReserveAndTotalCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ReduceReserveAndTotalMock.defaultExpectation != nil && afterReduceReserveAndTotalCounter < 1 {
		if m.ReduceReserveAndTotalMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to StockRepositoryMock.ReduceReserveAndTotal at\n%s", m.ReduceReserveAndTotalMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to StockRepositoryMock.ReduceReserveAndTotal at\n%s with params: %#v", m.ReduceReserveAndTotalMock.defaultExpectation.expectationOrigins.origin, *m.ReduceReserveAndTotalMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcReduceReserveAndTotal != nil && afterReduceReserveAndTotalCounter < 1 {
		m.t.Errorf("Expected call to StockRepositoryMock.ReduceReserveAndTotal at\n%s", m.funcReduceReserveAndTotalOrigin)
	}

	if !m.ReduceReserveAndTotalMock.invocationsDone() && afterReduceReserveAndTotalCounter > 0 {
		m.t.Errorf("Expected %d calls to StockRepositoryMock.ReduceReserveAndTotal at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.ReduceReserveAndTotalMock.expectedInvocations), m.ReduceReserveAndTotalMock.expectedInvocationsOrigin, afterReduceReserveAndTotalCounter)
	}
}

type mStockRepositoryMockRemoveReserve struct {
	optional           bool
	mock               *StockRepositoryMock
	defaultExpectation *StockRepositoryMockRemoveReserveExpectation
	expectations       []*StockRepositoryMockRemoveReserveExpectation

	callArgs []*StockRepositoryMockRemoveReserveParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// StockRepositoryMockRemoveReserveExpectation specifies expectation struct of the StockRepository.RemoveReserve
type StockRepositoryMockRemoveReserveExpectation struct {
	mock               *StockRepositoryMock
	params             *StockRepositoryMockRemoveReserveParams
	paramPtrs          *StockRepositoryMockRemoveReserveParamPtrs
	expectationOrigins StockRepositoryMockRemoveReserveExpectationOrigins
	results            *StockRepositoryMockRemoveReserveResults
	returnOrigin       string
	Counter            uint64
}

// StockRepositoryMockRemoveReserveParams contains parameters of the StockRepository.RemoveReserve
type StockRepositoryMockRemoveReserveParams struct {
	ctx   context.Context
	skuID int64
	delta uint32
}

// StockRepositoryMockRemoveReserveParamPtrs contains pointers to parameters of the StockRepository.RemoveReserve
type StockRepositoryMockRemoveReserveParamPtrs struct {
	ctx   *context.Context
	skuID *int64
	delta *uint32
}

// StockRepositoryMockRemoveReserveResults contains results of the StockRepository.RemoveReserve
type StockRepositoryMockRemoveReserveResults struct {
	err error
}

// StockRepositoryMockRemoveReserveOrigins contains origins of expectations of the StockRepository.RemoveReserve
type StockRepositoryMockRemoveReserveExpectationOrigins struct {
	origin      string
	originCtx   string
	originSkuID string
	originDelta string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmRemoveReserve *mStockRepositoryMockRemoveReserve) Optional() *mStockRepositoryMockRemoveReserve {
	mmRemoveReserve.optional = true
	return mmRemoveReserve
}

// Expect sets up expected params for StockRepository.RemoveReserve
func (mmRemoveReserve *mStockRepositoryMockRemoveReserve) Expect(ctx context.Context, skuID int64, delta uint32) *mStockRepositoryMockRemoveReserve {
	if mmRemoveReserve.mock.funcRemoveReserve != nil {
		mmRemoveReserve.mock.t.Fatalf("StockRepositoryMock.RemoveReserve mock is already set by Set")
	}

	if mmRemoveReserve.defaultExpectation == nil {
		mmRemoveReserve.defaultExpectation = &StockRepositoryMockRemoveReserveExpectation{}
	}

	if mmRemoveReserve.defaultExpectation.paramPtrs != nil {
		mmRemoveReserve.mock.t.Fatalf("StockRepositoryMock.RemoveReserve mock is already set by ExpectParams functions")
	}

	mmRemoveReserve.defaultExpectation.params = &StockRepositoryMockRemoveReserveParams{ctx, skuID, delta}
	mmRemoveReserve.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmRemoveReserve.expectations {
		if minimock.Equal(e.params, mmRemoveReserve.defaultExpectation.params) {
			mmRemoveReserve.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmRemoveReserve.defaultExpectation.params)
		}
	}

	return mmRemoveReserve
}

// ExpectCtxParam1 sets up expected param ctx for StockRepository.RemoveReserve
func (mmRemoveReserve *mStockRepositoryMockRemoveReserve) ExpectCtxParam1(ctx context.Context) *mStockRepositoryMockRemoveReserve {
	if mmRemoveReserve.mock.funcRemoveReserve != nil {
		mmRemoveReserve.mock.t.Fatalf("StockRepositoryMock.RemoveReserve mock is already set by Set")
	}

	if mmRemoveReserve.defaultExpectation == nil {
		mmRemoveReserve.defaultExpectation = &StockRepositoryMockRemoveReserveExpectation{}
	}

	if mmRemoveReserve.defaultExpectation.params != nil {
		mmRemoveReserve.mock.t.Fatalf("StockRepositoryMock.RemoveReserve mock is already set by Expect")
	}

	if mmRemoveReserve.defaultExpectation.paramPtrs == nil {
		mmRemoveReserve.defaultExpectation.paramPtrs = &StockRepositoryMockRemoveReserveParamPtrs{}
	}
	mmRemoveReserve.defaultExpectation.paramPtrs.ctx = &ctx
	mmRemoveReserve.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmRemoveReserve
}

// ExpectSkuIDParam2 sets up expected param skuID for StockRepository.RemoveReserve
func (mmRemoveReserve *mStockRepositoryMockRemoveReserve) ExpectSkuIDParam2(skuID int64) *mStockRepositoryMockRemoveReserve {
	if mmRemoveReserve.mock.funcRemoveReserve != nil {
		mmRemoveReserve.mock.t.Fatalf("StockRepositoryMock.RemoveReserve mock is already set by Set")
	}

	if mmRemoveReserve.defaultExpectation == nil {
		mmRemoveReserve.defaultExpectation = &StockRepositoryMockRemoveReserveExpectation{}
	}

	if mmRemoveReserve.defaultExpectation.params != nil {
		mmRemoveReserve.mock.t.Fatalf("StockRepositoryMock.RemoveReserve mock is already set by Expect")
	}

	if mmRemoveReserve.defaultExpectation.paramPtrs == nil {
		mmRemoveReserve.defaultExpectation.paramPtrs = &StockRepositoryMockRemoveReserveParamPtrs{}
	}
	mmRemoveReserve.defaultExpectation.paramPtrs.skuID = &skuID
	mmRemoveReserve.defaultExpectation.expectationOrigins.originSkuID = minimock.CallerInfo(1)

	return mmRemoveReserve
}

// ExpectDeltaParam3 sets up expected param delta for StockRepository.RemoveReserve
func (mmRemoveReserve *mStockRepositoryMockRemoveReserve) ExpectDeltaParam3(delta uint32) *mStockRepositoryMockRemoveReserve {
	if mmRemoveReserve.mock.funcRemoveReserve != nil {
		mmRemoveReserve.mock.t.Fatalf("StockRepositoryMock.RemoveReserve mock is already set by Set")
	}

	if mmRemoveReserve.defaultExpectation == nil {
		mmRemoveReserve.defaultExpectation = &StockRepositoryMockRemoveReserveExpectation{}
	}

	if mmRemoveReserve.defaultExpectation.params != nil {
		mmRemoveReserve.mock.t.Fatalf("StockRepositoryMock.RemoveReserve mock is already set by Expect")
	}

	if mmRemoveReserve.defaultExpectation.paramPtrs == nil {
		mmRemoveReserve.defaultExpectation.paramPtrs = &StockRepositoryMockRemoveReserveParamPtrs{}
	}
	mmRemoveReserve.defaultExpectation.paramPtrs.delta = &delta
	mmRemoveReserve.defaultExpectation.expectationOrigins.originDelta = minimock.CallerInfo(1)

	return mmRemoveReserve
}

// Inspect accepts an inspector function that has same arguments as the StockRepository.RemoveReserve
func (mmRemoveReserve *mStockRepositoryMockRemoveReserve) Inspect(f func(ctx context.Context, skuID int64, delta uint32)) *mStockRepositoryMockRemoveReserve {
	if mmRemoveReserve.mock.inspectFuncRemoveReserve != nil {
		mmRemoveReserve.mock.t.Fatalf("Inspect function is already set for StockRepositoryMock.RemoveReserve")
	}

	mmRemoveReserve.mock.inspectFuncRemoveReserve = f

	return mmRemoveReserve
}

// Return sets up results that will be returned by StockRepository.RemoveReserve
func (mmRemoveReserve *mStockRepositoryMockRemoveReserve) Return(err error) *StockRepositoryMock {
	if mmRemoveReserve.mock.funcRemoveReserve != nil {
		mmRemoveReserve.mock.t.Fatalf("StockRepositoryMock.RemoveReserve mock is already set by Set")
	}

	if mmRemoveReserve.defaultExpectation == nil {
		mmRemoveReserve.defaultExpectation = &StockRepositoryMockRemoveReserveExpectation{mock: mmRemoveReserve.mock}
	}
	mmRemoveReserve.defaultExpectation.results = &StockRepositoryMockRemoveReserveResults{err}
	mmRemoveReserve.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmRemoveReserve.mock
}

// Set uses given function f to mock the StockRepository.RemoveReserve method
func (mmRemoveReserve *mStockRepositoryMockRemoveReserve) Set(f func(ctx context.Context, skuID int64, delta uint32) (err error)) *StockRepositoryMock {
	if mmRemoveReserve.defaultExpectation != nil {
		mmRemoveReserve.mock.t.Fatalf("Default expectation is already set for the StockRepository.RemoveReserve method")
	}

	if len(mmRemoveReserve.expectations) > 0 {
		mmRemoveReserve.mock.t.Fatalf("Some expectations are already set for the StockRepository.RemoveReserve method")
	}

	mmRemoveReserve.mock.funcRemoveReserve = f
	mmRemoveReserve.mock.funcRemoveReserveOrigin = minimock.CallerInfo(1)
	return mmRemoveReserve.mock
}

// When sets expectation for the StockRepository.RemoveReserve which will trigger the result defined by the following
// Then helper
func (mmRemoveReserve *mStockRepositoryMockRemoveReserve) When(ctx context.Context, skuID int64, delta uint32) *StockRepositoryMockRemoveReserveExpectation {
	if mmRemoveReserve.mock.funcRemoveReserve != nil {
		mmRemoveReserve.mock.t.Fatalf("StockRepositoryMock.RemoveReserve mock is already set by Set")
	}

	expectation := &StockRepositoryMockRemoveReserveExpectation{
		mock:               mmRemoveReserve.mock,
		params:             &StockRepositoryMockRemoveReserveParams{ctx, skuID, delta},
		expectationOrigins: StockRepositoryMockRemoveReserveExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmRemoveReserve.expectations = append(mmRemoveReserve.expectations, expectation)
	return expectation
}

// Then sets up StockRepository.RemoveReserve return parameters for the expectation previously defined by the When method
func (e *StockRepositoryMockRemoveReserveExpectation) Then(err error) *StockRepositoryMock {
	e.results = &StockRepositoryMockRemoveReserveResults{err}
	return e.mock
}

// Times sets number of times StockRepository.RemoveReserve should be invoked
func (mmRemoveReserve *mStockRepositoryMockRemoveReserve) Times(n uint64) *mStockRepositoryMockRemoveReserve {
	if n == 0 {
		mmRemoveReserve.mock.t.Fatalf("Times of StockRepositoryMock.RemoveReserve mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmRemoveReserve.expectedInvocations, n)
	mmRemoveReserve.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmRemoveReserve
}

func (mmRemoveReserve *mStockRepositoryMockRemoveReserve) invocationsDone() bool {
	if len(mmRemoveReserve.expectations) == 0 && mmRemoveReserve.defaultExpectation == nil && mmRemoveReserve.mock.funcRemoveReserve == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmRemoveReserve.mock.afterRemoveReserveCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmRemoveReserve.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// RemoveReserve implements mm_service.StockRepository
func (mmRemoveReserve *StockRepositoryMock) RemoveReserve(ctx context.Context, skuID int64, delta uint32) (err error) {
	mm_atomic.AddUint64(&mmRemoveReserve.beforeRemoveReserveCounter, 1)
	defer mm_atomic.AddUint64(&mmRemoveReserve.afterRemoveReserveCounter, 1)

	mmRemoveReserve.t.Helper()

	if mmRemoveReserve.inspectFuncRemoveReserve != nil {
		mmRemoveReserve.inspectFuncRemoveReserve(ctx, skuID, delta)
	}

	mm_params := StockRepositoryMockRemoveReserveParams{ctx, skuID, delta}

	// Record call args
	mmRemoveReserve.RemoveReserveMock.mutex.Lock()
	mmRemoveReserve.RemoveReserveMock.callArgs = append(mmRemoveReserve.RemoveReserveMock.callArgs, &mm_params)
	mmRemoveReserve.RemoveReserveMock.mutex.Unlock()

	for _, e := range mmRemoveReserve.RemoveReserveMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmRemoveReserve.RemoveReserveMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmRemoveReserve.RemoveReserveMock.defaultExpectation.Counter, 1)
		mm_want := mmRemoveReserve.RemoveReserveMock.defaultExpectation.params
		mm_want_ptrs := mmRemoveReserve.RemoveReserveMock.defaultExpectation.paramPtrs

		mm_got := StockRepositoryMockRemoveReserveParams{ctx, skuID, delta}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmRemoveReserve.t.Errorf("StockRepositoryMock.RemoveReserve got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmRemoveReserve.RemoveReserveMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.skuID != nil && !minimock.Equal(*mm_want_ptrs.skuID, mm_got.skuID) {
				mmRemoveReserve.t.Errorf("StockRepositoryMock.RemoveReserve got unexpected parameter skuID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmRemoveReserve.RemoveReserveMock.defaultExpectation.expectationOrigins.originSkuID, *mm_want_ptrs.skuID, mm_got.skuID, minimock.Diff(*mm_want_ptrs.skuID, mm_got.skuID))
			}

			if mm_want_ptrs.delta != nil && !minimock.Equal(*mm_want_ptrs.delta, mm_got.delta) {
				mmRemoveReserve.t.Errorf("StockRepositoryMock.RemoveReserve got unexpected parameter delta, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmRemoveReserve.RemoveReserveMock.defaultExpectation.expectationOrigins.originDelta, *mm_want_ptrs.delta, mm_got.delta, minimock.Diff(*mm_want_ptrs.delta, mm_got.delta))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmRemoveReserve.t.Errorf("StockRepositoryMock.RemoveReserve got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmRemoveReserve.RemoveReserveMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmRemoveReserve.RemoveReserveMock.defaultExpectation.results
		if mm_results == nil {
			mmRemoveReserve.t.Fatal("No results are set for the StockRepositoryMock.RemoveReserve")
		}
		return (*mm_results).err
	}
	if mmRemoveReserve.funcRemoveReserve != nil {
		return mmRemoveReserve.funcRemoveReserve(ctx, skuID, delta)
	}
	mmRemoveReserve.t.Fatalf("Unexpected call to StockRepositoryMock.RemoveReserve. %v %v %v", ctx, skuID, delta)
	return
}

// RemoveReserveAfterCounter returns a count of finished StockRepositoryMock.RemoveReserve invocations
func (mmRemoveReserve *StockRepositoryMock) RemoveReserveAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRemoveReserve.afterRemoveReserveCounter)
}

// RemoveReserveBeforeCounter returns a count of StockRepositoryMock.RemoveReserve invocations
func (mmRemoveReserve *StockRepositoryMock) RemoveReserveBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRemoveReserve.beforeRemoveReserveCounter)
}

// Calls returns a list of arguments used in each call to StockRepositoryMock.RemoveReserve.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmRemoveReserve *mStockRepositoryMockRemoveReserve) Calls() []*StockRepositoryMockRemoveReserveParams {
	mmRemoveReserve.mutex.RLock()

	argCopy := make([]*StockRepositoryMockRemoveReserveParams, len(mmRemoveReserve.callArgs))
	copy(argCopy, mmRemoveReserve.callArgs)

	mmRemoveReserve.mutex.RUnlock()

	return argCopy
}

// MinimockRemoveReserveDone returns true if the count of the RemoveReserve invocations corresponds
// the number of defined expectations
func (m *StockRepositoryMock) MinimockRemoveReserveDone() bool {
	if m.RemoveReserveMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.RemoveReserveMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.RemoveReserveMock.invocationsDone()
}

// MinimockRemoveReserveInspect logs each unmet expectation
func (m *StockRepositoryMock) MinimockRemoveReserveInspect() {
	for _, e := range m.RemoveReserveMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to StockRepositoryMock.RemoveReserve at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterRemoveReserveCounter := mm_atomic.LoadUint64(&m.afterRemoveReserveCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.RemoveReserveMock.defaultExpectation != nil && afterRemoveReserveCounter < 1 {
		if m.RemoveReserveMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to StockRepositoryMock.RemoveReserve at\n%s", m.RemoveReserveMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to StockRepositoryMock.RemoveReserve at\n%s with params: %#v", m.RemoveReserveMock.defaultExpectation.expectationOrigins.origin, *m.RemoveReserveMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcRemoveReserve != nil && afterRemoveReserveCounter < 1 {
		m.t.Errorf("Expected call to StockRepositoryMock.RemoveReserve at\n%s", m.funcRemoveReserveOrigin)
	}

	if !m.RemoveReserveMock.invocationsDone() && afterRemoveReserveCounter > 0 {
		m.t.Errorf("Expected %d calls to StockRepositoryMock.RemoveReserve at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.RemoveReserveMock.expectedInvocations), m.RemoveReserveMock.expectedInvocationsOrigin, afterRemoveReserveCounter)
	}
}

type mStockRepositoryMockUpsert struct {
	optional           bool
	mock               *StockRepositoryMock
	defaultExpectation *StockRepositoryMockUpsertExpectation
	expectations       []*StockRepositoryMockUpsertExpectation

	callArgs []*StockRepositoryMockUpsertParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// StockRepositoryMockUpsertExpectation specifies expectation struct of the StockRepository.Upsert
type StockRepositoryMockUpsertExpectation struct {
	mock               *StockRepositoryMock
	params             *StockRepositoryMockUpsertParams
	paramPtrs          *StockRepositoryMockUpsertParamPtrs
	expectationOrigins StockRepositoryMockUpsertExpectationOrigins
	results            *StockRepositoryMockUpsertResults
	returnOrigin       string
	Counter            uint64
}

// StockRepositoryMockUpsertParams contains parameters of the StockRepository.Upsert
type StockRepositoryMockUpsertParams struct {
	ctx   context.Context
	stock *domain.Stock
}

// StockRepositoryMockUpsertParamPtrs contains pointers to parameters of the StockRepository.Upsert
type StockRepositoryMockUpsertParamPtrs struct {
	ctx   *context.Context
	stock **domain.Stock
}

// StockRepositoryMockUpsertResults contains results of the StockRepository.Upsert
type StockRepositoryMockUpsertResults struct {
	err error
}

// StockRepositoryMockUpsertOrigins contains origins of expectations of the StockRepository.Upsert
type StockRepositoryMockUpsertExpectationOrigins struct {
	origin      string
	originCtx   string
	originStock string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmUpsert *mStockRepositoryMockUpsert) Optional() *mStockRepositoryMockUpsert {
	mmUpsert.optional = true
	return mmUpsert
}

// Expect sets up expected params for StockRepository.Upsert
func (mmUpsert *mStockRepositoryMockUpsert) Expect(ctx context.Context, stock *domain.Stock) *mStockRepositoryMockUpsert {
	if mmUpsert.mock.funcUpsert != nil {
		mmUpsert.mock.t.Fatalf("StockRepositoryMock.Upsert mock is already set by Set")
	}

	if mmUpsert.defaultExpectation == nil {
		mmUpsert.defaultExpectation = &StockRepositoryMockUpsertExpectation{}
	}

	if mmUpsert.defaultExpectation.paramPtrs != nil {
		mmUpsert.mock.t.Fatalf("StockRepositoryMock.Upsert mock is already set by ExpectParams functions")
	}

	mmUpsert.defaultExpectation.params = &StockRepositoryMockUpsertParams{ctx, stock}
	mmUpsert.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmUpsert.expectations {
		if minimock.Equal(e.params, mmUpsert.defaultExpectation.params) {
			mmUpsert.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmUpsert.defaultExpectation.params)
		}
	}

	return mmUpsert
}

// ExpectCtxParam1 sets up expected param ctx for StockRepository.Upsert
func (mmUpsert *mStockRepositoryMockUpsert) ExpectCtxParam1(ctx context.Context) *mStockRepositoryMockUpsert {
	if mmUpsert.mock.funcUpsert != nil {
		mmUpsert.mock.t.Fatalf("StockRepositoryMock.Upsert mock is already set by Set")
	}

	if mmUpsert.defaultExpectation == nil {
		mmUpsert.defaultExpectation = &StockRepositoryMockUpsertExpectation{}
	}

	if mmUpsert.defaultExpectation.params != nil {
		mmUpsert.mock.t.Fatalf("StockRepositoryMock.Upsert mock is already set by Expect")
	}

	if mmUpsert.defaultExpectation.paramPtrs == nil {
		mmUpsert.defaultExpectation.paramPtrs = &StockRepositoryMockUpsertParamPtrs{}
	}
	mmUpsert.defaultExpectation.paramPtrs.ctx = &ctx
	mmUpsert.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmUpsert
}

// ExpectStockParam2 sets up expected param stock for StockRepository.Upsert
func (mmUpsert *mStockRepositoryMockUpsert) ExpectStockParam2(stock *domain.Stock) *mStockRepositoryMockUpsert {
	if mmUpsert.mock.funcUpsert != nil {
		mmUpsert.mock.t.Fatalf("StockRepositoryMock.Upsert mock is already set by Set")
	}

	if mmUpsert.defaultExpectation == nil {
		mmUpsert.defaultExpectation = &StockRepositoryMockUpsertExpectation{}
	}

	if mmUpsert.defaultExpectation.params != nil {
		mmUpsert.mock.t.Fatalf("StockRepositoryMock.Upsert mock is already set by Expect")
	}

	if mmUpsert.defaultExpectation.paramPtrs == nil {
		mmUpsert.defaultExpectation.paramPtrs = &StockRepositoryMockUpsertParamPtrs{}
	}
	mmUpsert.defaultExpectation.paramPtrs.stock = &stock
	mmUpsert.defaultExpectation.expectationOrigins.originStock = minimock.CallerInfo(1)

	return mmUpsert
}

// Inspect accepts an inspector function that has same arguments as the StockRepository.Upsert
func (mmUpsert *mStockRepositoryMockUpsert) Inspect(f func(ctx context.Context, stock *domain.Stock)) *mStockRepositoryMockUpsert {
	if mmUpsert.mock.inspectFuncUpsert != nil {
		mmUpsert.mock.t.Fatalf("Inspect function is already set for StockRepositoryMock.Upsert")
	}

	mmUpsert.mock.inspectFuncUpsert = f

	return mmUpsert
}

// Return sets up results that will be returned by StockRepository.Upsert
func (mmUpsert *mStockRepositoryMockUpsert) Return(err error) *StockRepositoryMock {
	if mmUpsert.mock.funcUpsert != nil {
		mmUpsert.mock.t.Fatalf("StockRepositoryMock.Upsert mock is already set by Set")
	}

	if mmUpsert.defaultExpectation == nil {
		mmUpsert.defaultExpectation = &StockRepositoryMockUpsertExpectation{mock: mmUpsert.mock}
	}
	mmUpsert.defaultExpectation.results = &StockRepositoryMockUpsertResults{err}
	mmUpsert.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmUpsert.mock
}

// Set uses given function f to mock the StockRepository.Upsert method
func (mmUpsert *mStockRepositoryMockUpsert) Set(f func(ctx context.Context, stock *domain.Stock) (err error)) *StockRepositoryMock {
	if mmUpsert.defaultExpectation != nil {
		mmUpsert.mock.t.Fatalf("Default expectation is already set for the StockRepository.Upsert method")
	}

	if len(mmUpsert.expectations) > 0 {
		mmUpsert.mock.t.Fatalf("Some expectations are already set for the StockRepository.Upsert method")
	}

	mmUpsert.mock.funcUpsert = f
	mmUpsert.mock.funcUpsertOrigin = minimock.CallerInfo(1)
	return mmUpsert.mock
}

// When sets expectation for the StockRepository.Upsert which will trigger the result defined by the following
// Then helper
func (mmUpsert *mStockRepositoryMockUpsert) When(ctx context.Context, stock *domain.Stock) *StockRepositoryMockUpsertExpectation {
	if mmUpsert.mock.funcUpsert != nil {
		mmUpsert.mock.t.Fatalf("StockRepositoryMock.Upsert mock is already set by Set")
	}

	expectation := &StockRepositoryMockUpsertExpectation{
		mock:               mmUpsert.mock,
		params:             &StockRepositoryMockUpsertParams{ctx, stock},
		expectationOrigins: StockRepositoryMockUpsertExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmUpsert.expectations = append(mmUpsert.expectations, expectation)
	return expectation
}

// Then sets up StockRepository.Upsert return parameters for the expectation previously defined by the When method
func (e *StockRepositoryMockUpsertExpectation) Then(err error) *StockRepositoryMock {
	e.results = &StockRepositoryMockUpsertResults{err}
	return e.mock
}

// Times sets number of times StockRepository.Upsert should be invoked
func (mmUpsert *mStockRepositoryMockUpsert) Times(n uint64) *mStockRepositoryMockUpsert {
	if n == 0 {
		mmUpsert.mock.t.Fatalf("Times of StockRepositoryMock.Upsert mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmUpsert.expectedInvocations, n)
	mmUpsert.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmUpsert
}

func (mmUpsert *mStockRepositoryMockUpsert) invocationsDone() bool {
	if len(mmUpsert.expectations) == 0 && mmUpsert.defaultExpectation == nil && mmUpsert.mock.funcUpsert == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmUpsert.mock.afterUpsertCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmUpsert.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Upsert implements mm_service.StockRepository
func (mmUpsert *StockRepositoryMock) Upsert(ctx context.Context, stock *domain.Stock) (err error) {
	mm_atomic.AddUint64(&mmUpsert.beforeUpsertCounter, 1)
	defer mm_atomic.AddUint64(&mmUpsert.afterUpsertCounter, 1)

	mmUpsert.t.Helper()

	if mmUpsert.inspectFuncUpsert != nil {
		mmUpsert.inspectFuncUpsert(ctx, stock)
	}

	mm_params := StockRepositoryMockUpsertParams{ctx, stock}

	// Record call args
	mmUpsert.UpsertMock.mutex.Lock()
	mmUpsert.UpsertMock.callArgs = append(mmUpsert.UpsertMock.callArgs, &mm_params)
	mmUpsert.UpsertMock.mutex.Unlock()

	for _, e := range mmUpsert.UpsertMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmUpsert.UpsertMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmUpsert.UpsertMock.defaultExpectation.Counter, 1)
		mm_want := mmUpsert.UpsertMock.defaultExpectation.params
		mm_want_ptrs := mmUpsert.UpsertMock.defaultExpectation.paramPtrs

		mm_got := StockRepositoryMockUpsertParams{ctx, stock}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmUpsert.t.Errorf("StockRepositoryMock.Upsert got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpsert.UpsertMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.stock != nil && !minimock.Equal(*mm_want_ptrs.stock, mm_got.stock) {
				mmUpsert.t.Errorf("StockRepositoryMock.Upsert got unexpected parameter stock, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpsert.UpsertMock.defaultExpectation.expectationOrigins.originStock, *mm_want_ptrs.stock, mm_got.stock, minimock.Diff(*mm_want_ptrs.stock, mm_got.stock))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmUpsert.t.Errorf("StockRepositoryMock.Upsert got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmUpsert.UpsertMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmUpsert.UpsertMock.defaultExpectation.results
		if mm_results == nil {
			mmUpsert.t.Fatal("No results are set for the StockRepositoryMock.Upsert")
		}
		return (*mm_results).err
	}
	if mmUpsert.funcUpsert != nil {
		return mmUpsert.funcUpsert(ctx, stock)
	}
	mmUpsert.t.Fatalf("Unexpected call to StockRepositoryMock.Upsert. %v %v", ctx, stock)
	return
}

// UpsertAfterCounter returns a count of finished StockRepositoryMock.Upsert invocations
func (mmUpsert *StockRepositoryMock) UpsertAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpsert.afterUpsertCounter)
}

// UpsertBeforeCounter returns a count of StockRepositoryMock.Upsert invocations
func (mmUpsert *StockRepositoryMock) UpsertBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpsert.beforeUpsertCounter)
}

// Calls returns a list of arguments used in each call to StockRepositoryMock.Upsert.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmUpsert *mStockRepositoryMockUpsert) Calls() []*StockRepositoryMockUpsertParams {
	mmUpsert.mutex.RLock()

	argCopy := make([]*StockRepositoryMockUpsertParams, len(mmUpsert.callArgs))
	copy(argCopy, mmUpsert.callArgs)

	mmUpsert.mutex.RUnlock()

	return argCopy
}

// MinimockUpsertDone returns true if the count of the Upsert invocations corresponds
// the number of defined expectations
func (m *StockRepositoryMock) MinimockUpsertDone() bool {
	if m.UpsertMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.UpsertMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.UpsertMock.invocationsDone()
}

// MinimockUpsertInspect logs each unmet expectation
func (m *StockRepositoryMock) MinimockUpsertInspect() {
	for _, e := range m.UpsertMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to StockRepositoryMock.Upsert at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterUpsertCounter := mm_atomic.LoadUint64(&m.afterUpsertCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.UpsertMock.defaultExpectation != nil && afterUpsertCounter < 1 {
		if m.UpsertMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to StockRepositoryMock.Upsert at\n%s", m.UpsertMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to StockRepositoryMock.Upsert at\n%s with params: %#v", m.UpsertMock.defaultExpectation.expectationOrigins.origin, *m.UpsertMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpsert != nil && afterUpsertCounter < 1 {
		m.t.Errorf("Expected call to StockRepositoryMock.Upsert at\n%s", m.funcUpsertOrigin)
	}

	if !m.UpsertMock.invocationsDone() && afterUpsertCounter > 0 {
		m.t.Errorf("Expected %d calls to StockRepositoryMock.Upsert at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.UpsertMock.expectedInvocations), m.UpsertMock.expectedInvocationsOrigin, afterUpsertCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *StockRepositoryMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockAddReserveInspect()

			m.MinimockGetBySkuIDInspect()

			m.MinimockReduceReserveAndTotalInspect()

			m.MinimockRemoveReserveInspect()

			m.MinimockUpsertInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *StockRepositoryMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *StockRepositoryMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockAddReserveDone() &&
		m.MinimockGetBySkuIDDone() &&
		m.MinimockReduceReserveAndTotalDone() &&
		m.MinimockRemoveReserveDone() &&
		m.MinimockUpsertDone()
}
