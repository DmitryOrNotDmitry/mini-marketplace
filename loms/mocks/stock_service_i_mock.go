// Code generated by http://github.com/gojuno/minimock (v3.4.5). DO NOT EDIT.

package mocks

//go:generate minimock -i route256/loms/internal/service.StockServiceI -o stock_service_i_mock.go -n StockServiceIMock -p mocks

import (
	"context"
	"route256/loms/internal/domain"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
)

// StockServiceIMock implements mm_service.StockServiceI
type StockServiceIMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcCancelReserveFor          func(ctx context.Context, order *domain.Order) (err error)
	funcCancelReserveForOrigin    string
	inspectFuncCancelReserveFor   func(ctx context.Context, order *domain.Order)
	afterCancelReserveForCounter  uint64
	beforeCancelReserveForCounter uint64
	CancelReserveForMock          mStockServiceIMockCancelReserveFor

	funcConfirmReserveFor          func(ctx context.Context, order *domain.Order) (err error)
	funcConfirmReserveForOrigin    string
	inspectFuncConfirmReserveFor   func(ctx context.Context, order *domain.Order)
	afterConfirmReserveForCounter  uint64
	beforeConfirmReserveForCounter uint64
	ConfirmReserveForMock          mStockServiceIMockConfirmReserveFor

	funcReserveFor          func(ctx context.Context, order *domain.Order) (err error)
	funcReserveForOrigin    string
	inspectFuncReserveFor   func(ctx context.Context, order *domain.Order)
	afterReserveForCounter  uint64
	beforeReserveForCounter uint64
	ReserveForMock          mStockServiceIMockReserveFor
}

// NewStockServiceIMock returns a mock for mm_service.StockServiceI
func NewStockServiceIMock(t minimock.Tester) *StockServiceIMock {
	m := &StockServiceIMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.CancelReserveForMock = mStockServiceIMockCancelReserveFor{mock: m}
	m.CancelReserveForMock.callArgs = []*StockServiceIMockCancelReserveForParams{}

	m.ConfirmReserveForMock = mStockServiceIMockConfirmReserveFor{mock: m}
	m.ConfirmReserveForMock.callArgs = []*StockServiceIMockConfirmReserveForParams{}

	m.ReserveForMock = mStockServiceIMockReserveFor{mock: m}
	m.ReserveForMock.callArgs = []*StockServiceIMockReserveForParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mStockServiceIMockCancelReserveFor struct {
	optional           bool
	mock               *StockServiceIMock
	defaultExpectation *StockServiceIMockCancelReserveForExpectation
	expectations       []*StockServiceIMockCancelReserveForExpectation

	callArgs []*StockServiceIMockCancelReserveForParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// StockServiceIMockCancelReserveForExpectation specifies expectation struct of the StockServiceI.CancelReserveFor
type StockServiceIMockCancelReserveForExpectation struct {
	mock               *StockServiceIMock
	params             *StockServiceIMockCancelReserveForParams
	paramPtrs          *StockServiceIMockCancelReserveForParamPtrs
	expectationOrigins StockServiceIMockCancelReserveForExpectationOrigins
	results            *StockServiceIMockCancelReserveForResults
	returnOrigin       string
	Counter            uint64
}

// StockServiceIMockCancelReserveForParams contains parameters of the StockServiceI.CancelReserveFor
type StockServiceIMockCancelReserveForParams struct {
	ctx   context.Context
	order *domain.Order
}

// StockServiceIMockCancelReserveForParamPtrs contains pointers to parameters of the StockServiceI.CancelReserveFor
type StockServiceIMockCancelReserveForParamPtrs struct {
	ctx   *context.Context
	order **domain.Order
}

// StockServiceIMockCancelReserveForResults contains results of the StockServiceI.CancelReserveFor
type StockServiceIMockCancelReserveForResults struct {
	err error
}

// StockServiceIMockCancelReserveForOrigins contains origins of expectations of the StockServiceI.CancelReserveFor
type StockServiceIMockCancelReserveForExpectationOrigins struct {
	origin      string
	originCtx   string
	originOrder string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmCancelReserveFor *mStockServiceIMockCancelReserveFor) Optional() *mStockServiceIMockCancelReserveFor {
	mmCancelReserveFor.optional = true
	return mmCancelReserveFor
}

// Expect sets up expected params for StockServiceI.CancelReserveFor
func (mmCancelReserveFor *mStockServiceIMockCancelReserveFor) Expect(ctx context.Context, order *domain.Order) *mStockServiceIMockCancelReserveFor {
	if mmCancelReserveFor.mock.funcCancelReserveFor != nil {
		mmCancelReserveFor.mock.t.Fatalf("StockServiceIMock.CancelReserveFor mock is already set by Set")
	}

	if mmCancelReserveFor.defaultExpectation == nil {
		mmCancelReserveFor.defaultExpectation = &StockServiceIMockCancelReserveForExpectation{}
	}

	if mmCancelReserveFor.defaultExpectation.paramPtrs != nil {
		mmCancelReserveFor.mock.t.Fatalf("StockServiceIMock.CancelReserveFor mock is already set by ExpectParams functions")
	}

	mmCancelReserveFor.defaultExpectation.params = &StockServiceIMockCancelReserveForParams{ctx, order}
	mmCancelReserveFor.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmCancelReserveFor.expectations {
		if minimock.Equal(e.params, mmCancelReserveFor.defaultExpectation.params) {
			mmCancelReserveFor.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCancelReserveFor.defaultExpectation.params)
		}
	}

	return mmCancelReserveFor
}

// ExpectCtxParam1 sets up expected param ctx for StockServiceI.CancelReserveFor
func (mmCancelReserveFor *mStockServiceIMockCancelReserveFor) ExpectCtxParam1(ctx context.Context) *mStockServiceIMockCancelReserveFor {
	if mmCancelReserveFor.mock.funcCancelReserveFor != nil {
		mmCancelReserveFor.mock.t.Fatalf("StockServiceIMock.CancelReserveFor mock is already set by Set")
	}

	if mmCancelReserveFor.defaultExpectation == nil {
		mmCancelReserveFor.defaultExpectation = &StockServiceIMockCancelReserveForExpectation{}
	}

	if mmCancelReserveFor.defaultExpectation.params != nil {
		mmCancelReserveFor.mock.t.Fatalf("StockServiceIMock.CancelReserveFor mock is already set by Expect")
	}

	if mmCancelReserveFor.defaultExpectation.paramPtrs == nil {
		mmCancelReserveFor.defaultExpectation.paramPtrs = &StockServiceIMockCancelReserveForParamPtrs{}
	}
	mmCancelReserveFor.defaultExpectation.paramPtrs.ctx = &ctx
	mmCancelReserveFor.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmCancelReserveFor
}

// ExpectOrderParam2 sets up expected param order for StockServiceI.CancelReserveFor
func (mmCancelReserveFor *mStockServiceIMockCancelReserveFor) ExpectOrderParam2(order *domain.Order) *mStockServiceIMockCancelReserveFor {
	if mmCancelReserveFor.mock.funcCancelReserveFor != nil {
		mmCancelReserveFor.mock.t.Fatalf("StockServiceIMock.CancelReserveFor mock is already set by Set")
	}

	if mmCancelReserveFor.defaultExpectation == nil {
		mmCancelReserveFor.defaultExpectation = &StockServiceIMockCancelReserveForExpectation{}
	}

	if mmCancelReserveFor.defaultExpectation.params != nil {
		mmCancelReserveFor.mock.t.Fatalf("StockServiceIMock.CancelReserveFor mock is already set by Expect")
	}

	if mmCancelReserveFor.defaultExpectation.paramPtrs == nil {
		mmCancelReserveFor.defaultExpectation.paramPtrs = &StockServiceIMockCancelReserveForParamPtrs{}
	}
	mmCancelReserveFor.defaultExpectation.paramPtrs.order = &order
	mmCancelReserveFor.defaultExpectation.expectationOrigins.originOrder = minimock.CallerInfo(1)

	return mmCancelReserveFor
}

// Inspect accepts an inspector function that has same arguments as the StockServiceI.CancelReserveFor
func (mmCancelReserveFor *mStockServiceIMockCancelReserveFor) Inspect(f func(ctx context.Context, order *domain.Order)) *mStockServiceIMockCancelReserveFor {
	if mmCancelReserveFor.mock.inspectFuncCancelReserveFor != nil {
		mmCancelReserveFor.mock.t.Fatalf("Inspect function is already set for StockServiceIMock.CancelReserveFor")
	}

	mmCancelReserveFor.mock.inspectFuncCancelReserveFor = f

	return mmCancelReserveFor
}

// Return sets up results that will be returned by StockServiceI.CancelReserveFor
func (mmCancelReserveFor *mStockServiceIMockCancelReserveFor) Return(err error) *StockServiceIMock {
	if mmCancelReserveFor.mock.funcCancelReserveFor != nil {
		mmCancelReserveFor.mock.t.Fatalf("StockServiceIMock.CancelReserveFor mock is already set by Set")
	}

	if mmCancelReserveFor.defaultExpectation == nil {
		mmCancelReserveFor.defaultExpectation = &StockServiceIMockCancelReserveForExpectation{mock: mmCancelReserveFor.mock}
	}
	mmCancelReserveFor.defaultExpectation.results = &StockServiceIMockCancelReserveForResults{err}
	mmCancelReserveFor.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmCancelReserveFor.mock
}

// Set uses given function f to mock the StockServiceI.CancelReserveFor method
func (mmCancelReserveFor *mStockServiceIMockCancelReserveFor) Set(f func(ctx context.Context, order *domain.Order) (err error)) *StockServiceIMock {
	if mmCancelReserveFor.defaultExpectation != nil {
		mmCancelReserveFor.mock.t.Fatalf("Default expectation is already set for the StockServiceI.CancelReserveFor method")
	}

	if len(mmCancelReserveFor.expectations) > 0 {
		mmCancelReserveFor.mock.t.Fatalf("Some expectations are already set for the StockServiceI.CancelReserveFor method")
	}

	mmCancelReserveFor.mock.funcCancelReserveFor = f
	mmCancelReserveFor.mock.funcCancelReserveForOrigin = minimock.CallerInfo(1)
	return mmCancelReserveFor.mock
}

// When sets expectation for the StockServiceI.CancelReserveFor which will trigger the result defined by the following
// Then helper
func (mmCancelReserveFor *mStockServiceIMockCancelReserveFor) When(ctx context.Context, order *domain.Order) *StockServiceIMockCancelReserveForExpectation {
	if mmCancelReserveFor.mock.funcCancelReserveFor != nil {
		mmCancelReserveFor.mock.t.Fatalf("StockServiceIMock.CancelReserveFor mock is already set by Set")
	}

	expectation := &StockServiceIMockCancelReserveForExpectation{
		mock:               mmCancelReserveFor.mock,
		params:             &StockServiceIMockCancelReserveForParams{ctx, order},
		expectationOrigins: StockServiceIMockCancelReserveForExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmCancelReserveFor.expectations = append(mmCancelReserveFor.expectations, expectation)
	return expectation
}

// Then sets up StockServiceI.CancelReserveFor return parameters for the expectation previously defined by the When method
func (e *StockServiceIMockCancelReserveForExpectation) Then(err error) *StockServiceIMock {
	e.results = &StockServiceIMockCancelReserveForResults{err}
	return e.mock
}

// Times sets number of times StockServiceI.CancelReserveFor should be invoked
func (mmCancelReserveFor *mStockServiceIMockCancelReserveFor) Times(n uint64) *mStockServiceIMockCancelReserveFor {
	if n == 0 {
		mmCancelReserveFor.mock.t.Fatalf("Times of StockServiceIMock.CancelReserveFor mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmCancelReserveFor.expectedInvocations, n)
	mmCancelReserveFor.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmCancelReserveFor
}

func (mmCancelReserveFor *mStockServiceIMockCancelReserveFor) invocationsDone() bool {
	if len(mmCancelReserveFor.expectations) == 0 && mmCancelReserveFor.defaultExpectation == nil && mmCancelReserveFor.mock.funcCancelReserveFor == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmCancelReserveFor.mock.afterCancelReserveForCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmCancelReserveFor.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// CancelReserveFor implements mm_service.StockServiceI
func (mmCancelReserveFor *StockServiceIMock) CancelReserveFor(ctx context.Context, order *domain.Order) (err error) {
	mm_atomic.AddUint64(&mmCancelReserveFor.beforeCancelReserveForCounter, 1)
	defer mm_atomic.AddUint64(&mmCancelReserveFor.afterCancelReserveForCounter, 1)

	mmCancelReserveFor.t.Helper()

	if mmCancelReserveFor.inspectFuncCancelReserveFor != nil {
		mmCancelReserveFor.inspectFuncCancelReserveFor(ctx, order)
	}

	mm_params := StockServiceIMockCancelReserveForParams{ctx, order}

	// Record call args
	mmCancelReserveFor.CancelReserveForMock.mutex.Lock()
	mmCancelReserveFor.CancelReserveForMock.callArgs = append(mmCancelReserveFor.CancelReserveForMock.callArgs, &mm_params)
	mmCancelReserveFor.CancelReserveForMock.mutex.Unlock()

	for _, e := range mmCancelReserveFor.CancelReserveForMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmCancelReserveFor.CancelReserveForMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCancelReserveFor.CancelReserveForMock.defaultExpectation.Counter, 1)
		mm_want := mmCancelReserveFor.CancelReserveForMock.defaultExpectation.params
		mm_want_ptrs := mmCancelReserveFor.CancelReserveForMock.defaultExpectation.paramPtrs

		mm_got := StockServiceIMockCancelReserveForParams{ctx, order}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmCancelReserveFor.t.Errorf("StockServiceIMock.CancelReserveFor got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCancelReserveFor.CancelReserveForMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.order != nil && !minimock.Equal(*mm_want_ptrs.order, mm_got.order) {
				mmCancelReserveFor.t.Errorf("StockServiceIMock.CancelReserveFor got unexpected parameter order, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCancelReserveFor.CancelReserveForMock.defaultExpectation.expectationOrigins.originOrder, *mm_want_ptrs.order, mm_got.order, minimock.Diff(*mm_want_ptrs.order, mm_got.order))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCancelReserveFor.t.Errorf("StockServiceIMock.CancelReserveFor got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmCancelReserveFor.CancelReserveForMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCancelReserveFor.CancelReserveForMock.defaultExpectation.results
		if mm_results == nil {
			mmCancelReserveFor.t.Fatal("No results are set for the StockServiceIMock.CancelReserveFor")
		}
		return (*mm_results).err
	}
	if mmCancelReserveFor.funcCancelReserveFor != nil {
		return mmCancelReserveFor.funcCancelReserveFor(ctx, order)
	}
	mmCancelReserveFor.t.Fatalf("Unexpected call to StockServiceIMock.CancelReserveFor. %v %v", ctx, order)
	return
}

// CancelReserveForAfterCounter returns a count of finished StockServiceIMock.CancelReserveFor invocations
func (mmCancelReserveFor *StockServiceIMock) CancelReserveForAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCancelReserveFor.afterCancelReserveForCounter)
}

// CancelReserveForBeforeCounter returns a count of StockServiceIMock.CancelReserveFor invocations
func (mmCancelReserveFor *StockServiceIMock) CancelReserveForBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCancelReserveFor.beforeCancelReserveForCounter)
}

// Calls returns a list of arguments used in each call to StockServiceIMock.CancelReserveFor.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCancelReserveFor *mStockServiceIMockCancelReserveFor) Calls() []*StockServiceIMockCancelReserveForParams {
	mmCancelReserveFor.mutex.RLock()

	argCopy := make([]*StockServiceIMockCancelReserveForParams, len(mmCancelReserveFor.callArgs))
	copy(argCopy, mmCancelReserveFor.callArgs)

	mmCancelReserveFor.mutex.RUnlock()

	return argCopy
}

// MinimockCancelReserveForDone returns true if the count of the CancelReserveFor invocations corresponds
// the number of defined expectations
func (m *StockServiceIMock) MinimockCancelReserveForDone() bool {
	if m.CancelReserveForMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.CancelReserveForMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.CancelReserveForMock.invocationsDone()
}

// MinimockCancelReserveForInspect logs each unmet expectation
func (m *StockServiceIMock) MinimockCancelReserveForInspect() {
	for _, e := range m.CancelReserveForMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to StockServiceIMock.CancelReserveFor at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterCancelReserveForCounter := mm_atomic.LoadUint64(&m.afterCancelReserveForCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.CancelReserveForMock.defaultExpectation != nil && afterCancelReserveForCounter < 1 {
		if m.CancelReserveForMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to StockServiceIMock.CancelReserveFor at\n%s", m.CancelReserveForMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to StockServiceIMock.CancelReserveFor at\n%s with params: %#v", m.CancelReserveForMock.defaultExpectation.expectationOrigins.origin, *m.CancelReserveForMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCancelReserveFor != nil && afterCancelReserveForCounter < 1 {
		m.t.Errorf("Expected call to StockServiceIMock.CancelReserveFor at\n%s", m.funcCancelReserveForOrigin)
	}

	if !m.CancelReserveForMock.invocationsDone() && afterCancelReserveForCounter > 0 {
		m.t.Errorf("Expected %d calls to StockServiceIMock.CancelReserveFor at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.CancelReserveForMock.expectedInvocations), m.CancelReserveForMock.expectedInvocationsOrigin, afterCancelReserveForCounter)
	}
}

type mStockServiceIMockConfirmReserveFor struct {
	optional           bool
	mock               *StockServiceIMock
	defaultExpectation *StockServiceIMockConfirmReserveForExpectation
	expectations       []*StockServiceIMockConfirmReserveForExpectation

	callArgs []*StockServiceIMockConfirmReserveForParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// StockServiceIMockConfirmReserveForExpectation specifies expectation struct of the StockServiceI.ConfirmReserveFor
type StockServiceIMockConfirmReserveForExpectation struct {
	mock               *StockServiceIMock
	params             *StockServiceIMockConfirmReserveForParams
	paramPtrs          *StockServiceIMockConfirmReserveForParamPtrs
	expectationOrigins StockServiceIMockConfirmReserveForExpectationOrigins
	results            *StockServiceIMockConfirmReserveForResults
	returnOrigin       string
	Counter            uint64
}

// StockServiceIMockConfirmReserveForParams contains parameters of the StockServiceI.ConfirmReserveFor
type StockServiceIMockConfirmReserveForParams struct {
	ctx   context.Context
	order *domain.Order
}

// StockServiceIMockConfirmReserveForParamPtrs contains pointers to parameters of the StockServiceI.ConfirmReserveFor
type StockServiceIMockConfirmReserveForParamPtrs struct {
	ctx   *context.Context
	order **domain.Order
}

// StockServiceIMockConfirmReserveForResults contains results of the StockServiceI.ConfirmReserveFor
type StockServiceIMockConfirmReserveForResults struct {
	err error
}

// StockServiceIMockConfirmReserveForOrigins contains origins of expectations of the StockServiceI.ConfirmReserveFor
type StockServiceIMockConfirmReserveForExpectationOrigins struct {
	origin      string
	originCtx   string
	originOrder string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmConfirmReserveFor *mStockServiceIMockConfirmReserveFor) Optional() *mStockServiceIMockConfirmReserveFor {
	mmConfirmReserveFor.optional = true
	return mmConfirmReserveFor
}

// Expect sets up expected params for StockServiceI.ConfirmReserveFor
func (mmConfirmReserveFor *mStockServiceIMockConfirmReserveFor) Expect(ctx context.Context, order *domain.Order) *mStockServiceIMockConfirmReserveFor {
	if mmConfirmReserveFor.mock.funcConfirmReserveFor != nil {
		mmConfirmReserveFor.mock.t.Fatalf("StockServiceIMock.ConfirmReserveFor mock is already set by Set")
	}

	if mmConfirmReserveFor.defaultExpectation == nil {
		mmConfirmReserveFor.defaultExpectation = &StockServiceIMockConfirmReserveForExpectation{}
	}

	if mmConfirmReserveFor.defaultExpectation.paramPtrs != nil {
		mmConfirmReserveFor.mock.t.Fatalf("StockServiceIMock.ConfirmReserveFor mock is already set by ExpectParams functions")
	}

	mmConfirmReserveFor.defaultExpectation.params = &StockServiceIMockConfirmReserveForParams{ctx, order}
	mmConfirmReserveFor.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmConfirmReserveFor.expectations {
		if minimock.Equal(e.params, mmConfirmReserveFor.defaultExpectation.params) {
			mmConfirmReserveFor.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmConfirmReserveFor.defaultExpectation.params)
		}
	}

	return mmConfirmReserveFor
}

// ExpectCtxParam1 sets up expected param ctx for StockServiceI.ConfirmReserveFor
func (mmConfirmReserveFor *mStockServiceIMockConfirmReserveFor) ExpectCtxParam1(ctx context.Context) *mStockServiceIMockConfirmReserveFor {
	if mmConfirmReserveFor.mock.funcConfirmReserveFor != nil {
		mmConfirmReserveFor.mock.t.Fatalf("StockServiceIMock.ConfirmReserveFor mock is already set by Set")
	}

	if mmConfirmReserveFor.defaultExpectation == nil {
		mmConfirmReserveFor.defaultExpectation = &StockServiceIMockConfirmReserveForExpectation{}
	}

	if mmConfirmReserveFor.defaultExpectation.params != nil {
		mmConfirmReserveFor.mock.t.Fatalf("StockServiceIMock.ConfirmReserveFor mock is already set by Expect")
	}

	if mmConfirmReserveFor.defaultExpectation.paramPtrs == nil {
		mmConfirmReserveFor.defaultExpectation.paramPtrs = &StockServiceIMockConfirmReserveForParamPtrs{}
	}
	mmConfirmReserveFor.defaultExpectation.paramPtrs.ctx = &ctx
	mmConfirmReserveFor.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmConfirmReserveFor
}

// ExpectOrderParam2 sets up expected param order for StockServiceI.ConfirmReserveFor
func (mmConfirmReserveFor *mStockServiceIMockConfirmReserveFor) ExpectOrderParam2(order *domain.Order) *mStockServiceIMockConfirmReserveFor {
	if mmConfirmReserveFor.mock.funcConfirmReserveFor != nil {
		mmConfirmReserveFor.mock.t.Fatalf("StockServiceIMock.ConfirmReserveFor mock is already set by Set")
	}

	if mmConfirmReserveFor.defaultExpectation == nil {
		mmConfirmReserveFor.defaultExpectation = &StockServiceIMockConfirmReserveForExpectation{}
	}

	if mmConfirmReserveFor.defaultExpectation.params != nil {
		mmConfirmReserveFor.mock.t.Fatalf("StockServiceIMock.ConfirmReserveFor mock is already set by Expect")
	}

	if mmConfirmReserveFor.defaultExpectation.paramPtrs == nil {
		mmConfirmReserveFor.defaultExpectation.paramPtrs = &StockServiceIMockConfirmReserveForParamPtrs{}
	}
	mmConfirmReserveFor.defaultExpectation.paramPtrs.order = &order
	mmConfirmReserveFor.defaultExpectation.expectationOrigins.originOrder = minimock.CallerInfo(1)

	return mmConfirmReserveFor
}

// Inspect accepts an inspector function that has same arguments as the StockServiceI.ConfirmReserveFor
func (mmConfirmReserveFor *mStockServiceIMockConfirmReserveFor) Inspect(f func(ctx context.Context, order *domain.Order)) *mStockServiceIMockConfirmReserveFor {
	if mmConfirmReserveFor.mock.inspectFuncConfirmReserveFor != nil {
		mmConfirmReserveFor.mock.t.Fatalf("Inspect function is already set for StockServiceIMock.ConfirmReserveFor")
	}

	mmConfirmReserveFor.mock.inspectFuncConfirmReserveFor = f

	return mmConfirmReserveFor
}

// Return sets up results that will be returned by StockServiceI.ConfirmReserveFor
func (mmConfirmReserveFor *mStockServiceIMockConfirmReserveFor) Return(err error) *StockServiceIMock {
	if mmConfirmReserveFor.mock.funcConfirmReserveFor != nil {
		mmConfirmReserveFor.mock.t.Fatalf("StockServiceIMock.ConfirmReserveFor mock is already set by Set")
	}

	if mmConfirmReserveFor.defaultExpectation == nil {
		mmConfirmReserveFor.defaultExpectation = &StockServiceIMockConfirmReserveForExpectation{mock: mmConfirmReserveFor.mock}
	}
	mmConfirmReserveFor.defaultExpectation.results = &StockServiceIMockConfirmReserveForResults{err}
	mmConfirmReserveFor.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmConfirmReserveFor.mock
}

// Set uses given function f to mock the StockServiceI.ConfirmReserveFor method
func (mmConfirmReserveFor *mStockServiceIMockConfirmReserveFor) Set(f func(ctx context.Context, order *domain.Order) (err error)) *StockServiceIMock {
	if mmConfirmReserveFor.defaultExpectation != nil {
		mmConfirmReserveFor.mock.t.Fatalf("Default expectation is already set for the StockServiceI.ConfirmReserveFor method")
	}

	if len(mmConfirmReserveFor.expectations) > 0 {
		mmConfirmReserveFor.mock.t.Fatalf("Some expectations are already set for the StockServiceI.ConfirmReserveFor method")
	}

	mmConfirmReserveFor.mock.funcConfirmReserveFor = f
	mmConfirmReserveFor.mock.funcConfirmReserveForOrigin = minimock.CallerInfo(1)
	return mmConfirmReserveFor.mock
}

// When sets expectation for the StockServiceI.ConfirmReserveFor which will trigger the result defined by the following
// Then helper
func (mmConfirmReserveFor *mStockServiceIMockConfirmReserveFor) When(ctx context.Context, order *domain.Order) *StockServiceIMockConfirmReserveForExpectation {
	if mmConfirmReserveFor.mock.funcConfirmReserveFor != nil {
		mmConfirmReserveFor.mock.t.Fatalf("StockServiceIMock.ConfirmReserveFor mock is already set by Set")
	}

	expectation := &StockServiceIMockConfirmReserveForExpectation{
		mock:               mmConfirmReserveFor.mock,
		params:             &StockServiceIMockConfirmReserveForParams{ctx, order},
		expectationOrigins: StockServiceIMockConfirmReserveForExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmConfirmReserveFor.expectations = append(mmConfirmReserveFor.expectations, expectation)
	return expectation
}

// Then sets up StockServiceI.ConfirmReserveFor return parameters for the expectation previously defined by the When method
func (e *StockServiceIMockConfirmReserveForExpectation) Then(err error) *StockServiceIMock {
	e.results = &StockServiceIMockConfirmReserveForResults{err}
	return e.mock
}

// Times sets number of times StockServiceI.ConfirmReserveFor should be invoked
func (mmConfirmReserveFor *mStockServiceIMockConfirmReserveFor) Times(n uint64) *mStockServiceIMockConfirmReserveFor {
	if n == 0 {
		mmConfirmReserveFor.mock.t.Fatalf("Times of StockServiceIMock.ConfirmReserveFor mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmConfirmReserveFor.expectedInvocations, n)
	mmConfirmReserveFor.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmConfirmReserveFor
}

func (mmConfirmReserveFor *mStockServiceIMockConfirmReserveFor) invocationsDone() bool {
	if len(mmConfirmReserveFor.expectations) == 0 && mmConfirmReserveFor.defaultExpectation == nil && mmConfirmReserveFor.mock.funcConfirmReserveFor == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmConfirmReserveFor.mock.afterConfirmReserveForCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmConfirmReserveFor.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// ConfirmReserveFor implements mm_service.StockServiceI
func (mmConfirmReserveFor *StockServiceIMock) ConfirmReserveFor(ctx context.Context, order *domain.Order) (err error) {
	mm_atomic.AddUint64(&mmConfirmReserveFor.beforeConfirmReserveForCounter, 1)
	defer mm_atomic.AddUint64(&mmConfirmReserveFor.afterConfirmReserveForCounter, 1)

	mmConfirmReserveFor.t.Helper()

	if mmConfirmReserveFor.inspectFuncConfirmReserveFor != nil {
		mmConfirmReserveFor.inspectFuncConfirmReserveFor(ctx, order)
	}

	mm_params := StockServiceIMockConfirmReserveForParams{ctx, order}

	// Record call args
	mmConfirmReserveFor.ConfirmReserveForMock.mutex.Lock()
	mmConfirmReserveFor.ConfirmReserveForMock.callArgs = append(mmConfirmReserveFor.ConfirmReserveForMock.callArgs, &mm_params)
	mmConfirmReserveFor.ConfirmReserveForMock.mutex.Unlock()

	for _, e := range mmConfirmReserveFor.ConfirmReserveForMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmConfirmReserveFor.ConfirmReserveForMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmConfirmReserveFor.ConfirmReserveForMock.defaultExpectation.Counter, 1)
		mm_want := mmConfirmReserveFor.ConfirmReserveForMock.defaultExpectation.params
		mm_want_ptrs := mmConfirmReserveFor.ConfirmReserveForMock.defaultExpectation.paramPtrs

		mm_got := StockServiceIMockConfirmReserveForParams{ctx, order}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmConfirmReserveFor.t.Errorf("StockServiceIMock.ConfirmReserveFor got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmConfirmReserveFor.ConfirmReserveForMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.order != nil && !minimock.Equal(*mm_want_ptrs.order, mm_got.order) {
				mmConfirmReserveFor.t.Errorf("StockServiceIMock.ConfirmReserveFor got unexpected parameter order, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmConfirmReserveFor.ConfirmReserveForMock.defaultExpectation.expectationOrigins.originOrder, *mm_want_ptrs.order, mm_got.order, minimock.Diff(*mm_want_ptrs.order, mm_got.order))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmConfirmReserveFor.t.Errorf("StockServiceIMock.ConfirmReserveFor got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmConfirmReserveFor.ConfirmReserveForMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmConfirmReserveFor.ConfirmReserveForMock.defaultExpectation.results
		if mm_results == nil {
			mmConfirmReserveFor.t.Fatal("No results are set for the StockServiceIMock.ConfirmReserveFor")
		}
		return (*mm_results).err
	}
	if mmConfirmReserveFor.funcConfirmReserveFor != nil {
		return mmConfirmReserveFor.funcConfirmReserveFor(ctx, order)
	}
	mmConfirmReserveFor.t.Fatalf("Unexpected call to StockServiceIMock.ConfirmReserveFor. %v %v", ctx, order)
	return
}

// ConfirmReserveForAfterCounter returns a count of finished StockServiceIMock.ConfirmReserveFor invocations
func (mmConfirmReserveFor *StockServiceIMock) ConfirmReserveForAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmConfirmReserveFor.afterConfirmReserveForCounter)
}

// ConfirmReserveForBeforeCounter returns a count of StockServiceIMock.ConfirmReserveFor invocations
func (mmConfirmReserveFor *StockServiceIMock) ConfirmReserveForBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmConfirmReserveFor.beforeConfirmReserveForCounter)
}

// Calls returns a list of arguments used in each call to StockServiceIMock.ConfirmReserveFor.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmConfirmReserveFor *mStockServiceIMockConfirmReserveFor) Calls() []*StockServiceIMockConfirmReserveForParams {
	mmConfirmReserveFor.mutex.RLock()

	argCopy := make([]*StockServiceIMockConfirmReserveForParams, len(mmConfirmReserveFor.callArgs))
	copy(argCopy, mmConfirmReserveFor.callArgs)

	mmConfirmReserveFor.mutex.RUnlock()

	return argCopy
}

// MinimockConfirmReserveForDone returns true if the count of the ConfirmReserveFor invocations corresponds
// the number of defined expectations
func (m *StockServiceIMock) MinimockConfirmReserveForDone() bool {
	if m.ConfirmReserveForMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ConfirmReserveForMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ConfirmReserveForMock.invocationsDone()
}

// MinimockConfirmReserveForInspect logs each unmet expectation
func (m *StockServiceIMock) MinimockConfirmReserveForInspect() {
	for _, e := range m.ConfirmReserveForMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to StockServiceIMock.ConfirmReserveFor at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterConfirmReserveForCounter := mm_atomic.LoadUint64(&m.afterConfirmReserveForCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ConfirmReserveForMock.defaultExpectation != nil && afterConfirmReserveForCounter < 1 {
		if m.ConfirmReserveForMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to StockServiceIMock.ConfirmReserveFor at\n%s", m.ConfirmReserveForMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to StockServiceIMock.ConfirmReserveFor at\n%s with params: %#v", m.ConfirmReserveForMock.defaultExpectation.expectationOrigins.origin, *m.ConfirmReserveForMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcConfirmReserveFor != nil && afterConfirmReserveForCounter < 1 {
		m.t.Errorf("Expected call to StockServiceIMock.ConfirmReserveFor at\n%s", m.funcConfirmReserveForOrigin)
	}

	if !m.ConfirmReserveForMock.invocationsDone() && afterConfirmReserveForCounter > 0 {
		m.t.Errorf("Expected %d calls to StockServiceIMock.ConfirmReserveFor at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.ConfirmReserveForMock.expectedInvocations), m.ConfirmReserveForMock.expectedInvocationsOrigin, afterConfirmReserveForCounter)
	}
}

type mStockServiceIMockReserveFor struct {
	optional           bool
	mock               *StockServiceIMock
	defaultExpectation *StockServiceIMockReserveForExpectation
	expectations       []*StockServiceIMockReserveForExpectation

	callArgs []*StockServiceIMockReserveForParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// StockServiceIMockReserveForExpectation specifies expectation struct of the StockServiceI.ReserveFor
type StockServiceIMockReserveForExpectation struct {
	mock               *StockServiceIMock
	params             *StockServiceIMockReserveForParams
	paramPtrs          *StockServiceIMockReserveForParamPtrs
	expectationOrigins StockServiceIMockReserveForExpectationOrigins
	results            *StockServiceIMockReserveForResults
	returnOrigin       string
	Counter            uint64
}

// StockServiceIMockReserveForParams contains parameters of the StockServiceI.ReserveFor
type StockServiceIMockReserveForParams struct {
	ctx   context.Context
	order *domain.Order
}

// StockServiceIMockReserveForParamPtrs contains pointers to parameters of the StockServiceI.ReserveFor
type StockServiceIMockReserveForParamPtrs struct {
	ctx   *context.Context
	order **domain.Order
}

// StockServiceIMockReserveForResults contains results of the StockServiceI.ReserveFor
type StockServiceIMockReserveForResults struct {
	err error
}

// StockServiceIMockReserveForOrigins contains origins of expectations of the StockServiceI.ReserveFor
type StockServiceIMockReserveForExpectationOrigins struct {
	origin      string
	originCtx   string
	originOrder string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmReserveFor *mStockServiceIMockReserveFor) Optional() *mStockServiceIMockReserveFor {
	mmReserveFor.optional = true
	return mmReserveFor
}

// Expect sets up expected params for StockServiceI.ReserveFor
func (mmReserveFor *mStockServiceIMockReserveFor) Expect(ctx context.Context, order *domain.Order) *mStockServiceIMockReserveFor {
	if mmReserveFor.mock.funcReserveFor != nil {
		mmReserveFor.mock.t.Fatalf("StockServiceIMock.ReserveFor mock is already set by Set")
	}

	if mmReserveFor.defaultExpectation == nil {
		mmReserveFor.defaultExpectation = &StockServiceIMockReserveForExpectation{}
	}

	if mmReserveFor.defaultExpectation.paramPtrs != nil {
		mmReserveFor.mock.t.Fatalf("StockServiceIMock.ReserveFor mock is already set by ExpectParams functions")
	}

	mmReserveFor.defaultExpectation.params = &StockServiceIMockReserveForParams{ctx, order}
	mmReserveFor.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmReserveFor.expectations {
		if minimock.Equal(e.params, mmReserveFor.defaultExpectation.params) {
			mmReserveFor.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmReserveFor.defaultExpectation.params)
		}
	}

	return mmReserveFor
}

// ExpectCtxParam1 sets up expected param ctx for StockServiceI.ReserveFor
func (mmReserveFor *mStockServiceIMockReserveFor) ExpectCtxParam1(ctx context.Context) *mStockServiceIMockReserveFor {
	if mmReserveFor.mock.funcReserveFor != nil {
		mmReserveFor.mock.t.Fatalf("StockServiceIMock.ReserveFor mock is already set by Set")
	}

	if mmReserveFor.defaultExpectation == nil {
		mmReserveFor.defaultExpectation = &StockServiceIMockReserveForExpectation{}
	}

	if mmReserveFor.defaultExpectation.params != nil {
		mmReserveFor.mock.t.Fatalf("StockServiceIMock.ReserveFor mock is already set by Expect")
	}

	if mmReserveFor.defaultExpectation.paramPtrs == nil {
		mmReserveFor.defaultExpectation.paramPtrs = &StockServiceIMockReserveForParamPtrs{}
	}
	mmReserveFor.defaultExpectation.paramPtrs.ctx = &ctx
	mmReserveFor.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmReserveFor
}

// ExpectOrderParam2 sets up expected param order for StockServiceI.ReserveFor
func (mmReserveFor *mStockServiceIMockReserveFor) ExpectOrderParam2(order *domain.Order) *mStockServiceIMockReserveFor {
	if mmReserveFor.mock.funcReserveFor != nil {
		mmReserveFor.mock.t.Fatalf("StockServiceIMock.ReserveFor mock is already set by Set")
	}

	if mmReserveFor.defaultExpectation == nil {
		mmReserveFor.defaultExpectation = &StockServiceIMockReserveForExpectation{}
	}

	if mmReserveFor.defaultExpectation.params != nil {
		mmReserveFor.mock.t.Fatalf("StockServiceIMock.ReserveFor mock is already set by Expect")
	}

	if mmReserveFor.defaultExpectation.paramPtrs == nil {
		mmReserveFor.defaultExpectation.paramPtrs = &StockServiceIMockReserveForParamPtrs{}
	}
	mmReserveFor.defaultExpectation.paramPtrs.order = &order
	mmReserveFor.defaultExpectation.expectationOrigins.originOrder = minimock.CallerInfo(1)

	return mmReserveFor
}

// Inspect accepts an inspector function that has same arguments as the StockServiceI.ReserveFor
func (mmReserveFor *mStockServiceIMockReserveFor) Inspect(f func(ctx context.Context, order *domain.Order)) *mStockServiceIMockReserveFor {
	if mmReserveFor.mock.inspectFuncReserveFor != nil {
		mmReserveFor.mock.t.Fatalf("Inspect function is already set for StockServiceIMock.ReserveFor")
	}

	mmReserveFor.mock.inspectFuncReserveFor = f

	return mmReserveFor
}

// Return sets up results that will be returned by StockServiceI.ReserveFor
func (mmReserveFor *mStockServiceIMockReserveFor) Return(err error) *StockServiceIMock {
	if mmReserveFor.mock.funcReserveFor != nil {
		mmReserveFor.mock.t.Fatalf("StockServiceIMock.ReserveFor mock is already set by Set")
	}

	if mmReserveFor.defaultExpectation == nil {
		mmReserveFor.defaultExpectation = &StockServiceIMockReserveForExpectation{mock: mmReserveFor.mock}
	}
	mmReserveFor.defaultExpectation.results = &StockServiceIMockReserveForResults{err}
	mmReserveFor.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmReserveFor.mock
}

// Set uses given function f to mock the StockServiceI.ReserveFor method
func (mmReserveFor *mStockServiceIMockReserveFor) Set(f func(ctx context.Context, order *domain.Order) (err error)) *StockServiceIMock {
	if mmReserveFor.defaultExpectation != nil {
		mmReserveFor.mock.t.Fatalf("Default expectation is already set for the StockServiceI.ReserveFor method")
	}

	if len(mmReserveFor.expectations) > 0 {
		mmReserveFor.mock.t.Fatalf("Some expectations are already set for the StockServiceI.ReserveFor method")
	}

	mmReserveFor.mock.funcReserveFor = f
	mmReserveFor.mock.funcReserveForOrigin = minimock.CallerInfo(1)
	return mmReserveFor.mock
}

// When sets expectation for the StockServiceI.ReserveFor which will trigger the result defined by the following
// Then helper
func (mmReserveFor *mStockServiceIMockReserveFor) When(ctx context.Context, order *domain.Order) *StockServiceIMockReserveForExpectation {
	if mmReserveFor.mock.funcReserveFor != nil {
		mmReserveFor.mock.t.Fatalf("StockServiceIMock.ReserveFor mock is already set by Set")
	}

	expectation := &StockServiceIMockReserveForExpectation{
		mock:               mmReserveFor.mock,
		params:             &StockServiceIMockReserveForParams{ctx, order},
		expectationOrigins: StockServiceIMockReserveForExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmReserveFor.expectations = append(mmReserveFor.expectations, expectation)
	return expectation
}

// Then sets up StockServiceI.ReserveFor return parameters for the expectation previously defined by the When method
func (e *StockServiceIMockReserveForExpectation) Then(err error) *StockServiceIMock {
	e.results = &StockServiceIMockReserveForResults{err}
	return e.mock
}

// Times sets number of times StockServiceI.ReserveFor should be invoked
func (mmReserveFor *mStockServiceIMockReserveFor) Times(n uint64) *mStockServiceIMockReserveFor {
	if n == 0 {
		mmReserveFor.mock.t.Fatalf("Times of StockServiceIMock.ReserveFor mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmReserveFor.expectedInvocations, n)
	mmReserveFor.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmReserveFor
}

func (mmReserveFor *mStockServiceIMockReserveFor) invocationsDone() bool {
	if len(mmReserveFor.expectations) == 0 && mmReserveFor.defaultExpectation == nil && mmReserveFor.mock.funcReserveFor == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmReserveFor.mock.afterReserveForCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmReserveFor.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// ReserveFor implements mm_service.StockServiceI
func (mmReserveFor *StockServiceIMock) ReserveFor(ctx context.Context, order *domain.Order) (err error) {
	mm_atomic.AddUint64(&mmReserveFor.beforeReserveForCounter, 1)
	defer mm_atomic.AddUint64(&mmReserveFor.afterReserveForCounter, 1)

	mmReserveFor.t.Helper()

	if mmReserveFor.inspectFuncReserveFor != nil {
		mmReserveFor.inspectFuncReserveFor(ctx, order)
	}

	mm_params := StockServiceIMockReserveForParams{ctx, order}

	// Record call args
	mmReserveFor.ReserveForMock.mutex.Lock()
	mmReserveFor.ReserveForMock.callArgs = append(mmReserveFor.ReserveForMock.callArgs, &mm_params)
	mmReserveFor.ReserveForMock.mutex.Unlock()

	for _, e := range mmReserveFor.ReserveForMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmReserveFor.ReserveForMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmReserveFor.ReserveForMock.defaultExpectation.Counter, 1)
		mm_want := mmReserveFor.ReserveForMock.defaultExpectation.params
		mm_want_ptrs := mmReserveFor.ReserveForMock.defaultExpectation.paramPtrs

		mm_got := StockServiceIMockReserveForParams{ctx, order}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmReserveFor.t.Errorf("StockServiceIMock.ReserveFor got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmReserveFor.ReserveForMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.order != nil && !minimock.Equal(*mm_want_ptrs.order, mm_got.order) {
				mmReserveFor.t.Errorf("StockServiceIMock.ReserveFor got unexpected parameter order, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmReserveFor.ReserveForMock.defaultExpectation.expectationOrigins.originOrder, *mm_want_ptrs.order, mm_got.order, minimock.Diff(*mm_want_ptrs.order, mm_got.order))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmReserveFor.t.Errorf("StockServiceIMock.ReserveFor got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmReserveFor.ReserveForMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmReserveFor.ReserveForMock.defaultExpectation.results
		if mm_results == nil {
			mmReserveFor.t.Fatal("No results are set for the StockServiceIMock.ReserveFor")
		}
		return (*mm_results).err
	}
	if mmReserveFor.funcReserveFor != nil {
		return mmReserveFor.funcReserveFor(ctx, order)
	}
	mmReserveFor.t.Fatalf("Unexpected call to StockServiceIMock.ReserveFor. %v %v", ctx, order)
	return
}

// ReserveForAfterCounter returns a count of finished StockServiceIMock.ReserveFor invocations
func (mmReserveFor *StockServiceIMock) ReserveForAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmReserveFor.afterReserveForCounter)
}

// ReserveForBeforeCounter returns a count of StockServiceIMock.ReserveFor invocations
func (mmReserveFor *StockServiceIMock) ReserveForBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmReserveFor.beforeReserveForCounter)
}

// Calls returns a list of arguments used in each call to StockServiceIMock.ReserveFor.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmReserveFor *mStockServiceIMockReserveFor) Calls() []*StockServiceIMockReserveForParams {
	mmReserveFor.mutex.RLock()

	argCopy := make([]*StockServiceIMockReserveForParams, len(mmReserveFor.callArgs))
	copy(argCopy, mmReserveFor.callArgs)

	mmReserveFor.mutex.RUnlock()

	return argCopy
}

// MinimockReserveForDone returns true if the count of the ReserveFor invocations corresponds
// the number of defined expectations
func (m *StockServiceIMock) MinimockReserveForDone() bool {
	if m.ReserveForMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ReserveForMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ReserveForMock.invocationsDone()
}

// MinimockReserveForInspect logs each unmet expectation
func (m *StockServiceIMock) MinimockReserveForInspect() {
	for _, e := range m.ReserveForMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to StockServiceIMock.ReserveFor at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterReserveForCounter := mm_atomic.LoadUint64(&m.afterReserveForCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ReserveForMock.defaultExpectation != nil && afterReserveForCounter < 1 {
		if m.ReserveForMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to StockServiceIMock.ReserveFor at\n%s", m.ReserveForMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to StockServiceIMock.ReserveFor at\n%s with params: %#v", m.ReserveForMock.defaultExpectation.expectationOrigins.origin, *m.ReserveForMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcReserveFor != nil && afterReserveForCounter < 1 {
		m.t.Errorf("Expected call to StockServiceIMock.ReserveFor at\n%s", m.funcReserveForOrigin)
	}

	if !m.ReserveForMock.invocationsDone() && afterReserveForCounter > 0 {
		m.t.Errorf("Expected %d calls to StockServiceIMock.ReserveFor at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.ReserveForMock.expectedInvocations), m.ReserveForMock.expectedInvocationsOrigin, afterReserveForCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *StockServiceIMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockCancelReserveForInspect()

			m.MinimockConfirmReserveForInspect()

			m.MinimockReserveForInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *StockServiceIMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *StockServiceIMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockCancelReserveForDone() &&
		m.MinimockConfirmReserveForDone() &&
		m.MinimockReserveForDone()
}
