// Code generated by http://github.com/gojuno/minimock (v3.4.5). DO NOT EDIT.

package mocks

//go:generate minimock -i route256/loms/internal/handler.OrderService -o order_service_mock.go -n OrderServiceMock -p mocks

import (
	"context"
	"route256/loms/internal/domain"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
)

// OrderServiceMock implements mm_handler.OrderService
type OrderServiceMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcCancelByID          func(ctx context.Context, orderID int64) (err error)
	funcCancelByIDOrigin    string
	inspectFuncCancelByID   func(ctx context.Context, orderID int64)
	afterCancelByIDCounter  uint64
	beforeCancelByIDCounter uint64
	CancelByIDMock          mOrderServiceMockCancelByID

	funcCreate          func(ctx context.Context, order *domain.Order) (i1 int64, err error)
	funcCreateOrigin    string
	inspectFuncCreate   func(ctx context.Context, order *domain.Order)
	afterCreateCounter  uint64
	beforeCreateCounter uint64
	CreateMock          mOrderServiceMockCreate

	funcGetInfoByID          func(ctx context.Context, orderID int64) (op1 *domain.Order, err error)
	funcGetInfoByIDOrigin    string
	inspectFuncGetInfoByID   func(ctx context.Context, orderID int64)
	afterGetInfoByIDCounter  uint64
	beforeGetInfoByIDCounter uint64
	GetInfoByIDMock          mOrderServiceMockGetInfoByID

	funcPayByID          func(ctx context.Context, orderID int64) (err error)
	funcPayByIDOrigin    string
	inspectFuncPayByID   func(ctx context.Context, orderID int64)
	afterPayByIDCounter  uint64
	beforePayByIDCounter uint64
	PayByIDMock          mOrderServiceMockPayByID
}

// NewOrderServiceMock returns a mock for mm_handler.OrderService
func NewOrderServiceMock(t minimock.Tester) *OrderServiceMock {
	m := &OrderServiceMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.CancelByIDMock = mOrderServiceMockCancelByID{mock: m}
	m.CancelByIDMock.callArgs = []*OrderServiceMockCancelByIDParams{}

	m.CreateMock = mOrderServiceMockCreate{mock: m}
	m.CreateMock.callArgs = []*OrderServiceMockCreateParams{}

	m.GetInfoByIDMock = mOrderServiceMockGetInfoByID{mock: m}
	m.GetInfoByIDMock.callArgs = []*OrderServiceMockGetInfoByIDParams{}

	m.PayByIDMock = mOrderServiceMockPayByID{mock: m}
	m.PayByIDMock.callArgs = []*OrderServiceMockPayByIDParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mOrderServiceMockCancelByID struct {
	optional           bool
	mock               *OrderServiceMock
	defaultExpectation *OrderServiceMockCancelByIDExpectation
	expectations       []*OrderServiceMockCancelByIDExpectation

	callArgs []*OrderServiceMockCancelByIDParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// OrderServiceMockCancelByIDExpectation specifies expectation struct of the OrderService.CancelByID
type OrderServiceMockCancelByIDExpectation struct {
	mock               *OrderServiceMock
	params             *OrderServiceMockCancelByIDParams
	paramPtrs          *OrderServiceMockCancelByIDParamPtrs
	expectationOrigins OrderServiceMockCancelByIDExpectationOrigins
	results            *OrderServiceMockCancelByIDResults
	returnOrigin       string
	Counter            uint64
}

// OrderServiceMockCancelByIDParams contains parameters of the OrderService.CancelByID
type OrderServiceMockCancelByIDParams struct {
	ctx     context.Context
	orderID int64
}

// OrderServiceMockCancelByIDParamPtrs contains pointers to parameters of the OrderService.CancelByID
type OrderServiceMockCancelByIDParamPtrs struct {
	ctx     *context.Context
	orderID *int64
}

// OrderServiceMockCancelByIDResults contains results of the OrderService.CancelByID
type OrderServiceMockCancelByIDResults struct {
	err error
}

// OrderServiceMockCancelByIDOrigins contains origins of expectations of the OrderService.CancelByID
type OrderServiceMockCancelByIDExpectationOrigins struct {
	origin        string
	originCtx     string
	originOrderID string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmCancelByID *mOrderServiceMockCancelByID) Optional() *mOrderServiceMockCancelByID {
	mmCancelByID.optional = true
	return mmCancelByID
}

// Expect sets up expected params for OrderService.CancelByID
func (mmCancelByID *mOrderServiceMockCancelByID) Expect(ctx context.Context, orderID int64) *mOrderServiceMockCancelByID {
	if mmCancelByID.mock.funcCancelByID != nil {
		mmCancelByID.mock.t.Fatalf("OrderServiceMock.CancelByID mock is already set by Set")
	}

	if mmCancelByID.defaultExpectation == nil {
		mmCancelByID.defaultExpectation = &OrderServiceMockCancelByIDExpectation{}
	}

	if mmCancelByID.defaultExpectation.paramPtrs != nil {
		mmCancelByID.mock.t.Fatalf("OrderServiceMock.CancelByID mock is already set by ExpectParams functions")
	}

	mmCancelByID.defaultExpectation.params = &OrderServiceMockCancelByIDParams{ctx, orderID}
	mmCancelByID.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmCancelByID.expectations {
		if minimock.Equal(e.params, mmCancelByID.defaultExpectation.params) {
			mmCancelByID.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCancelByID.defaultExpectation.params)
		}
	}

	return mmCancelByID
}

// ExpectCtxParam1 sets up expected param ctx for OrderService.CancelByID
func (mmCancelByID *mOrderServiceMockCancelByID) ExpectCtxParam1(ctx context.Context) *mOrderServiceMockCancelByID {
	if mmCancelByID.mock.funcCancelByID != nil {
		mmCancelByID.mock.t.Fatalf("OrderServiceMock.CancelByID mock is already set by Set")
	}

	if mmCancelByID.defaultExpectation == nil {
		mmCancelByID.defaultExpectation = &OrderServiceMockCancelByIDExpectation{}
	}

	if mmCancelByID.defaultExpectation.params != nil {
		mmCancelByID.mock.t.Fatalf("OrderServiceMock.CancelByID mock is already set by Expect")
	}

	if mmCancelByID.defaultExpectation.paramPtrs == nil {
		mmCancelByID.defaultExpectation.paramPtrs = &OrderServiceMockCancelByIDParamPtrs{}
	}
	mmCancelByID.defaultExpectation.paramPtrs.ctx = &ctx
	mmCancelByID.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmCancelByID
}

// ExpectOrderIDParam2 sets up expected param orderID for OrderService.CancelByID
func (mmCancelByID *mOrderServiceMockCancelByID) ExpectOrderIDParam2(orderID int64) *mOrderServiceMockCancelByID {
	if mmCancelByID.mock.funcCancelByID != nil {
		mmCancelByID.mock.t.Fatalf("OrderServiceMock.CancelByID mock is already set by Set")
	}

	if mmCancelByID.defaultExpectation == nil {
		mmCancelByID.defaultExpectation = &OrderServiceMockCancelByIDExpectation{}
	}

	if mmCancelByID.defaultExpectation.params != nil {
		mmCancelByID.mock.t.Fatalf("OrderServiceMock.CancelByID mock is already set by Expect")
	}

	if mmCancelByID.defaultExpectation.paramPtrs == nil {
		mmCancelByID.defaultExpectation.paramPtrs = &OrderServiceMockCancelByIDParamPtrs{}
	}
	mmCancelByID.defaultExpectation.paramPtrs.orderID = &orderID
	mmCancelByID.defaultExpectation.expectationOrigins.originOrderID = minimock.CallerInfo(1)

	return mmCancelByID
}

// Inspect accepts an inspector function that has same arguments as the OrderService.CancelByID
func (mmCancelByID *mOrderServiceMockCancelByID) Inspect(f func(ctx context.Context, orderID int64)) *mOrderServiceMockCancelByID {
	if mmCancelByID.mock.inspectFuncCancelByID != nil {
		mmCancelByID.mock.t.Fatalf("Inspect function is already set for OrderServiceMock.CancelByID")
	}

	mmCancelByID.mock.inspectFuncCancelByID = f

	return mmCancelByID
}

// Return sets up results that will be returned by OrderService.CancelByID
func (mmCancelByID *mOrderServiceMockCancelByID) Return(err error) *OrderServiceMock {
	if mmCancelByID.mock.funcCancelByID != nil {
		mmCancelByID.mock.t.Fatalf("OrderServiceMock.CancelByID mock is already set by Set")
	}

	if mmCancelByID.defaultExpectation == nil {
		mmCancelByID.defaultExpectation = &OrderServiceMockCancelByIDExpectation{mock: mmCancelByID.mock}
	}
	mmCancelByID.defaultExpectation.results = &OrderServiceMockCancelByIDResults{err}
	mmCancelByID.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmCancelByID.mock
}

// Set uses given function f to mock the OrderService.CancelByID method
func (mmCancelByID *mOrderServiceMockCancelByID) Set(f func(ctx context.Context, orderID int64) (err error)) *OrderServiceMock {
	if mmCancelByID.defaultExpectation != nil {
		mmCancelByID.mock.t.Fatalf("Default expectation is already set for the OrderService.CancelByID method")
	}

	if len(mmCancelByID.expectations) > 0 {
		mmCancelByID.mock.t.Fatalf("Some expectations are already set for the OrderService.CancelByID method")
	}

	mmCancelByID.mock.funcCancelByID = f
	mmCancelByID.mock.funcCancelByIDOrigin = minimock.CallerInfo(1)
	return mmCancelByID.mock
}

// When sets expectation for the OrderService.CancelByID which will trigger the result defined by the following
// Then helper
func (mmCancelByID *mOrderServiceMockCancelByID) When(ctx context.Context, orderID int64) *OrderServiceMockCancelByIDExpectation {
	if mmCancelByID.mock.funcCancelByID != nil {
		mmCancelByID.mock.t.Fatalf("OrderServiceMock.CancelByID mock is already set by Set")
	}

	expectation := &OrderServiceMockCancelByIDExpectation{
		mock:               mmCancelByID.mock,
		params:             &OrderServiceMockCancelByIDParams{ctx, orderID},
		expectationOrigins: OrderServiceMockCancelByIDExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmCancelByID.expectations = append(mmCancelByID.expectations, expectation)
	return expectation
}

// Then sets up OrderService.CancelByID return parameters for the expectation previously defined by the When method
func (e *OrderServiceMockCancelByIDExpectation) Then(err error) *OrderServiceMock {
	e.results = &OrderServiceMockCancelByIDResults{err}
	return e.mock
}

// Times sets number of times OrderService.CancelByID should be invoked
func (mmCancelByID *mOrderServiceMockCancelByID) Times(n uint64) *mOrderServiceMockCancelByID {
	if n == 0 {
		mmCancelByID.mock.t.Fatalf("Times of OrderServiceMock.CancelByID mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmCancelByID.expectedInvocations, n)
	mmCancelByID.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmCancelByID
}

func (mmCancelByID *mOrderServiceMockCancelByID) invocationsDone() bool {
	if len(mmCancelByID.expectations) == 0 && mmCancelByID.defaultExpectation == nil && mmCancelByID.mock.funcCancelByID == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmCancelByID.mock.afterCancelByIDCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmCancelByID.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// CancelByID implements mm_handler.OrderService
func (mmCancelByID *OrderServiceMock) CancelByID(ctx context.Context, orderID int64) (err error) {
	mm_atomic.AddUint64(&mmCancelByID.beforeCancelByIDCounter, 1)
	defer mm_atomic.AddUint64(&mmCancelByID.afterCancelByIDCounter, 1)

	mmCancelByID.t.Helper()

	if mmCancelByID.inspectFuncCancelByID != nil {
		mmCancelByID.inspectFuncCancelByID(ctx, orderID)
	}

	mm_params := OrderServiceMockCancelByIDParams{ctx, orderID}

	// Record call args
	mmCancelByID.CancelByIDMock.mutex.Lock()
	mmCancelByID.CancelByIDMock.callArgs = append(mmCancelByID.CancelByIDMock.callArgs, &mm_params)
	mmCancelByID.CancelByIDMock.mutex.Unlock()

	for _, e := range mmCancelByID.CancelByIDMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmCancelByID.CancelByIDMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCancelByID.CancelByIDMock.defaultExpectation.Counter, 1)
		mm_want := mmCancelByID.CancelByIDMock.defaultExpectation.params
		mm_want_ptrs := mmCancelByID.CancelByIDMock.defaultExpectation.paramPtrs

		mm_got := OrderServiceMockCancelByIDParams{ctx, orderID}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmCancelByID.t.Errorf("OrderServiceMock.CancelByID got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCancelByID.CancelByIDMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.orderID != nil && !minimock.Equal(*mm_want_ptrs.orderID, mm_got.orderID) {
				mmCancelByID.t.Errorf("OrderServiceMock.CancelByID got unexpected parameter orderID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCancelByID.CancelByIDMock.defaultExpectation.expectationOrigins.originOrderID, *mm_want_ptrs.orderID, mm_got.orderID, minimock.Diff(*mm_want_ptrs.orderID, mm_got.orderID))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCancelByID.t.Errorf("OrderServiceMock.CancelByID got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmCancelByID.CancelByIDMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCancelByID.CancelByIDMock.defaultExpectation.results
		if mm_results == nil {
			mmCancelByID.t.Fatal("No results are set for the OrderServiceMock.CancelByID")
		}
		return (*mm_results).err
	}
	if mmCancelByID.funcCancelByID != nil {
		return mmCancelByID.funcCancelByID(ctx, orderID)
	}
	mmCancelByID.t.Fatalf("Unexpected call to OrderServiceMock.CancelByID. %v %v", ctx, orderID)
	return
}

// CancelByIDAfterCounter returns a count of finished OrderServiceMock.CancelByID invocations
func (mmCancelByID *OrderServiceMock) CancelByIDAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCancelByID.afterCancelByIDCounter)
}

// CancelByIDBeforeCounter returns a count of OrderServiceMock.CancelByID invocations
func (mmCancelByID *OrderServiceMock) CancelByIDBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCancelByID.beforeCancelByIDCounter)
}

// Calls returns a list of arguments used in each call to OrderServiceMock.CancelByID.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCancelByID *mOrderServiceMockCancelByID) Calls() []*OrderServiceMockCancelByIDParams {
	mmCancelByID.mutex.RLock()

	argCopy := make([]*OrderServiceMockCancelByIDParams, len(mmCancelByID.callArgs))
	copy(argCopy, mmCancelByID.callArgs)

	mmCancelByID.mutex.RUnlock()

	return argCopy
}

// MinimockCancelByIDDone returns true if the count of the CancelByID invocations corresponds
// the number of defined expectations
func (m *OrderServiceMock) MinimockCancelByIDDone() bool {
	if m.CancelByIDMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.CancelByIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.CancelByIDMock.invocationsDone()
}

// MinimockCancelByIDInspect logs each unmet expectation
func (m *OrderServiceMock) MinimockCancelByIDInspect() {
	for _, e := range m.CancelByIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to OrderServiceMock.CancelByID at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterCancelByIDCounter := mm_atomic.LoadUint64(&m.afterCancelByIDCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.CancelByIDMock.defaultExpectation != nil && afterCancelByIDCounter < 1 {
		if m.CancelByIDMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to OrderServiceMock.CancelByID at\n%s", m.CancelByIDMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to OrderServiceMock.CancelByID at\n%s with params: %#v", m.CancelByIDMock.defaultExpectation.expectationOrigins.origin, *m.CancelByIDMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCancelByID != nil && afterCancelByIDCounter < 1 {
		m.t.Errorf("Expected call to OrderServiceMock.CancelByID at\n%s", m.funcCancelByIDOrigin)
	}

	if !m.CancelByIDMock.invocationsDone() && afterCancelByIDCounter > 0 {
		m.t.Errorf("Expected %d calls to OrderServiceMock.CancelByID at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.CancelByIDMock.expectedInvocations), m.CancelByIDMock.expectedInvocationsOrigin, afterCancelByIDCounter)
	}
}

type mOrderServiceMockCreate struct {
	optional           bool
	mock               *OrderServiceMock
	defaultExpectation *OrderServiceMockCreateExpectation
	expectations       []*OrderServiceMockCreateExpectation

	callArgs []*OrderServiceMockCreateParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// OrderServiceMockCreateExpectation specifies expectation struct of the OrderService.Create
type OrderServiceMockCreateExpectation struct {
	mock               *OrderServiceMock
	params             *OrderServiceMockCreateParams
	paramPtrs          *OrderServiceMockCreateParamPtrs
	expectationOrigins OrderServiceMockCreateExpectationOrigins
	results            *OrderServiceMockCreateResults
	returnOrigin       string
	Counter            uint64
}

// OrderServiceMockCreateParams contains parameters of the OrderService.Create
type OrderServiceMockCreateParams struct {
	ctx   context.Context
	order *domain.Order
}

// OrderServiceMockCreateParamPtrs contains pointers to parameters of the OrderService.Create
type OrderServiceMockCreateParamPtrs struct {
	ctx   *context.Context
	order **domain.Order
}

// OrderServiceMockCreateResults contains results of the OrderService.Create
type OrderServiceMockCreateResults struct {
	i1  int64
	err error
}

// OrderServiceMockCreateOrigins contains origins of expectations of the OrderService.Create
type OrderServiceMockCreateExpectationOrigins struct {
	origin      string
	originCtx   string
	originOrder string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmCreate *mOrderServiceMockCreate) Optional() *mOrderServiceMockCreate {
	mmCreate.optional = true
	return mmCreate
}

// Expect sets up expected params for OrderService.Create
func (mmCreate *mOrderServiceMockCreate) Expect(ctx context.Context, order *domain.Order) *mOrderServiceMockCreate {
	if mmCreate.mock.funcCreate != nil {
		mmCreate.mock.t.Fatalf("OrderServiceMock.Create mock is already set by Set")
	}

	if mmCreate.defaultExpectation == nil {
		mmCreate.defaultExpectation = &OrderServiceMockCreateExpectation{}
	}

	if mmCreate.defaultExpectation.paramPtrs != nil {
		mmCreate.mock.t.Fatalf("OrderServiceMock.Create mock is already set by ExpectParams functions")
	}

	mmCreate.defaultExpectation.params = &OrderServiceMockCreateParams{ctx, order}
	mmCreate.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmCreate.expectations {
		if minimock.Equal(e.params, mmCreate.defaultExpectation.params) {
			mmCreate.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCreate.defaultExpectation.params)
		}
	}

	return mmCreate
}

// ExpectCtxParam1 sets up expected param ctx for OrderService.Create
func (mmCreate *mOrderServiceMockCreate) ExpectCtxParam1(ctx context.Context) *mOrderServiceMockCreate {
	if mmCreate.mock.funcCreate != nil {
		mmCreate.mock.t.Fatalf("OrderServiceMock.Create mock is already set by Set")
	}

	if mmCreate.defaultExpectation == nil {
		mmCreate.defaultExpectation = &OrderServiceMockCreateExpectation{}
	}

	if mmCreate.defaultExpectation.params != nil {
		mmCreate.mock.t.Fatalf("OrderServiceMock.Create mock is already set by Expect")
	}

	if mmCreate.defaultExpectation.paramPtrs == nil {
		mmCreate.defaultExpectation.paramPtrs = &OrderServiceMockCreateParamPtrs{}
	}
	mmCreate.defaultExpectation.paramPtrs.ctx = &ctx
	mmCreate.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmCreate
}

// ExpectOrderParam2 sets up expected param order for OrderService.Create
func (mmCreate *mOrderServiceMockCreate) ExpectOrderParam2(order *domain.Order) *mOrderServiceMockCreate {
	if mmCreate.mock.funcCreate != nil {
		mmCreate.mock.t.Fatalf("OrderServiceMock.Create mock is already set by Set")
	}

	if mmCreate.defaultExpectation == nil {
		mmCreate.defaultExpectation = &OrderServiceMockCreateExpectation{}
	}

	if mmCreate.defaultExpectation.params != nil {
		mmCreate.mock.t.Fatalf("OrderServiceMock.Create mock is already set by Expect")
	}

	if mmCreate.defaultExpectation.paramPtrs == nil {
		mmCreate.defaultExpectation.paramPtrs = &OrderServiceMockCreateParamPtrs{}
	}
	mmCreate.defaultExpectation.paramPtrs.order = &order
	mmCreate.defaultExpectation.expectationOrigins.originOrder = minimock.CallerInfo(1)

	return mmCreate
}

// Inspect accepts an inspector function that has same arguments as the OrderService.Create
func (mmCreate *mOrderServiceMockCreate) Inspect(f func(ctx context.Context, order *domain.Order)) *mOrderServiceMockCreate {
	if mmCreate.mock.inspectFuncCreate != nil {
		mmCreate.mock.t.Fatalf("Inspect function is already set for OrderServiceMock.Create")
	}

	mmCreate.mock.inspectFuncCreate = f

	return mmCreate
}

// Return sets up results that will be returned by OrderService.Create
func (mmCreate *mOrderServiceMockCreate) Return(i1 int64, err error) *OrderServiceMock {
	if mmCreate.mock.funcCreate != nil {
		mmCreate.mock.t.Fatalf("OrderServiceMock.Create mock is already set by Set")
	}

	if mmCreate.defaultExpectation == nil {
		mmCreate.defaultExpectation = &OrderServiceMockCreateExpectation{mock: mmCreate.mock}
	}
	mmCreate.defaultExpectation.results = &OrderServiceMockCreateResults{i1, err}
	mmCreate.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmCreate.mock
}

// Set uses given function f to mock the OrderService.Create method
func (mmCreate *mOrderServiceMockCreate) Set(f func(ctx context.Context, order *domain.Order) (i1 int64, err error)) *OrderServiceMock {
	if mmCreate.defaultExpectation != nil {
		mmCreate.mock.t.Fatalf("Default expectation is already set for the OrderService.Create method")
	}

	if len(mmCreate.expectations) > 0 {
		mmCreate.mock.t.Fatalf("Some expectations are already set for the OrderService.Create method")
	}

	mmCreate.mock.funcCreate = f
	mmCreate.mock.funcCreateOrigin = minimock.CallerInfo(1)
	return mmCreate.mock
}

// When sets expectation for the OrderService.Create which will trigger the result defined by the following
// Then helper
func (mmCreate *mOrderServiceMockCreate) When(ctx context.Context, order *domain.Order) *OrderServiceMockCreateExpectation {
	if mmCreate.mock.funcCreate != nil {
		mmCreate.mock.t.Fatalf("OrderServiceMock.Create mock is already set by Set")
	}

	expectation := &OrderServiceMockCreateExpectation{
		mock:               mmCreate.mock,
		params:             &OrderServiceMockCreateParams{ctx, order},
		expectationOrigins: OrderServiceMockCreateExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmCreate.expectations = append(mmCreate.expectations, expectation)
	return expectation
}

// Then sets up OrderService.Create return parameters for the expectation previously defined by the When method
func (e *OrderServiceMockCreateExpectation) Then(i1 int64, err error) *OrderServiceMock {
	e.results = &OrderServiceMockCreateResults{i1, err}
	return e.mock
}

// Times sets number of times OrderService.Create should be invoked
func (mmCreate *mOrderServiceMockCreate) Times(n uint64) *mOrderServiceMockCreate {
	if n == 0 {
		mmCreate.mock.t.Fatalf("Times of OrderServiceMock.Create mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmCreate.expectedInvocations, n)
	mmCreate.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmCreate
}

func (mmCreate *mOrderServiceMockCreate) invocationsDone() bool {
	if len(mmCreate.expectations) == 0 && mmCreate.defaultExpectation == nil && mmCreate.mock.funcCreate == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmCreate.mock.afterCreateCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmCreate.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Create implements mm_handler.OrderService
func (mmCreate *OrderServiceMock) Create(ctx context.Context, order *domain.Order) (i1 int64, err error) {
	mm_atomic.AddUint64(&mmCreate.beforeCreateCounter, 1)
	defer mm_atomic.AddUint64(&mmCreate.afterCreateCounter, 1)

	mmCreate.t.Helper()

	if mmCreate.inspectFuncCreate != nil {
		mmCreate.inspectFuncCreate(ctx, order)
	}

	mm_params := OrderServiceMockCreateParams{ctx, order}

	// Record call args
	mmCreate.CreateMock.mutex.Lock()
	mmCreate.CreateMock.callArgs = append(mmCreate.CreateMock.callArgs, &mm_params)
	mmCreate.CreateMock.mutex.Unlock()

	for _, e := range mmCreate.CreateMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.i1, e.results.err
		}
	}

	if mmCreate.CreateMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCreate.CreateMock.defaultExpectation.Counter, 1)
		mm_want := mmCreate.CreateMock.defaultExpectation.params
		mm_want_ptrs := mmCreate.CreateMock.defaultExpectation.paramPtrs

		mm_got := OrderServiceMockCreateParams{ctx, order}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmCreate.t.Errorf("OrderServiceMock.Create got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreate.CreateMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.order != nil && !minimock.Equal(*mm_want_ptrs.order, mm_got.order) {
				mmCreate.t.Errorf("OrderServiceMock.Create got unexpected parameter order, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreate.CreateMock.defaultExpectation.expectationOrigins.originOrder, *mm_want_ptrs.order, mm_got.order, minimock.Diff(*mm_want_ptrs.order, mm_got.order))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCreate.t.Errorf("OrderServiceMock.Create got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmCreate.CreateMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCreate.CreateMock.defaultExpectation.results
		if mm_results == nil {
			mmCreate.t.Fatal("No results are set for the OrderServiceMock.Create")
		}
		return (*mm_results).i1, (*mm_results).err
	}
	if mmCreate.funcCreate != nil {
		return mmCreate.funcCreate(ctx, order)
	}
	mmCreate.t.Fatalf("Unexpected call to OrderServiceMock.Create. %v %v", ctx, order)
	return
}

// CreateAfterCounter returns a count of finished OrderServiceMock.Create invocations
func (mmCreate *OrderServiceMock) CreateAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreate.afterCreateCounter)
}

// CreateBeforeCounter returns a count of OrderServiceMock.Create invocations
func (mmCreate *OrderServiceMock) CreateBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreate.beforeCreateCounter)
}

// Calls returns a list of arguments used in each call to OrderServiceMock.Create.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCreate *mOrderServiceMockCreate) Calls() []*OrderServiceMockCreateParams {
	mmCreate.mutex.RLock()

	argCopy := make([]*OrderServiceMockCreateParams, len(mmCreate.callArgs))
	copy(argCopy, mmCreate.callArgs)

	mmCreate.mutex.RUnlock()

	return argCopy
}

// MinimockCreateDone returns true if the count of the Create invocations corresponds
// the number of defined expectations
func (m *OrderServiceMock) MinimockCreateDone() bool {
	if m.CreateMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.CreateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.CreateMock.invocationsDone()
}

// MinimockCreateInspect logs each unmet expectation
func (m *OrderServiceMock) MinimockCreateInspect() {
	for _, e := range m.CreateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to OrderServiceMock.Create at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterCreateCounter := mm_atomic.LoadUint64(&m.afterCreateCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.CreateMock.defaultExpectation != nil && afterCreateCounter < 1 {
		if m.CreateMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to OrderServiceMock.Create at\n%s", m.CreateMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to OrderServiceMock.Create at\n%s with params: %#v", m.CreateMock.defaultExpectation.expectationOrigins.origin, *m.CreateMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreate != nil && afterCreateCounter < 1 {
		m.t.Errorf("Expected call to OrderServiceMock.Create at\n%s", m.funcCreateOrigin)
	}

	if !m.CreateMock.invocationsDone() && afterCreateCounter > 0 {
		m.t.Errorf("Expected %d calls to OrderServiceMock.Create at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.CreateMock.expectedInvocations), m.CreateMock.expectedInvocationsOrigin, afterCreateCounter)
	}
}

type mOrderServiceMockGetInfoByID struct {
	optional           bool
	mock               *OrderServiceMock
	defaultExpectation *OrderServiceMockGetInfoByIDExpectation
	expectations       []*OrderServiceMockGetInfoByIDExpectation

	callArgs []*OrderServiceMockGetInfoByIDParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// OrderServiceMockGetInfoByIDExpectation specifies expectation struct of the OrderService.GetInfoByID
type OrderServiceMockGetInfoByIDExpectation struct {
	mock               *OrderServiceMock
	params             *OrderServiceMockGetInfoByIDParams
	paramPtrs          *OrderServiceMockGetInfoByIDParamPtrs
	expectationOrigins OrderServiceMockGetInfoByIDExpectationOrigins
	results            *OrderServiceMockGetInfoByIDResults
	returnOrigin       string
	Counter            uint64
}

// OrderServiceMockGetInfoByIDParams contains parameters of the OrderService.GetInfoByID
type OrderServiceMockGetInfoByIDParams struct {
	ctx     context.Context
	orderID int64
}

// OrderServiceMockGetInfoByIDParamPtrs contains pointers to parameters of the OrderService.GetInfoByID
type OrderServiceMockGetInfoByIDParamPtrs struct {
	ctx     *context.Context
	orderID *int64
}

// OrderServiceMockGetInfoByIDResults contains results of the OrderService.GetInfoByID
type OrderServiceMockGetInfoByIDResults struct {
	op1 *domain.Order
	err error
}

// OrderServiceMockGetInfoByIDOrigins contains origins of expectations of the OrderService.GetInfoByID
type OrderServiceMockGetInfoByIDExpectationOrigins struct {
	origin        string
	originCtx     string
	originOrderID string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetInfoByID *mOrderServiceMockGetInfoByID) Optional() *mOrderServiceMockGetInfoByID {
	mmGetInfoByID.optional = true
	return mmGetInfoByID
}

// Expect sets up expected params for OrderService.GetInfoByID
func (mmGetInfoByID *mOrderServiceMockGetInfoByID) Expect(ctx context.Context, orderID int64) *mOrderServiceMockGetInfoByID {
	if mmGetInfoByID.mock.funcGetInfoByID != nil {
		mmGetInfoByID.mock.t.Fatalf("OrderServiceMock.GetInfoByID mock is already set by Set")
	}

	if mmGetInfoByID.defaultExpectation == nil {
		mmGetInfoByID.defaultExpectation = &OrderServiceMockGetInfoByIDExpectation{}
	}

	if mmGetInfoByID.defaultExpectation.paramPtrs != nil {
		mmGetInfoByID.mock.t.Fatalf("OrderServiceMock.GetInfoByID mock is already set by ExpectParams functions")
	}

	mmGetInfoByID.defaultExpectation.params = &OrderServiceMockGetInfoByIDParams{ctx, orderID}
	mmGetInfoByID.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetInfoByID.expectations {
		if minimock.Equal(e.params, mmGetInfoByID.defaultExpectation.params) {
			mmGetInfoByID.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetInfoByID.defaultExpectation.params)
		}
	}

	return mmGetInfoByID
}

// ExpectCtxParam1 sets up expected param ctx for OrderService.GetInfoByID
func (mmGetInfoByID *mOrderServiceMockGetInfoByID) ExpectCtxParam1(ctx context.Context) *mOrderServiceMockGetInfoByID {
	if mmGetInfoByID.mock.funcGetInfoByID != nil {
		mmGetInfoByID.mock.t.Fatalf("OrderServiceMock.GetInfoByID mock is already set by Set")
	}

	if mmGetInfoByID.defaultExpectation == nil {
		mmGetInfoByID.defaultExpectation = &OrderServiceMockGetInfoByIDExpectation{}
	}

	if mmGetInfoByID.defaultExpectation.params != nil {
		mmGetInfoByID.mock.t.Fatalf("OrderServiceMock.GetInfoByID mock is already set by Expect")
	}

	if mmGetInfoByID.defaultExpectation.paramPtrs == nil {
		mmGetInfoByID.defaultExpectation.paramPtrs = &OrderServiceMockGetInfoByIDParamPtrs{}
	}
	mmGetInfoByID.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetInfoByID.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetInfoByID
}

// ExpectOrderIDParam2 sets up expected param orderID for OrderService.GetInfoByID
func (mmGetInfoByID *mOrderServiceMockGetInfoByID) ExpectOrderIDParam2(orderID int64) *mOrderServiceMockGetInfoByID {
	if mmGetInfoByID.mock.funcGetInfoByID != nil {
		mmGetInfoByID.mock.t.Fatalf("OrderServiceMock.GetInfoByID mock is already set by Set")
	}

	if mmGetInfoByID.defaultExpectation == nil {
		mmGetInfoByID.defaultExpectation = &OrderServiceMockGetInfoByIDExpectation{}
	}

	if mmGetInfoByID.defaultExpectation.params != nil {
		mmGetInfoByID.mock.t.Fatalf("OrderServiceMock.GetInfoByID mock is already set by Expect")
	}

	if mmGetInfoByID.defaultExpectation.paramPtrs == nil {
		mmGetInfoByID.defaultExpectation.paramPtrs = &OrderServiceMockGetInfoByIDParamPtrs{}
	}
	mmGetInfoByID.defaultExpectation.paramPtrs.orderID = &orderID
	mmGetInfoByID.defaultExpectation.expectationOrigins.originOrderID = minimock.CallerInfo(1)

	return mmGetInfoByID
}

// Inspect accepts an inspector function that has same arguments as the OrderService.GetInfoByID
func (mmGetInfoByID *mOrderServiceMockGetInfoByID) Inspect(f func(ctx context.Context, orderID int64)) *mOrderServiceMockGetInfoByID {
	if mmGetInfoByID.mock.inspectFuncGetInfoByID != nil {
		mmGetInfoByID.mock.t.Fatalf("Inspect function is already set for OrderServiceMock.GetInfoByID")
	}

	mmGetInfoByID.mock.inspectFuncGetInfoByID = f

	return mmGetInfoByID
}

// Return sets up results that will be returned by OrderService.GetInfoByID
func (mmGetInfoByID *mOrderServiceMockGetInfoByID) Return(op1 *domain.Order, err error) *OrderServiceMock {
	if mmGetInfoByID.mock.funcGetInfoByID != nil {
		mmGetInfoByID.mock.t.Fatalf("OrderServiceMock.GetInfoByID mock is already set by Set")
	}

	if mmGetInfoByID.defaultExpectation == nil {
		mmGetInfoByID.defaultExpectation = &OrderServiceMockGetInfoByIDExpectation{mock: mmGetInfoByID.mock}
	}
	mmGetInfoByID.defaultExpectation.results = &OrderServiceMockGetInfoByIDResults{op1, err}
	mmGetInfoByID.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetInfoByID.mock
}

// Set uses given function f to mock the OrderService.GetInfoByID method
func (mmGetInfoByID *mOrderServiceMockGetInfoByID) Set(f func(ctx context.Context, orderID int64) (op1 *domain.Order, err error)) *OrderServiceMock {
	if mmGetInfoByID.defaultExpectation != nil {
		mmGetInfoByID.mock.t.Fatalf("Default expectation is already set for the OrderService.GetInfoByID method")
	}

	if len(mmGetInfoByID.expectations) > 0 {
		mmGetInfoByID.mock.t.Fatalf("Some expectations are already set for the OrderService.GetInfoByID method")
	}

	mmGetInfoByID.mock.funcGetInfoByID = f
	mmGetInfoByID.mock.funcGetInfoByIDOrigin = minimock.CallerInfo(1)
	return mmGetInfoByID.mock
}

// When sets expectation for the OrderService.GetInfoByID which will trigger the result defined by the following
// Then helper
func (mmGetInfoByID *mOrderServiceMockGetInfoByID) When(ctx context.Context, orderID int64) *OrderServiceMockGetInfoByIDExpectation {
	if mmGetInfoByID.mock.funcGetInfoByID != nil {
		mmGetInfoByID.mock.t.Fatalf("OrderServiceMock.GetInfoByID mock is already set by Set")
	}

	expectation := &OrderServiceMockGetInfoByIDExpectation{
		mock:               mmGetInfoByID.mock,
		params:             &OrderServiceMockGetInfoByIDParams{ctx, orderID},
		expectationOrigins: OrderServiceMockGetInfoByIDExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetInfoByID.expectations = append(mmGetInfoByID.expectations, expectation)
	return expectation
}

// Then sets up OrderService.GetInfoByID return parameters for the expectation previously defined by the When method
func (e *OrderServiceMockGetInfoByIDExpectation) Then(op1 *domain.Order, err error) *OrderServiceMock {
	e.results = &OrderServiceMockGetInfoByIDResults{op1, err}
	return e.mock
}

// Times sets number of times OrderService.GetInfoByID should be invoked
func (mmGetInfoByID *mOrderServiceMockGetInfoByID) Times(n uint64) *mOrderServiceMockGetInfoByID {
	if n == 0 {
		mmGetInfoByID.mock.t.Fatalf("Times of OrderServiceMock.GetInfoByID mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetInfoByID.expectedInvocations, n)
	mmGetInfoByID.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetInfoByID
}

func (mmGetInfoByID *mOrderServiceMockGetInfoByID) invocationsDone() bool {
	if len(mmGetInfoByID.expectations) == 0 && mmGetInfoByID.defaultExpectation == nil && mmGetInfoByID.mock.funcGetInfoByID == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetInfoByID.mock.afterGetInfoByIDCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetInfoByID.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetInfoByID implements mm_handler.OrderService
func (mmGetInfoByID *OrderServiceMock) GetInfoByID(ctx context.Context, orderID int64) (op1 *domain.Order, err error) {
	mm_atomic.AddUint64(&mmGetInfoByID.beforeGetInfoByIDCounter, 1)
	defer mm_atomic.AddUint64(&mmGetInfoByID.afterGetInfoByIDCounter, 1)

	mmGetInfoByID.t.Helper()

	if mmGetInfoByID.inspectFuncGetInfoByID != nil {
		mmGetInfoByID.inspectFuncGetInfoByID(ctx, orderID)
	}

	mm_params := OrderServiceMockGetInfoByIDParams{ctx, orderID}

	// Record call args
	mmGetInfoByID.GetInfoByIDMock.mutex.Lock()
	mmGetInfoByID.GetInfoByIDMock.callArgs = append(mmGetInfoByID.GetInfoByIDMock.callArgs, &mm_params)
	mmGetInfoByID.GetInfoByIDMock.mutex.Unlock()

	for _, e := range mmGetInfoByID.GetInfoByIDMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.op1, e.results.err
		}
	}

	if mmGetInfoByID.GetInfoByIDMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetInfoByID.GetInfoByIDMock.defaultExpectation.Counter, 1)
		mm_want := mmGetInfoByID.GetInfoByIDMock.defaultExpectation.params
		mm_want_ptrs := mmGetInfoByID.GetInfoByIDMock.defaultExpectation.paramPtrs

		mm_got := OrderServiceMockGetInfoByIDParams{ctx, orderID}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetInfoByID.t.Errorf("OrderServiceMock.GetInfoByID got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetInfoByID.GetInfoByIDMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.orderID != nil && !minimock.Equal(*mm_want_ptrs.orderID, mm_got.orderID) {
				mmGetInfoByID.t.Errorf("OrderServiceMock.GetInfoByID got unexpected parameter orderID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetInfoByID.GetInfoByIDMock.defaultExpectation.expectationOrigins.originOrderID, *mm_want_ptrs.orderID, mm_got.orderID, minimock.Diff(*mm_want_ptrs.orderID, mm_got.orderID))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetInfoByID.t.Errorf("OrderServiceMock.GetInfoByID got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetInfoByID.GetInfoByIDMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetInfoByID.GetInfoByIDMock.defaultExpectation.results
		if mm_results == nil {
			mmGetInfoByID.t.Fatal("No results are set for the OrderServiceMock.GetInfoByID")
		}
		return (*mm_results).op1, (*mm_results).err
	}
	if mmGetInfoByID.funcGetInfoByID != nil {
		return mmGetInfoByID.funcGetInfoByID(ctx, orderID)
	}
	mmGetInfoByID.t.Fatalf("Unexpected call to OrderServiceMock.GetInfoByID. %v %v", ctx, orderID)
	return
}

// GetInfoByIDAfterCounter returns a count of finished OrderServiceMock.GetInfoByID invocations
func (mmGetInfoByID *OrderServiceMock) GetInfoByIDAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetInfoByID.afterGetInfoByIDCounter)
}

// GetInfoByIDBeforeCounter returns a count of OrderServiceMock.GetInfoByID invocations
func (mmGetInfoByID *OrderServiceMock) GetInfoByIDBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetInfoByID.beforeGetInfoByIDCounter)
}

// Calls returns a list of arguments used in each call to OrderServiceMock.GetInfoByID.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetInfoByID *mOrderServiceMockGetInfoByID) Calls() []*OrderServiceMockGetInfoByIDParams {
	mmGetInfoByID.mutex.RLock()

	argCopy := make([]*OrderServiceMockGetInfoByIDParams, len(mmGetInfoByID.callArgs))
	copy(argCopy, mmGetInfoByID.callArgs)

	mmGetInfoByID.mutex.RUnlock()

	return argCopy
}

// MinimockGetInfoByIDDone returns true if the count of the GetInfoByID invocations corresponds
// the number of defined expectations
func (m *OrderServiceMock) MinimockGetInfoByIDDone() bool {
	if m.GetInfoByIDMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetInfoByIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetInfoByIDMock.invocationsDone()
}

// MinimockGetInfoByIDInspect logs each unmet expectation
func (m *OrderServiceMock) MinimockGetInfoByIDInspect() {
	for _, e := range m.GetInfoByIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to OrderServiceMock.GetInfoByID at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetInfoByIDCounter := mm_atomic.LoadUint64(&m.afterGetInfoByIDCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetInfoByIDMock.defaultExpectation != nil && afterGetInfoByIDCounter < 1 {
		if m.GetInfoByIDMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to OrderServiceMock.GetInfoByID at\n%s", m.GetInfoByIDMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to OrderServiceMock.GetInfoByID at\n%s with params: %#v", m.GetInfoByIDMock.defaultExpectation.expectationOrigins.origin, *m.GetInfoByIDMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetInfoByID != nil && afterGetInfoByIDCounter < 1 {
		m.t.Errorf("Expected call to OrderServiceMock.GetInfoByID at\n%s", m.funcGetInfoByIDOrigin)
	}

	if !m.GetInfoByIDMock.invocationsDone() && afterGetInfoByIDCounter > 0 {
		m.t.Errorf("Expected %d calls to OrderServiceMock.GetInfoByID at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetInfoByIDMock.expectedInvocations), m.GetInfoByIDMock.expectedInvocationsOrigin, afterGetInfoByIDCounter)
	}
}

type mOrderServiceMockPayByID struct {
	optional           bool
	mock               *OrderServiceMock
	defaultExpectation *OrderServiceMockPayByIDExpectation
	expectations       []*OrderServiceMockPayByIDExpectation

	callArgs []*OrderServiceMockPayByIDParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// OrderServiceMockPayByIDExpectation specifies expectation struct of the OrderService.PayByID
type OrderServiceMockPayByIDExpectation struct {
	mock               *OrderServiceMock
	params             *OrderServiceMockPayByIDParams
	paramPtrs          *OrderServiceMockPayByIDParamPtrs
	expectationOrigins OrderServiceMockPayByIDExpectationOrigins
	results            *OrderServiceMockPayByIDResults
	returnOrigin       string
	Counter            uint64
}

// OrderServiceMockPayByIDParams contains parameters of the OrderService.PayByID
type OrderServiceMockPayByIDParams struct {
	ctx     context.Context
	orderID int64
}

// OrderServiceMockPayByIDParamPtrs contains pointers to parameters of the OrderService.PayByID
type OrderServiceMockPayByIDParamPtrs struct {
	ctx     *context.Context
	orderID *int64
}

// OrderServiceMockPayByIDResults contains results of the OrderService.PayByID
type OrderServiceMockPayByIDResults struct {
	err error
}

// OrderServiceMockPayByIDOrigins contains origins of expectations of the OrderService.PayByID
type OrderServiceMockPayByIDExpectationOrigins struct {
	origin        string
	originCtx     string
	originOrderID string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmPayByID *mOrderServiceMockPayByID) Optional() *mOrderServiceMockPayByID {
	mmPayByID.optional = true
	return mmPayByID
}

// Expect sets up expected params for OrderService.PayByID
func (mmPayByID *mOrderServiceMockPayByID) Expect(ctx context.Context, orderID int64) *mOrderServiceMockPayByID {
	if mmPayByID.mock.funcPayByID != nil {
		mmPayByID.mock.t.Fatalf("OrderServiceMock.PayByID mock is already set by Set")
	}

	if mmPayByID.defaultExpectation == nil {
		mmPayByID.defaultExpectation = &OrderServiceMockPayByIDExpectation{}
	}

	if mmPayByID.defaultExpectation.paramPtrs != nil {
		mmPayByID.mock.t.Fatalf("OrderServiceMock.PayByID mock is already set by ExpectParams functions")
	}

	mmPayByID.defaultExpectation.params = &OrderServiceMockPayByIDParams{ctx, orderID}
	mmPayByID.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmPayByID.expectations {
		if minimock.Equal(e.params, mmPayByID.defaultExpectation.params) {
			mmPayByID.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmPayByID.defaultExpectation.params)
		}
	}

	return mmPayByID
}

// ExpectCtxParam1 sets up expected param ctx for OrderService.PayByID
func (mmPayByID *mOrderServiceMockPayByID) ExpectCtxParam1(ctx context.Context) *mOrderServiceMockPayByID {
	if mmPayByID.mock.funcPayByID != nil {
		mmPayByID.mock.t.Fatalf("OrderServiceMock.PayByID mock is already set by Set")
	}

	if mmPayByID.defaultExpectation == nil {
		mmPayByID.defaultExpectation = &OrderServiceMockPayByIDExpectation{}
	}

	if mmPayByID.defaultExpectation.params != nil {
		mmPayByID.mock.t.Fatalf("OrderServiceMock.PayByID mock is already set by Expect")
	}

	if mmPayByID.defaultExpectation.paramPtrs == nil {
		mmPayByID.defaultExpectation.paramPtrs = &OrderServiceMockPayByIDParamPtrs{}
	}
	mmPayByID.defaultExpectation.paramPtrs.ctx = &ctx
	mmPayByID.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmPayByID
}

// ExpectOrderIDParam2 sets up expected param orderID for OrderService.PayByID
func (mmPayByID *mOrderServiceMockPayByID) ExpectOrderIDParam2(orderID int64) *mOrderServiceMockPayByID {
	if mmPayByID.mock.funcPayByID != nil {
		mmPayByID.mock.t.Fatalf("OrderServiceMock.PayByID mock is already set by Set")
	}

	if mmPayByID.defaultExpectation == nil {
		mmPayByID.defaultExpectation = &OrderServiceMockPayByIDExpectation{}
	}

	if mmPayByID.defaultExpectation.params != nil {
		mmPayByID.mock.t.Fatalf("OrderServiceMock.PayByID mock is already set by Expect")
	}

	if mmPayByID.defaultExpectation.paramPtrs == nil {
		mmPayByID.defaultExpectation.paramPtrs = &OrderServiceMockPayByIDParamPtrs{}
	}
	mmPayByID.defaultExpectation.paramPtrs.orderID = &orderID
	mmPayByID.defaultExpectation.expectationOrigins.originOrderID = minimock.CallerInfo(1)

	return mmPayByID
}

// Inspect accepts an inspector function that has same arguments as the OrderService.PayByID
func (mmPayByID *mOrderServiceMockPayByID) Inspect(f func(ctx context.Context, orderID int64)) *mOrderServiceMockPayByID {
	if mmPayByID.mock.inspectFuncPayByID != nil {
		mmPayByID.mock.t.Fatalf("Inspect function is already set for OrderServiceMock.PayByID")
	}

	mmPayByID.mock.inspectFuncPayByID = f

	return mmPayByID
}

// Return sets up results that will be returned by OrderService.PayByID
func (mmPayByID *mOrderServiceMockPayByID) Return(err error) *OrderServiceMock {
	if mmPayByID.mock.funcPayByID != nil {
		mmPayByID.mock.t.Fatalf("OrderServiceMock.PayByID mock is already set by Set")
	}

	if mmPayByID.defaultExpectation == nil {
		mmPayByID.defaultExpectation = &OrderServiceMockPayByIDExpectation{mock: mmPayByID.mock}
	}
	mmPayByID.defaultExpectation.results = &OrderServiceMockPayByIDResults{err}
	mmPayByID.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmPayByID.mock
}

// Set uses given function f to mock the OrderService.PayByID method
func (mmPayByID *mOrderServiceMockPayByID) Set(f func(ctx context.Context, orderID int64) (err error)) *OrderServiceMock {
	if mmPayByID.defaultExpectation != nil {
		mmPayByID.mock.t.Fatalf("Default expectation is already set for the OrderService.PayByID method")
	}

	if len(mmPayByID.expectations) > 0 {
		mmPayByID.mock.t.Fatalf("Some expectations are already set for the OrderService.PayByID method")
	}

	mmPayByID.mock.funcPayByID = f
	mmPayByID.mock.funcPayByIDOrigin = minimock.CallerInfo(1)
	return mmPayByID.mock
}

// When sets expectation for the OrderService.PayByID which will trigger the result defined by the following
// Then helper
func (mmPayByID *mOrderServiceMockPayByID) When(ctx context.Context, orderID int64) *OrderServiceMockPayByIDExpectation {
	if mmPayByID.mock.funcPayByID != nil {
		mmPayByID.mock.t.Fatalf("OrderServiceMock.PayByID mock is already set by Set")
	}

	expectation := &OrderServiceMockPayByIDExpectation{
		mock:               mmPayByID.mock,
		params:             &OrderServiceMockPayByIDParams{ctx, orderID},
		expectationOrigins: OrderServiceMockPayByIDExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmPayByID.expectations = append(mmPayByID.expectations, expectation)
	return expectation
}

// Then sets up OrderService.PayByID return parameters for the expectation previously defined by the When method
func (e *OrderServiceMockPayByIDExpectation) Then(err error) *OrderServiceMock {
	e.results = &OrderServiceMockPayByIDResults{err}
	return e.mock
}

// Times sets number of times OrderService.PayByID should be invoked
func (mmPayByID *mOrderServiceMockPayByID) Times(n uint64) *mOrderServiceMockPayByID {
	if n == 0 {
		mmPayByID.mock.t.Fatalf("Times of OrderServiceMock.PayByID mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmPayByID.expectedInvocations, n)
	mmPayByID.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmPayByID
}

func (mmPayByID *mOrderServiceMockPayByID) invocationsDone() bool {
	if len(mmPayByID.expectations) == 0 && mmPayByID.defaultExpectation == nil && mmPayByID.mock.funcPayByID == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmPayByID.mock.afterPayByIDCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmPayByID.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// PayByID implements mm_handler.OrderService
func (mmPayByID *OrderServiceMock) PayByID(ctx context.Context, orderID int64) (err error) {
	mm_atomic.AddUint64(&mmPayByID.beforePayByIDCounter, 1)
	defer mm_atomic.AddUint64(&mmPayByID.afterPayByIDCounter, 1)

	mmPayByID.t.Helper()

	if mmPayByID.inspectFuncPayByID != nil {
		mmPayByID.inspectFuncPayByID(ctx, orderID)
	}

	mm_params := OrderServiceMockPayByIDParams{ctx, orderID}

	// Record call args
	mmPayByID.PayByIDMock.mutex.Lock()
	mmPayByID.PayByIDMock.callArgs = append(mmPayByID.PayByIDMock.callArgs, &mm_params)
	mmPayByID.PayByIDMock.mutex.Unlock()

	for _, e := range mmPayByID.PayByIDMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmPayByID.PayByIDMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmPayByID.PayByIDMock.defaultExpectation.Counter, 1)
		mm_want := mmPayByID.PayByIDMock.defaultExpectation.params
		mm_want_ptrs := mmPayByID.PayByIDMock.defaultExpectation.paramPtrs

		mm_got := OrderServiceMockPayByIDParams{ctx, orderID}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmPayByID.t.Errorf("OrderServiceMock.PayByID got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmPayByID.PayByIDMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.orderID != nil && !minimock.Equal(*mm_want_ptrs.orderID, mm_got.orderID) {
				mmPayByID.t.Errorf("OrderServiceMock.PayByID got unexpected parameter orderID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmPayByID.PayByIDMock.defaultExpectation.expectationOrigins.originOrderID, *mm_want_ptrs.orderID, mm_got.orderID, minimock.Diff(*mm_want_ptrs.orderID, mm_got.orderID))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmPayByID.t.Errorf("OrderServiceMock.PayByID got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmPayByID.PayByIDMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmPayByID.PayByIDMock.defaultExpectation.results
		if mm_results == nil {
			mmPayByID.t.Fatal("No results are set for the OrderServiceMock.PayByID")
		}
		return (*mm_results).err
	}
	if mmPayByID.funcPayByID != nil {
		return mmPayByID.funcPayByID(ctx, orderID)
	}
	mmPayByID.t.Fatalf("Unexpected call to OrderServiceMock.PayByID. %v %v", ctx, orderID)
	return
}

// PayByIDAfterCounter returns a count of finished OrderServiceMock.PayByID invocations
func (mmPayByID *OrderServiceMock) PayByIDAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmPayByID.afterPayByIDCounter)
}

// PayByIDBeforeCounter returns a count of OrderServiceMock.PayByID invocations
func (mmPayByID *OrderServiceMock) PayByIDBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmPayByID.beforePayByIDCounter)
}

// Calls returns a list of arguments used in each call to OrderServiceMock.PayByID.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmPayByID *mOrderServiceMockPayByID) Calls() []*OrderServiceMockPayByIDParams {
	mmPayByID.mutex.RLock()

	argCopy := make([]*OrderServiceMockPayByIDParams, len(mmPayByID.callArgs))
	copy(argCopy, mmPayByID.callArgs)

	mmPayByID.mutex.RUnlock()

	return argCopy
}

// MinimockPayByIDDone returns true if the count of the PayByID invocations corresponds
// the number of defined expectations
func (m *OrderServiceMock) MinimockPayByIDDone() bool {
	if m.PayByIDMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.PayByIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.PayByIDMock.invocationsDone()
}

// MinimockPayByIDInspect logs each unmet expectation
func (m *OrderServiceMock) MinimockPayByIDInspect() {
	for _, e := range m.PayByIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to OrderServiceMock.PayByID at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterPayByIDCounter := mm_atomic.LoadUint64(&m.afterPayByIDCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.PayByIDMock.defaultExpectation != nil && afterPayByIDCounter < 1 {
		if m.PayByIDMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to OrderServiceMock.PayByID at\n%s", m.PayByIDMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to OrderServiceMock.PayByID at\n%s with params: %#v", m.PayByIDMock.defaultExpectation.expectationOrigins.origin, *m.PayByIDMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcPayByID != nil && afterPayByIDCounter < 1 {
		m.t.Errorf("Expected call to OrderServiceMock.PayByID at\n%s", m.funcPayByIDOrigin)
	}

	if !m.PayByIDMock.invocationsDone() && afterPayByIDCounter > 0 {
		m.t.Errorf("Expected %d calls to OrderServiceMock.PayByID at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.PayByIDMock.expectedInvocations), m.PayByIDMock.expectedInvocationsOrigin, afterPayByIDCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *OrderServiceMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockCancelByIDInspect()

			m.MinimockCreateInspect()

			m.MinimockGetInfoByIDInspect()

			m.MinimockPayByIDInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *OrderServiceMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *OrderServiceMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockCancelByIDDone() &&
		m.MinimockCreateDone() &&
		m.MinimockGetInfoByIDDone() &&
		m.MinimockPayByIDDone()
}
