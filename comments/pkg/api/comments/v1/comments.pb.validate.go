// Code generated by protoc-gen-validate. DO NOT EDIT.
// source: comments/v1/comments.proto

package comments

import (
	"bytes"
	"errors"
	"fmt"
	"net"
	"net/mail"
	"net/url"
	"regexp"
	"sort"
	"strings"
	"time"
	"unicode/utf8"

	"google.golang.org/protobuf/types/known/anypb"
)

// ensure the imports are used
var (
	_ = bytes.MinRead
	_ = errors.New("")
	_ = fmt.Print
	_ = utf8.UTFMax
	_ = (*regexp.Regexp)(nil)
	_ = (*strings.Reader)(nil)
	_ = net.IPv4len
	_ = time.Duration(0)
	_ = (*url.URL)(nil)
	_ = (*mail.Address)(nil)
	_ = anypb.Any{}
	_ = sort.Sort
)

// Validate checks the field values on AddCommentRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *AddCommentRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on AddCommentRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// AddCommentRequestMultiError, or nil if none found.
func (m *AddCommentRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *AddCommentRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetUserId() <= 0 {
		err := AddCommentRequestValidationError{
			field:  "UserId",
			reason: "value must be greater than 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.GetSku() <= 0 {
		err := AddCommentRequestValidationError{
			field:  "Sku",
			reason: "value must be greater than 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetContent()); l < 1 || l > 255 {
		err := AddCommentRequestValidationError{
			field:  "Content",
			reason: "value length must be between 1 and 255 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return AddCommentRequestMultiError(errors)
	}

	return nil
}

// AddCommentRequestMultiError is an error wrapping multiple validation errors
// returned by AddCommentRequest.ValidateAll() if the designated constraints
// aren't met.
type AddCommentRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m AddCommentRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m AddCommentRequestMultiError) AllErrors() []error { return m }

// AddCommentRequestValidationError is the validation error returned by
// AddCommentRequest.Validate if the designated constraints aren't met.
type AddCommentRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e AddCommentRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e AddCommentRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e AddCommentRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e AddCommentRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e AddCommentRequestValidationError) ErrorName() string {
	return "AddCommentRequestValidationError"
}

// Error satisfies the builtin error interface
func (e AddCommentRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sAddCommentRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = AddCommentRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = AddCommentRequestValidationError{}

// Validate checks the field values on AddCommentResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *AddCommentResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on AddCommentResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// AddCommentResponseMultiError, or nil if none found.
func (m *AddCommentResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *AddCommentResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	if len(errors) > 0 {
		return AddCommentResponseMultiError(errors)
	}

	return nil
}

// AddCommentResponseMultiError is an error wrapping multiple validation errors
// returned by AddCommentResponse.ValidateAll() if the designated constraints
// aren't met.
type AddCommentResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m AddCommentResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m AddCommentResponseMultiError) AllErrors() []error { return m }

// AddCommentResponseValidationError is the validation error returned by
// AddCommentResponse.Validate if the designated constraints aren't met.
type AddCommentResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e AddCommentResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e AddCommentResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e AddCommentResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e AddCommentResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e AddCommentResponseValidationError) ErrorName() string {
	return "AddCommentResponseValidationError"
}

// Error satisfies the builtin error interface
func (e AddCommentResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sAddCommentResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = AddCommentResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = AddCommentResponseValidationError{}

// Validate checks the field values on CommentInfoRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CommentInfoRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CommentInfoRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CommentInfoRequestMultiError, or nil if none found.
func (m *CommentInfoRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *CommentInfoRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetId() <= 0 {
		err := CommentInfoRequestValidationError{
			field:  "Id",
			reason: "value must be greater than 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return CommentInfoRequestMultiError(errors)
	}

	return nil
}

// CommentInfoRequestMultiError is an error wrapping multiple validation errors
// returned by CommentInfoRequest.ValidateAll() if the designated constraints
// aren't met.
type CommentInfoRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CommentInfoRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CommentInfoRequestMultiError) AllErrors() []error { return m }

// CommentInfoRequestValidationError is the validation error returned by
// CommentInfoRequest.Validate if the designated constraints aren't met.
type CommentInfoRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CommentInfoRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CommentInfoRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CommentInfoRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CommentInfoRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CommentInfoRequestValidationError) ErrorName() string {
	return "CommentInfoRequestValidationError"
}

// Error satisfies the builtin error interface
func (e CommentInfoRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCommentInfoRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CommentInfoRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CommentInfoRequestValidationError{}

// Validate checks the field values on CommentInfoResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CommentInfoResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CommentInfoResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CommentInfoResponseMultiError, or nil if none found.
func (m *CommentInfoResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *CommentInfoResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for UserId

	// no validation rules for Sku

	// no validation rules for Content

	if all {
		switch v := interface{}(m.GetCreatedAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CommentInfoResponseValidationError{
					field:  "CreatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CommentInfoResponseValidationError{
					field:  "CreatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCreatedAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CommentInfoResponseValidationError{
				field:  "CreatedAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return CommentInfoResponseMultiError(errors)
	}

	return nil
}

// CommentInfoResponseMultiError is an error wrapping multiple validation
// errors returned by CommentInfoResponse.ValidateAll() if the designated
// constraints aren't met.
type CommentInfoResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CommentInfoResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CommentInfoResponseMultiError) AllErrors() []error { return m }

// CommentInfoResponseValidationError is the validation error returned by
// CommentInfoResponse.Validate if the designated constraints aren't met.
type CommentInfoResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CommentInfoResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CommentInfoResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CommentInfoResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CommentInfoResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CommentInfoResponseValidationError) ErrorName() string {
	return "CommentInfoResponseValidationError"
}

// Error satisfies the builtin error interface
func (e CommentInfoResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCommentInfoResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CommentInfoResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CommentInfoResponseValidationError{}

// Validate checks the field values on EditCommentRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *EditCommentRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on EditCommentRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// EditCommentRequestMultiError, or nil if none found.
func (m *EditCommentRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *EditCommentRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetCommentId() <= 0 {
		err := EditCommentRequestValidationError{
			field:  "CommentId",
			reason: "value must be greater than 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.GetUserId() <= 0 {
		err := EditCommentRequestValidationError{
			field:  "UserId",
			reason: "value must be greater than 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetContent()); l < 1 || l > 255 {
		err := EditCommentRequestValidationError{
			field:  "Content",
			reason: "value length must be between 1 and 255 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return EditCommentRequestMultiError(errors)
	}

	return nil
}

// EditCommentRequestMultiError is an error wrapping multiple validation errors
// returned by EditCommentRequest.ValidateAll() if the designated constraints
// aren't met.
type EditCommentRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m EditCommentRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m EditCommentRequestMultiError) AllErrors() []error { return m }

// EditCommentRequestValidationError is the validation error returned by
// EditCommentRequest.Validate if the designated constraints aren't met.
type EditCommentRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e EditCommentRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e EditCommentRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e EditCommentRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e EditCommentRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e EditCommentRequestValidationError) ErrorName() string {
	return "EditCommentRequestValidationError"
}

// Error satisfies the builtin error interface
func (e EditCommentRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sEditCommentRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = EditCommentRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = EditCommentRequestValidationError{}

// Validate checks the field values on EditCommentResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *EditCommentResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on EditCommentResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// EditCommentResponseMultiError, or nil if none found.
func (m *EditCommentResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *EditCommentResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return EditCommentResponseMultiError(errors)
	}

	return nil
}

// EditCommentResponseMultiError is an error wrapping multiple validation
// errors returned by EditCommentResponse.ValidateAll() if the designated
// constraints aren't met.
type EditCommentResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m EditCommentResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m EditCommentResponseMultiError) AllErrors() []error { return m }

// EditCommentResponseValidationError is the validation error returned by
// EditCommentResponse.Validate if the designated constraints aren't met.
type EditCommentResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e EditCommentResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e EditCommentResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e EditCommentResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e EditCommentResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e EditCommentResponseValidationError) ErrorName() string {
	return "EditCommentResponseValidationError"
}

// Error satisfies the builtin error interface
func (e EditCommentResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sEditCommentResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = EditCommentResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = EditCommentResponseValidationError{}

// Validate checks the field values on GetCommentsBySKURequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetCommentsBySKURequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetCommentsBySKURequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetCommentsBySKURequestMultiError, or nil if none found.
func (m *GetCommentsBySKURequest) ValidateAll() error {
	return m.validate(true)
}

func (m *GetCommentsBySKURequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetSku() <= 0 {
		err := GetCommentsBySKURequestValidationError{
			field:  "Sku",
			reason: "value must be greater than 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return GetCommentsBySKURequestMultiError(errors)
	}

	return nil
}

// GetCommentsBySKURequestMultiError is an error wrapping multiple validation
// errors returned by GetCommentsBySKURequest.ValidateAll() if the designated
// constraints aren't met.
type GetCommentsBySKURequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetCommentsBySKURequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetCommentsBySKURequestMultiError) AllErrors() []error { return m }

// GetCommentsBySKURequestValidationError is the validation error returned by
// GetCommentsBySKURequest.Validate if the designated constraints aren't met.
type GetCommentsBySKURequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetCommentsBySKURequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetCommentsBySKURequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetCommentsBySKURequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetCommentsBySKURequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetCommentsBySKURequestValidationError) ErrorName() string {
	return "GetCommentsBySKURequestValidationError"
}

// Error satisfies the builtin error interface
func (e GetCommentsBySKURequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetCommentsBySKURequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetCommentsBySKURequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetCommentsBySKURequestValidationError{}

// Validate checks the field values on GetCommentsBySKUResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetCommentsBySKUResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetCommentsBySKUResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetCommentsBySKUResponseMultiError, or nil if none found.
func (m *GetCommentsBySKUResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *GetCommentsBySKUResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetComments() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, GetCommentsBySKUResponseValidationError{
						field:  fmt.Sprintf("Comments[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, GetCommentsBySKUResponseValidationError{
						field:  fmt.Sprintf("Comments[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return GetCommentsBySKUResponseValidationError{
					field:  fmt.Sprintf("Comments[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return GetCommentsBySKUResponseMultiError(errors)
	}

	return nil
}

// GetCommentsBySKUResponseMultiError is an error wrapping multiple validation
// errors returned by GetCommentsBySKUResponse.ValidateAll() if the designated
// constraints aren't met.
type GetCommentsBySKUResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetCommentsBySKUResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetCommentsBySKUResponseMultiError) AllErrors() []error { return m }

// GetCommentsBySKUResponseValidationError is the validation error returned by
// GetCommentsBySKUResponse.Validate if the designated constraints aren't met.
type GetCommentsBySKUResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetCommentsBySKUResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetCommentsBySKUResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetCommentsBySKUResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetCommentsBySKUResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetCommentsBySKUResponseValidationError) ErrorName() string {
	return "GetCommentsBySKUResponseValidationError"
}

// Error satisfies the builtin error interface
func (e GetCommentsBySKUResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetCommentsBySKUResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetCommentsBySKUResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetCommentsBySKUResponseValidationError{}

// Validate checks the field values on CommentBySKU with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *CommentBySKU) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CommentBySKU with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in CommentBySKUMultiError, or
// nil if none found.
func (m *CommentBySKU) ValidateAll() error {
	return m.validate(true)
}

func (m *CommentBySKU) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for UserId

	// no validation rules for Content

	if all {
		switch v := interface{}(m.GetCreatedAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CommentBySKUValidationError{
					field:  "CreatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CommentBySKUValidationError{
					field:  "CreatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCreatedAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CommentBySKUValidationError{
				field:  "CreatedAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return CommentBySKUMultiError(errors)
	}

	return nil
}

// CommentBySKUMultiError is an error wrapping multiple validation errors
// returned by CommentBySKU.ValidateAll() if the designated constraints aren't met.
type CommentBySKUMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CommentBySKUMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CommentBySKUMultiError) AllErrors() []error { return m }

// CommentBySKUValidationError is the validation error returned by
// CommentBySKU.Validate if the designated constraints aren't met.
type CommentBySKUValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CommentBySKUValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CommentBySKUValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CommentBySKUValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CommentBySKUValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CommentBySKUValidationError) ErrorName() string { return "CommentBySKUValidationError" }

// Error satisfies the builtin error interface
func (e CommentBySKUValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCommentBySKU.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CommentBySKUValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CommentBySKUValidationError{}

// Validate checks the field values on GetCommentsByUserRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetCommentsByUserRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetCommentsByUserRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetCommentsByUserRequestMultiError, or nil if none found.
func (m *GetCommentsByUserRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *GetCommentsByUserRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetUserId() <= 0 {
		err := GetCommentsByUserRequestValidationError{
			field:  "UserId",
			reason: "value must be greater than 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return GetCommentsByUserRequestMultiError(errors)
	}

	return nil
}

// GetCommentsByUserRequestMultiError is an error wrapping multiple validation
// errors returned by GetCommentsByUserRequest.ValidateAll() if the designated
// constraints aren't met.
type GetCommentsByUserRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetCommentsByUserRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetCommentsByUserRequestMultiError) AllErrors() []error { return m }

// GetCommentsByUserRequestValidationError is the validation error returned by
// GetCommentsByUserRequest.Validate if the designated constraints aren't met.
type GetCommentsByUserRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetCommentsByUserRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetCommentsByUserRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetCommentsByUserRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetCommentsByUserRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetCommentsByUserRequestValidationError) ErrorName() string {
	return "GetCommentsByUserRequestValidationError"
}

// Error satisfies the builtin error interface
func (e GetCommentsByUserRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetCommentsByUserRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetCommentsByUserRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetCommentsByUserRequestValidationError{}

// Validate checks the field values on GetCommentsByUserResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetCommentsByUserResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetCommentsByUserResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetCommentsByUserResponseMultiError, or nil if none found.
func (m *GetCommentsByUserResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *GetCommentsByUserResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetComments() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, GetCommentsByUserResponseValidationError{
						field:  fmt.Sprintf("Comments[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, GetCommentsByUserResponseValidationError{
						field:  fmt.Sprintf("Comments[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return GetCommentsByUserResponseValidationError{
					field:  fmt.Sprintf("Comments[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return GetCommentsByUserResponseMultiError(errors)
	}

	return nil
}

// GetCommentsByUserResponseMultiError is an error wrapping multiple validation
// errors returned by GetCommentsByUserResponse.ValidateAll() if the
// designated constraints aren't met.
type GetCommentsByUserResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetCommentsByUserResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetCommentsByUserResponseMultiError) AllErrors() []error { return m }

// GetCommentsByUserResponseValidationError is the validation error returned by
// GetCommentsByUserResponse.Validate if the designated constraints aren't met.
type GetCommentsByUserResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetCommentsByUserResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetCommentsByUserResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetCommentsByUserResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetCommentsByUserResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetCommentsByUserResponseValidationError) ErrorName() string {
	return "GetCommentsByUserResponseValidationError"
}

// Error satisfies the builtin error interface
func (e GetCommentsByUserResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetCommentsByUserResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetCommentsByUserResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetCommentsByUserResponseValidationError{}

// Validate checks the field values on CommentByUser with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *CommentByUser) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CommentByUser with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in CommentByUserMultiError, or
// nil if none found.
func (m *CommentByUser) ValidateAll() error {
	return m.validate(true)
}

func (m *CommentByUser) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for Sku

	// no validation rules for Content

	if all {
		switch v := interface{}(m.GetCreatedAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CommentByUserValidationError{
					field:  "CreatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CommentByUserValidationError{
					field:  "CreatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCreatedAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CommentByUserValidationError{
				field:  "CreatedAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return CommentByUserMultiError(errors)
	}

	return nil
}

// CommentByUserMultiError is an error wrapping multiple validation errors
// returned by CommentByUser.ValidateAll() if the designated constraints
// aren't met.
type CommentByUserMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CommentByUserMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CommentByUserMultiError) AllErrors() []error { return m }

// CommentByUserValidationError is the validation error returned by
// CommentByUser.Validate if the designated constraints aren't met.
type CommentByUserValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CommentByUserValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CommentByUserValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CommentByUserValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CommentByUserValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CommentByUserValidationError) ErrorName() string { return "CommentByUserValidationError" }

// Error satisfies the builtin error interface
func (e CommentByUserValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCommentByUser.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CommentByUserValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CommentByUserValidationError{}
