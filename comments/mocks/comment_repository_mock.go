// Code generated by http://github.com/gojuno/minimock (v3.4.5). DO NOT EDIT.

package mocks

//go:generate minimock -i route256/comments/internal/service.commentRepository -o comment_repository_mock.go -n CommentRepositoryMock -p mocks

import (
	"context"
	"route256/comments/internal/domain"
	"sync"
	mm_atomic "sync/atomic"
	"time"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
)

// CommentRepositoryMock implements mm_service.commentRepository
type CommentRepositoryMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcGetByID          func(ctx context.Context, commentID int64) (cp1 *domain.Comment, err error)
	funcGetByIDOrigin    string
	inspectFuncGetByID   func(ctx context.Context, commentID int64)
	afterGetByIDCounter  uint64
	beforeGetByIDCounter uint64
	GetByIDMock          mCommentRepositoryMockGetByID

	funcGetListBySKU          func(ctx context.Context, sku int64, lastCreatedAt time.Time, lastUserID int64, limit int32) (cpa1 []*domain.Comment, err error)
	funcGetListBySKUOrigin    string
	inspectFuncGetListBySKU   func(ctx context.Context, sku int64, lastCreatedAt time.Time, lastUserID int64, limit int32)
	afterGetListBySKUCounter  uint64
	beforeGetListBySKUCounter uint64
	GetListBySKUMock          mCommentRepositoryMockGetListBySKU

	funcGetListByUser          func(ctx context.Context, userID int64) (cpa1 []*domain.Comment, err error)
	funcGetListByUserOrigin    string
	inspectFuncGetListByUser   func(ctx context.Context, userID int64)
	afterGetListByUserCounter  uint64
	beforeGetListByUserCounter uint64
	GetListByUserMock          mCommentRepositoryMockGetListByUser

	funcInsert          func(ctx context.Context, comment *domain.Comment) (i1 int64, err error)
	funcInsertOrigin    string
	inspectFuncInsert   func(ctx context.Context, comment *domain.Comment)
	afterInsertCounter  uint64
	beforeInsertCounter uint64
	InsertMock          mCommentRepositoryMockInsert

	funcUpdateContentWithCheck          func(ctx context.Context, commentID int64, newComment *domain.Comment, predicate func(oldComment *domain.Comment) error) (err error)
	funcUpdateContentWithCheckOrigin    string
	inspectFuncUpdateContentWithCheck   func(ctx context.Context, commentID int64, newComment *domain.Comment, predicate func(oldComment *domain.Comment) error)
	afterUpdateContentWithCheckCounter  uint64
	beforeUpdateContentWithCheckCounter uint64
	UpdateContentWithCheckMock          mCommentRepositoryMockUpdateContentWithCheck
}

// NewCommentRepositoryMock returns a mock for mm_service.commentRepository
func NewCommentRepositoryMock(t minimock.Tester) *CommentRepositoryMock {
	m := &CommentRepositoryMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.GetByIDMock = mCommentRepositoryMockGetByID{mock: m}
	m.GetByIDMock.callArgs = []*CommentRepositoryMockGetByIDParams{}

	m.GetListBySKUMock = mCommentRepositoryMockGetListBySKU{mock: m}
	m.GetListBySKUMock.callArgs = []*CommentRepositoryMockGetListBySKUParams{}

	m.GetListByUserMock = mCommentRepositoryMockGetListByUser{mock: m}
	m.GetListByUserMock.callArgs = []*CommentRepositoryMockGetListByUserParams{}

	m.InsertMock = mCommentRepositoryMockInsert{mock: m}
	m.InsertMock.callArgs = []*CommentRepositoryMockInsertParams{}

	m.UpdateContentWithCheckMock = mCommentRepositoryMockUpdateContentWithCheck{mock: m}
	m.UpdateContentWithCheckMock.callArgs = []*CommentRepositoryMockUpdateContentWithCheckParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mCommentRepositoryMockGetByID struct {
	optional           bool
	mock               *CommentRepositoryMock
	defaultExpectation *CommentRepositoryMockGetByIDExpectation
	expectations       []*CommentRepositoryMockGetByIDExpectation

	callArgs []*CommentRepositoryMockGetByIDParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// CommentRepositoryMockGetByIDExpectation specifies expectation struct of the commentRepository.GetByID
type CommentRepositoryMockGetByIDExpectation struct {
	mock               *CommentRepositoryMock
	params             *CommentRepositoryMockGetByIDParams
	paramPtrs          *CommentRepositoryMockGetByIDParamPtrs
	expectationOrigins CommentRepositoryMockGetByIDExpectationOrigins
	results            *CommentRepositoryMockGetByIDResults
	returnOrigin       string
	Counter            uint64
}

// CommentRepositoryMockGetByIDParams contains parameters of the commentRepository.GetByID
type CommentRepositoryMockGetByIDParams struct {
	ctx       context.Context
	commentID int64
}

// CommentRepositoryMockGetByIDParamPtrs contains pointers to parameters of the commentRepository.GetByID
type CommentRepositoryMockGetByIDParamPtrs struct {
	ctx       *context.Context
	commentID *int64
}

// CommentRepositoryMockGetByIDResults contains results of the commentRepository.GetByID
type CommentRepositoryMockGetByIDResults struct {
	cp1 *domain.Comment
	err error
}

// CommentRepositoryMockGetByIDOrigins contains origins of expectations of the commentRepository.GetByID
type CommentRepositoryMockGetByIDExpectationOrigins struct {
	origin          string
	originCtx       string
	originCommentID string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetByID *mCommentRepositoryMockGetByID) Optional() *mCommentRepositoryMockGetByID {
	mmGetByID.optional = true
	return mmGetByID
}

// Expect sets up expected params for commentRepository.GetByID
func (mmGetByID *mCommentRepositoryMockGetByID) Expect(ctx context.Context, commentID int64) *mCommentRepositoryMockGetByID {
	if mmGetByID.mock.funcGetByID != nil {
		mmGetByID.mock.t.Fatalf("CommentRepositoryMock.GetByID mock is already set by Set")
	}

	if mmGetByID.defaultExpectation == nil {
		mmGetByID.defaultExpectation = &CommentRepositoryMockGetByIDExpectation{}
	}

	if mmGetByID.defaultExpectation.paramPtrs != nil {
		mmGetByID.mock.t.Fatalf("CommentRepositoryMock.GetByID mock is already set by ExpectParams functions")
	}

	mmGetByID.defaultExpectation.params = &CommentRepositoryMockGetByIDParams{ctx, commentID}
	mmGetByID.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetByID.expectations {
		if minimock.Equal(e.params, mmGetByID.defaultExpectation.params) {
			mmGetByID.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetByID.defaultExpectation.params)
		}
	}

	return mmGetByID
}

// ExpectCtxParam1 sets up expected param ctx for commentRepository.GetByID
func (mmGetByID *mCommentRepositoryMockGetByID) ExpectCtxParam1(ctx context.Context) *mCommentRepositoryMockGetByID {
	if mmGetByID.mock.funcGetByID != nil {
		mmGetByID.mock.t.Fatalf("CommentRepositoryMock.GetByID mock is already set by Set")
	}

	if mmGetByID.defaultExpectation == nil {
		mmGetByID.defaultExpectation = &CommentRepositoryMockGetByIDExpectation{}
	}

	if mmGetByID.defaultExpectation.params != nil {
		mmGetByID.mock.t.Fatalf("CommentRepositoryMock.GetByID mock is already set by Expect")
	}

	if mmGetByID.defaultExpectation.paramPtrs == nil {
		mmGetByID.defaultExpectation.paramPtrs = &CommentRepositoryMockGetByIDParamPtrs{}
	}
	mmGetByID.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetByID.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetByID
}

// ExpectCommentIDParam2 sets up expected param commentID for commentRepository.GetByID
func (mmGetByID *mCommentRepositoryMockGetByID) ExpectCommentIDParam2(commentID int64) *mCommentRepositoryMockGetByID {
	if mmGetByID.mock.funcGetByID != nil {
		mmGetByID.mock.t.Fatalf("CommentRepositoryMock.GetByID mock is already set by Set")
	}

	if mmGetByID.defaultExpectation == nil {
		mmGetByID.defaultExpectation = &CommentRepositoryMockGetByIDExpectation{}
	}

	if mmGetByID.defaultExpectation.params != nil {
		mmGetByID.mock.t.Fatalf("CommentRepositoryMock.GetByID mock is already set by Expect")
	}

	if mmGetByID.defaultExpectation.paramPtrs == nil {
		mmGetByID.defaultExpectation.paramPtrs = &CommentRepositoryMockGetByIDParamPtrs{}
	}
	mmGetByID.defaultExpectation.paramPtrs.commentID = &commentID
	mmGetByID.defaultExpectation.expectationOrigins.originCommentID = minimock.CallerInfo(1)

	return mmGetByID
}

// Inspect accepts an inspector function that has same arguments as the commentRepository.GetByID
func (mmGetByID *mCommentRepositoryMockGetByID) Inspect(f func(ctx context.Context, commentID int64)) *mCommentRepositoryMockGetByID {
	if mmGetByID.mock.inspectFuncGetByID != nil {
		mmGetByID.mock.t.Fatalf("Inspect function is already set for CommentRepositoryMock.GetByID")
	}

	mmGetByID.mock.inspectFuncGetByID = f

	return mmGetByID
}

// Return sets up results that will be returned by commentRepository.GetByID
func (mmGetByID *mCommentRepositoryMockGetByID) Return(cp1 *domain.Comment, err error) *CommentRepositoryMock {
	if mmGetByID.mock.funcGetByID != nil {
		mmGetByID.mock.t.Fatalf("CommentRepositoryMock.GetByID mock is already set by Set")
	}

	if mmGetByID.defaultExpectation == nil {
		mmGetByID.defaultExpectation = &CommentRepositoryMockGetByIDExpectation{mock: mmGetByID.mock}
	}
	mmGetByID.defaultExpectation.results = &CommentRepositoryMockGetByIDResults{cp1, err}
	mmGetByID.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetByID.mock
}

// Set uses given function f to mock the commentRepository.GetByID method
func (mmGetByID *mCommentRepositoryMockGetByID) Set(f func(ctx context.Context, commentID int64) (cp1 *domain.Comment, err error)) *CommentRepositoryMock {
	if mmGetByID.defaultExpectation != nil {
		mmGetByID.mock.t.Fatalf("Default expectation is already set for the commentRepository.GetByID method")
	}

	if len(mmGetByID.expectations) > 0 {
		mmGetByID.mock.t.Fatalf("Some expectations are already set for the commentRepository.GetByID method")
	}

	mmGetByID.mock.funcGetByID = f
	mmGetByID.mock.funcGetByIDOrigin = minimock.CallerInfo(1)
	return mmGetByID.mock
}

// When sets expectation for the commentRepository.GetByID which will trigger the result defined by the following
// Then helper
func (mmGetByID *mCommentRepositoryMockGetByID) When(ctx context.Context, commentID int64) *CommentRepositoryMockGetByIDExpectation {
	if mmGetByID.mock.funcGetByID != nil {
		mmGetByID.mock.t.Fatalf("CommentRepositoryMock.GetByID mock is already set by Set")
	}

	expectation := &CommentRepositoryMockGetByIDExpectation{
		mock:               mmGetByID.mock,
		params:             &CommentRepositoryMockGetByIDParams{ctx, commentID},
		expectationOrigins: CommentRepositoryMockGetByIDExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetByID.expectations = append(mmGetByID.expectations, expectation)
	return expectation
}

// Then sets up commentRepository.GetByID return parameters for the expectation previously defined by the When method
func (e *CommentRepositoryMockGetByIDExpectation) Then(cp1 *domain.Comment, err error) *CommentRepositoryMock {
	e.results = &CommentRepositoryMockGetByIDResults{cp1, err}
	return e.mock
}

// Times sets number of times commentRepository.GetByID should be invoked
func (mmGetByID *mCommentRepositoryMockGetByID) Times(n uint64) *mCommentRepositoryMockGetByID {
	if n == 0 {
		mmGetByID.mock.t.Fatalf("Times of CommentRepositoryMock.GetByID mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetByID.expectedInvocations, n)
	mmGetByID.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetByID
}

func (mmGetByID *mCommentRepositoryMockGetByID) invocationsDone() bool {
	if len(mmGetByID.expectations) == 0 && mmGetByID.defaultExpectation == nil && mmGetByID.mock.funcGetByID == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetByID.mock.afterGetByIDCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetByID.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetByID implements mm_service.commentRepository
func (mmGetByID *CommentRepositoryMock) GetByID(ctx context.Context, commentID int64) (cp1 *domain.Comment, err error) {
	mm_atomic.AddUint64(&mmGetByID.beforeGetByIDCounter, 1)
	defer mm_atomic.AddUint64(&mmGetByID.afterGetByIDCounter, 1)

	mmGetByID.t.Helper()

	if mmGetByID.inspectFuncGetByID != nil {
		mmGetByID.inspectFuncGetByID(ctx, commentID)
	}

	mm_params := CommentRepositoryMockGetByIDParams{ctx, commentID}

	// Record call args
	mmGetByID.GetByIDMock.mutex.Lock()
	mmGetByID.GetByIDMock.callArgs = append(mmGetByID.GetByIDMock.callArgs, &mm_params)
	mmGetByID.GetByIDMock.mutex.Unlock()

	for _, e := range mmGetByID.GetByIDMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.cp1, e.results.err
		}
	}

	if mmGetByID.GetByIDMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetByID.GetByIDMock.defaultExpectation.Counter, 1)
		mm_want := mmGetByID.GetByIDMock.defaultExpectation.params
		mm_want_ptrs := mmGetByID.GetByIDMock.defaultExpectation.paramPtrs

		mm_got := CommentRepositoryMockGetByIDParams{ctx, commentID}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetByID.t.Errorf("CommentRepositoryMock.GetByID got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetByID.GetByIDMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.commentID != nil && !minimock.Equal(*mm_want_ptrs.commentID, mm_got.commentID) {
				mmGetByID.t.Errorf("CommentRepositoryMock.GetByID got unexpected parameter commentID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetByID.GetByIDMock.defaultExpectation.expectationOrigins.originCommentID, *mm_want_ptrs.commentID, mm_got.commentID, minimock.Diff(*mm_want_ptrs.commentID, mm_got.commentID))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetByID.t.Errorf("CommentRepositoryMock.GetByID got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetByID.GetByIDMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetByID.GetByIDMock.defaultExpectation.results
		if mm_results == nil {
			mmGetByID.t.Fatal("No results are set for the CommentRepositoryMock.GetByID")
		}
		return (*mm_results).cp1, (*mm_results).err
	}
	if mmGetByID.funcGetByID != nil {
		return mmGetByID.funcGetByID(ctx, commentID)
	}
	mmGetByID.t.Fatalf("Unexpected call to CommentRepositoryMock.GetByID. %v %v", ctx, commentID)
	return
}

// GetByIDAfterCounter returns a count of finished CommentRepositoryMock.GetByID invocations
func (mmGetByID *CommentRepositoryMock) GetByIDAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetByID.afterGetByIDCounter)
}

// GetByIDBeforeCounter returns a count of CommentRepositoryMock.GetByID invocations
func (mmGetByID *CommentRepositoryMock) GetByIDBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetByID.beforeGetByIDCounter)
}

// Calls returns a list of arguments used in each call to CommentRepositoryMock.GetByID.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetByID *mCommentRepositoryMockGetByID) Calls() []*CommentRepositoryMockGetByIDParams {
	mmGetByID.mutex.RLock()

	argCopy := make([]*CommentRepositoryMockGetByIDParams, len(mmGetByID.callArgs))
	copy(argCopy, mmGetByID.callArgs)

	mmGetByID.mutex.RUnlock()

	return argCopy
}

// MinimockGetByIDDone returns true if the count of the GetByID invocations corresponds
// the number of defined expectations
func (m *CommentRepositoryMock) MinimockGetByIDDone() bool {
	if m.GetByIDMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetByIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetByIDMock.invocationsDone()
}

// MinimockGetByIDInspect logs each unmet expectation
func (m *CommentRepositoryMock) MinimockGetByIDInspect() {
	for _, e := range m.GetByIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to CommentRepositoryMock.GetByID at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetByIDCounter := mm_atomic.LoadUint64(&m.afterGetByIDCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetByIDMock.defaultExpectation != nil && afterGetByIDCounter < 1 {
		if m.GetByIDMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to CommentRepositoryMock.GetByID at\n%s", m.GetByIDMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to CommentRepositoryMock.GetByID at\n%s with params: %#v", m.GetByIDMock.defaultExpectation.expectationOrigins.origin, *m.GetByIDMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetByID != nil && afterGetByIDCounter < 1 {
		m.t.Errorf("Expected call to CommentRepositoryMock.GetByID at\n%s", m.funcGetByIDOrigin)
	}

	if !m.GetByIDMock.invocationsDone() && afterGetByIDCounter > 0 {
		m.t.Errorf("Expected %d calls to CommentRepositoryMock.GetByID at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetByIDMock.expectedInvocations), m.GetByIDMock.expectedInvocationsOrigin, afterGetByIDCounter)
	}
}

type mCommentRepositoryMockGetListBySKU struct {
	optional           bool
	mock               *CommentRepositoryMock
	defaultExpectation *CommentRepositoryMockGetListBySKUExpectation
	expectations       []*CommentRepositoryMockGetListBySKUExpectation

	callArgs []*CommentRepositoryMockGetListBySKUParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// CommentRepositoryMockGetListBySKUExpectation specifies expectation struct of the commentRepository.GetListBySKU
type CommentRepositoryMockGetListBySKUExpectation struct {
	mock               *CommentRepositoryMock
	params             *CommentRepositoryMockGetListBySKUParams
	paramPtrs          *CommentRepositoryMockGetListBySKUParamPtrs
	expectationOrigins CommentRepositoryMockGetListBySKUExpectationOrigins
	results            *CommentRepositoryMockGetListBySKUResults
	returnOrigin       string
	Counter            uint64
}

// CommentRepositoryMockGetListBySKUParams contains parameters of the commentRepository.GetListBySKU
type CommentRepositoryMockGetListBySKUParams struct {
	ctx           context.Context
	sku           int64
	lastCreatedAt time.Time
	lastUserID    int64
	limit         int32
}

// CommentRepositoryMockGetListBySKUParamPtrs contains pointers to parameters of the commentRepository.GetListBySKU
type CommentRepositoryMockGetListBySKUParamPtrs struct {
	ctx           *context.Context
	sku           *int64
	lastCreatedAt *time.Time
	lastUserID    *int64
	limit         *int32
}

// CommentRepositoryMockGetListBySKUResults contains results of the commentRepository.GetListBySKU
type CommentRepositoryMockGetListBySKUResults struct {
	cpa1 []*domain.Comment
	err  error
}

// CommentRepositoryMockGetListBySKUOrigins contains origins of expectations of the commentRepository.GetListBySKU
type CommentRepositoryMockGetListBySKUExpectationOrigins struct {
	origin              string
	originCtx           string
	originSku           string
	originLastCreatedAt string
	originLastUserID    string
	originLimit         string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetListBySKU *mCommentRepositoryMockGetListBySKU) Optional() *mCommentRepositoryMockGetListBySKU {
	mmGetListBySKU.optional = true
	return mmGetListBySKU
}

// Expect sets up expected params for commentRepository.GetListBySKU
func (mmGetListBySKU *mCommentRepositoryMockGetListBySKU) Expect(ctx context.Context, sku int64, lastCreatedAt time.Time, lastUserID int64, limit int32) *mCommentRepositoryMockGetListBySKU {
	if mmGetListBySKU.mock.funcGetListBySKU != nil {
		mmGetListBySKU.mock.t.Fatalf("CommentRepositoryMock.GetListBySKU mock is already set by Set")
	}

	if mmGetListBySKU.defaultExpectation == nil {
		mmGetListBySKU.defaultExpectation = &CommentRepositoryMockGetListBySKUExpectation{}
	}

	if mmGetListBySKU.defaultExpectation.paramPtrs != nil {
		mmGetListBySKU.mock.t.Fatalf("CommentRepositoryMock.GetListBySKU mock is already set by ExpectParams functions")
	}

	mmGetListBySKU.defaultExpectation.params = &CommentRepositoryMockGetListBySKUParams{ctx, sku, lastCreatedAt, lastUserID, limit}
	mmGetListBySKU.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetListBySKU.expectations {
		if minimock.Equal(e.params, mmGetListBySKU.defaultExpectation.params) {
			mmGetListBySKU.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetListBySKU.defaultExpectation.params)
		}
	}

	return mmGetListBySKU
}

// ExpectCtxParam1 sets up expected param ctx for commentRepository.GetListBySKU
func (mmGetListBySKU *mCommentRepositoryMockGetListBySKU) ExpectCtxParam1(ctx context.Context) *mCommentRepositoryMockGetListBySKU {
	if mmGetListBySKU.mock.funcGetListBySKU != nil {
		mmGetListBySKU.mock.t.Fatalf("CommentRepositoryMock.GetListBySKU mock is already set by Set")
	}

	if mmGetListBySKU.defaultExpectation == nil {
		mmGetListBySKU.defaultExpectation = &CommentRepositoryMockGetListBySKUExpectation{}
	}

	if mmGetListBySKU.defaultExpectation.params != nil {
		mmGetListBySKU.mock.t.Fatalf("CommentRepositoryMock.GetListBySKU mock is already set by Expect")
	}

	if mmGetListBySKU.defaultExpectation.paramPtrs == nil {
		mmGetListBySKU.defaultExpectation.paramPtrs = &CommentRepositoryMockGetListBySKUParamPtrs{}
	}
	mmGetListBySKU.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetListBySKU.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetListBySKU
}

// ExpectSkuParam2 sets up expected param sku for commentRepository.GetListBySKU
func (mmGetListBySKU *mCommentRepositoryMockGetListBySKU) ExpectSkuParam2(sku int64) *mCommentRepositoryMockGetListBySKU {
	if mmGetListBySKU.mock.funcGetListBySKU != nil {
		mmGetListBySKU.mock.t.Fatalf("CommentRepositoryMock.GetListBySKU mock is already set by Set")
	}

	if mmGetListBySKU.defaultExpectation == nil {
		mmGetListBySKU.defaultExpectation = &CommentRepositoryMockGetListBySKUExpectation{}
	}

	if mmGetListBySKU.defaultExpectation.params != nil {
		mmGetListBySKU.mock.t.Fatalf("CommentRepositoryMock.GetListBySKU mock is already set by Expect")
	}

	if mmGetListBySKU.defaultExpectation.paramPtrs == nil {
		mmGetListBySKU.defaultExpectation.paramPtrs = &CommentRepositoryMockGetListBySKUParamPtrs{}
	}
	mmGetListBySKU.defaultExpectation.paramPtrs.sku = &sku
	mmGetListBySKU.defaultExpectation.expectationOrigins.originSku = minimock.CallerInfo(1)

	return mmGetListBySKU
}

// ExpectLastCreatedAtParam3 sets up expected param lastCreatedAt for commentRepository.GetListBySKU
func (mmGetListBySKU *mCommentRepositoryMockGetListBySKU) ExpectLastCreatedAtParam3(lastCreatedAt time.Time) *mCommentRepositoryMockGetListBySKU {
	if mmGetListBySKU.mock.funcGetListBySKU != nil {
		mmGetListBySKU.mock.t.Fatalf("CommentRepositoryMock.GetListBySKU mock is already set by Set")
	}

	if mmGetListBySKU.defaultExpectation == nil {
		mmGetListBySKU.defaultExpectation = &CommentRepositoryMockGetListBySKUExpectation{}
	}

	if mmGetListBySKU.defaultExpectation.params != nil {
		mmGetListBySKU.mock.t.Fatalf("CommentRepositoryMock.GetListBySKU mock is already set by Expect")
	}

	if mmGetListBySKU.defaultExpectation.paramPtrs == nil {
		mmGetListBySKU.defaultExpectation.paramPtrs = &CommentRepositoryMockGetListBySKUParamPtrs{}
	}
	mmGetListBySKU.defaultExpectation.paramPtrs.lastCreatedAt = &lastCreatedAt
	mmGetListBySKU.defaultExpectation.expectationOrigins.originLastCreatedAt = minimock.CallerInfo(1)

	return mmGetListBySKU
}

// ExpectLastUserIDParam4 sets up expected param lastUserID for commentRepository.GetListBySKU
func (mmGetListBySKU *mCommentRepositoryMockGetListBySKU) ExpectLastUserIDParam4(lastUserID int64) *mCommentRepositoryMockGetListBySKU {
	if mmGetListBySKU.mock.funcGetListBySKU != nil {
		mmGetListBySKU.mock.t.Fatalf("CommentRepositoryMock.GetListBySKU mock is already set by Set")
	}

	if mmGetListBySKU.defaultExpectation == nil {
		mmGetListBySKU.defaultExpectation = &CommentRepositoryMockGetListBySKUExpectation{}
	}

	if mmGetListBySKU.defaultExpectation.params != nil {
		mmGetListBySKU.mock.t.Fatalf("CommentRepositoryMock.GetListBySKU mock is already set by Expect")
	}

	if mmGetListBySKU.defaultExpectation.paramPtrs == nil {
		mmGetListBySKU.defaultExpectation.paramPtrs = &CommentRepositoryMockGetListBySKUParamPtrs{}
	}
	mmGetListBySKU.defaultExpectation.paramPtrs.lastUserID = &lastUserID
	mmGetListBySKU.defaultExpectation.expectationOrigins.originLastUserID = minimock.CallerInfo(1)

	return mmGetListBySKU
}

// ExpectLimitParam5 sets up expected param limit for commentRepository.GetListBySKU
func (mmGetListBySKU *mCommentRepositoryMockGetListBySKU) ExpectLimitParam5(limit int32) *mCommentRepositoryMockGetListBySKU {
	if mmGetListBySKU.mock.funcGetListBySKU != nil {
		mmGetListBySKU.mock.t.Fatalf("CommentRepositoryMock.GetListBySKU mock is already set by Set")
	}

	if mmGetListBySKU.defaultExpectation == nil {
		mmGetListBySKU.defaultExpectation = &CommentRepositoryMockGetListBySKUExpectation{}
	}

	if mmGetListBySKU.defaultExpectation.params != nil {
		mmGetListBySKU.mock.t.Fatalf("CommentRepositoryMock.GetListBySKU mock is already set by Expect")
	}

	if mmGetListBySKU.defaultExpectation.paramPtrs == nil {
		mmGetListBySKU.defaultExpectation.paramPtrs = &CommentRepositoryMockGetListBySKUParamPtrs{}
	}
	mmGetListBySKU.defaultExpectation.paramPtrs.limit = &limit
	mmGetListBySKU.defaultExpectation.expectationOrigins.originLimit = minimock.CallerInfo(1)

	return mmGetListBySKU
}

// Inspect accepts an inspector function that has same arguments as the commentRepository.GetListBySKU
func (mmGetListBySKU *mCommentRepositoryMockGetListBySKU) Inspect(f func(ctx context.Context, sku int64, lastCreatedAt time.Time, lastUserID int64, limit int32)) *mCommentRepositoryMockGetListBySKU {
	if mmGetListBySKU.mock.inspectFuncGetListBySKU != nil {
		mmGetListBySKU.mock.t.Fatalf("Inspect function is already set for CommentRepositoryMock.GetListBySKU")
	}

	mmGetListBySKU.mock.inspectFuncGetListBySKU = f

	return mmGetListBySKU
}

// Return sets up results that will be returned by commentRepository.GetListBySKU
func (mmGetListBySKU *mCommentRepositoryMockGetListBySKU) Return(cpa1 []*domain.Comment, err error) *CommentRepositoryMock {
	if mmGetListBySKU.mock.funcGetListBySKU != nil {
		mmGetListBySKU.mock.t.Fatalf("CommentRepositoryMock.GetListBySKU mock is already set by Set")
	}

	if mmGetListBySKU.defaultExpectation == nil {
		mmGetListBySKU.defaultExpectation = &CommentRepositoryMockGetListBySKUExpectation{mock: mmGetListBySKU.mock}
	}
	mmGetListBySKU.defaultExpectation.results = &CommentRepositoryMockGetListBySKUResults{cpa1, err}
	mmGetListBySKU.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetListBySKU.mock
}

// Set uses given function f to mock the commentRepository.GetListBySKU method
func (mmGetListBySKU *mCommentRepositoryMockGetListBySKU) Set(f func(ctx context.Context, sku int64, lastCreatedAt time.Time, lastUserID int64, limit int32) (cpa1 []*domain.Comment, err error)) *CommentRepositoryMock {
	if mmGetListBySKU.defaultExpectation != nil {
		mmGetListBySKU.mock.t.Fatalf("Default expectation is already set for the commentRepository.GetListBySKU method")
	}

	if len(mmGetListBySKU.expectations) > 0 {
		mmGetListBySKU.mock.t.Fatalf("Some expectations are already set for the commentRepository.GetListBySKU method")
	}

	mmGetListBySKU.mock.funcGetListBySKU = f
	mmGetListBySKU.mock.funcGetListBySKUOrigin = minimock.CallerInfo(1)
	return mmGetListBySKU.mock
}

// When sets expectation for the commentRepository.GetListBySKU which will trigger the result defined by the following
// Then helper
func (mmGetListBySKU *mCommentRepositoryMockGetListBySKU) When(ctx context.Context, sku int64, lastCreatedAt time.Time, lastUserID int64, limit int32) *CommentRepositoryMockGetListBySKUExpectation {
	if mmGetListBySKU.mock.funcGetListBySKU != nil {
		mmGetListBySKU.mock.t.Fatalf("CommentRepositoryMock.GetListBySKU mock is already set by Set")
	}

	expectation := &CommentRepositoryMockGetListBySKUExpectation{
		mock:               mmGetListBySKU.mock,
		params:             &CommentRepositoryMockGetListBySKUParams{ctx, sku, lastCreatedAt, lastUserID, limit},
		expectationOrigins: CommentRepositoryMockGetListBySKUExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetListBySKU.expectations = append(mmGetListBySKU.expectations, expectation)
	return expectation
}

// Then sets up commentRepository.GetListBySKU return parameters for the expectation previously defined by the When method
func (e *CommentRepositoryMockGetListBySKUExpectation) Then(cpa1 []*domain.Comment, err error) *CommentRepositoryMock {
	e.results = &CommentRepositoryMockGetListBySKUResults{cpa1, err}
	return e.mock
}

// Times sets number of times commentRepository.GetListBySKU should be invoked
func (mmGetListBySKU *mCommentRepositoryMockGetListBySKU) Times(n uint64) *mCommentRepositoryMockGetListBySKU {
	if n == 0 {
		mmGetListBySKU.mock.t.Fatalf("Times of CommentRepositoryMock.GetListBySKU mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetListBySKU.expectedInvocations, n)
	mmGetListBySKU.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetListBySKU
}

func (mmGetListBySKU *mCommentRepositoryMockGetListBySKU) invocationsDone() bool {
	if len(mmGetListBySKU.expectations) == 0 && mmGetListBySKU.defaultExpectation == nil && mmGetListBySKU.mock.funcGetListBySKU == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetListBySKU.mock.afterGetListBySKUCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetListBySKU.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetListBySKU implements mm_service.commentRepository
func (mmGetListBySKU *CommentRepositoryMock) GetListBySKU(ctx context.Context, sku int64, lastCreatedAt time.Time, lastUserID int64, limit int32) (cpa1 []*domain.Comment, err error) {
	mm_atomic.AddUint64(&mmGetListBySKU.beforeGetListBySKUCounter, 1)
	defer mm_atomic.AddUint64(&mmGetListBySKU.afterGetListBySKUCounter, 1)

	mmGetListBySKU.t.Helper()

	if mmGetListBySKU.inspectFuncGetListBySKU != nil {
		mmGetListBySKU.inspectFuncGetListBySKU(ctx, sku, lastCreatedAt, lastUserID, limit)
	}

	mm_params := CommentRepositoryMockGetListBySKUParams{ctx, sku, lastCreatedAt, lastUserID, limit}

	// Record call args
	mmGetListBySKU.GetListBySKUMock.mutex.Lock()
	mmGetListBySKU.GetListBySKUMock.callArgs = append(mmGetListBySKU.GetListBySKUMock.callArgs, &mm_params)
	mmGetListBySKU.GetListBySKUMock.mutex.Unlock()

	for _, e := range mmGetListBySKU.GetListBySKUMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.cpa1, e.results.err
		}
	}

	if mmGetListBySKU.GetListBySKUMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetListBySKU.GetListBySKUMock.defaultExpectation.Counter, 1)
		mm_want := mmGetListBySKU.GetListBySKUMock.defaultExpectation.params
		mm_want_ptrs := mmGetListBySKU.GetListBySKUMock.defaultExpectation.paramPtrs

		mm_got := CommentRepositoryMockGetListBySKUParams{ctx, sku, lastCreatedAt, lastUserID, limit}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetListBySKU.t.Errorf("CommentRepositoryMock.GetListBySKU got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetListBySKU.GetListBySKUMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.sku != nil && !minimock.Equal(*mm_want_ptrs.sku, mm_got.sku) {
				mmGetListBySKU.t.Errorf("CommentRepositoryMock.GetListBySKU got unexpected parameter sku, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetListBySKU.GetListBySKUMock.defaultExpectation.expectationOrigins.originSku, *mm_want_ptrs.sku, mm_got.sku, minimock.Diff(*mm_want_ptrs.sku, mm_got.sku))
			}

			if mm_want_ptrs.lastCreatedAt != nil && !minimock.Equal(*mm_want_ptrs.lastCreatedAt, mm_got.lastCreatedAt) {
				mmGetListBySKU.t.Errorf("CommentRepositoryMock.GetListBySKU got unexpected parameter lastCreatedAt, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetListBySKU.GetListBySKUMock.defaultExpectation.expectationOrigins.originLastCreatedAt, *mm_want_ptrs.lastCreatedAt, mm_got.lastCreatedAt, minimock.Diff(*mm_want_ptrs.lastCreatedAt, mm_got.lastCreatedAt))
			}

			if mm_want_ptrs.lastUserID != nil && !minimock.Equal(*mm_want_ptrs.lastUserID, mm_got.lastUserID) {
				mmGetListBySKU.t.Errorf("CommentRepositoryMock.GetListBySKU got unexpected parameter lastUserID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetListBySKU.GetListBySKUMock.defaultExpectation.expectationOrigins.originLastUserID, *mm_want_ptrs.lastUserID, mm_got.lastUserID, minimock.Diff(*mm_want_ptrs.lastUserID, mm_got.lastUserID))
			}

			if mm_want_ptrs.limit != nil && !minimock.Equal(*mm_want_ptrs.limit, mm_got.limit) {
				mmGetListBySKU.t.Errorf("CommentRepositoryMock.GetListBySKU got unexpected parameter limit, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetListBySKU.GetListBySKUMock.defaultExpectation.expectationOrigins.originLimit, *mm_want_ptrs.limit, mm_got.limit, minimock.Diff(*mm_want_ptrs.limit, mm_got.limit))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetListBySKU.t.Errorf("CommentRepositoryMock.GetListBySKU got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetListBySKU.GetListBySKUMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetListBySKU.GetListBySKUMock.defaultExpectation.results
		if mm_results == nil {
			mmGetListBySKU.t.Fatal("No results are set for the CommentRepositoryMock.GetListBySKU")
		}
		return (*mm_results).cpa1, (*mm_results).err
	}
	if mmGetListBySKU.funcGetListBySKU != nil {
		return mmGetListBySKU.funcGetListBySKU(ctx, sku, lastCreatedAt, lastUserID, limit)
	}
	mmGetListBySKU.t.Fatalf("Unexpected call to CommentRepositoryMock.GetListBySKU. %v %v %v %v %v", ctx, sku, lastCreatedAt, lastUserID, limit)
	return
}

// GetListBySKUAfterCounter returns a count of finished CommentRepositoryMock.GetListBySKU invocations
func (mmGetListBySKU *CommentRepositoryMock) GetListBySKUAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetListBySKU.afterGetListBySKUCounter)
}

// GetListBySKUBeforeCounter returns a count of CommentRepositoryMock.GetListBySKU invocations
func (mmGetListBySKU *CommentRepositoryMock) GetListBySKUBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetListBySKU.beforeGetListBySKUCounter)
}

// Calls returns a list of arguments used in each call to CommentRepositoryMock.GetListBySKU.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetListBySKU *mCommentRepositoryMockGetListBySKU) Calls() []*CommentRepositoryMockGetListBySKUParams {
	mmGetListBySKU.mutex.RLock()

	argCopy := make([]*CommentRepositoryMockGetListBySKUParams, len(mmGetListBySKU.callArgs))
	copy(argCopy, mmGetListBySKU.callArgs)

	mmGetListBySKU.mutex.RUnlock()

	return argCopy
}

// MinimockGetListBySKUDone returns true if the count of the GetListBySKU invocations corresponds
// the number of defined expectations
func (m *CommentRepositoryMock) MinimockGetListBySKUDone() bool {
	if m.GetListBySKUMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetListBySKUMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetListBySKUMock.invocationsDone()
}

// MinimockGetListBySKUInspect logs each unmet expectation
func (m *CommentRepositoryMock) MinimockGetListBySKUInspect() {
	for _, e := range m.GetListBySKUMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to CommentRepositoryMock.GetListBySKU at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetListBySKUCounter := mm_atomic.LoadUint64(&m.afterGetListBySKUCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetListBySKUMock.defaultExpectation != nil && afterGetListBySKUCounter < 1 {
		if m.GetListBySKUMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to CommentRepositoryMock.GetListBySKU at\n%s", m.GetListBySKUMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to CommentRepositoryMock.GetListBySKU at\n%s with params: %#v", m.GetListBySKUMock.defaultExpectation.expectationOrigins.origin, *m.GetListBySKUMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetListBySKU != nil && afterGetListBySKUCounter < 1 {
		m.t.Errorf("Expected call to CommentRepositoryMock.GetListBySKU at\n%s", m.funcGetListBySKUOrigin)
	}

	if !m.GetListBySKUMock.invocationsDone() && afterGetListBySKUCounter > 0 {
		m.t.Errorf("Expected %d calls to CommentRepositoryMock.GetListBySKU at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetListBySKUMock.expectedInvocations), m.GetListBySKUMock.expectedInvocationsOrigin, afterGetListBySKUCounter)
	}
}

type mCommentRepositoryMockGetListByUser struct {
	optional           bool
	mock               *CommentRepositoryMock
	defaultExpectation *CommentRepositoryMockGetListByUserExpectation
	expectations       []*CommentRepositoryMockGetListByUserExpectation

	callArgs []*CommentRepositoryMockGetListByUserParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// CommentRepositoryMockGetListByUserExpectation specifies expectation struct of the commentRepository.GetListByUser
type CommentRepositoryMockGetListByUserExpectation struct {
	mock               *CommentRepositoryMock
	params             *CommentRepositoryMockGetListByUserParams
	paramPtrs          *CommentRepositoryMockGetListByUserParamPtrs
	expectationOrigins CommentRepositoryMockGetListByUserExpectationOrigins
	results            *CommentRepositoryMockGetListByUserResults
	returnOrigin       string
	Counter            uint64
}

// CommentRepositoryMockGetListByUserParams contains parameters of the commentRepository.GetListByUser
type CommentRepositoryMockGetListByUserParams struct {
	ctx    context.Context
	userID int64
}

// CommentRepositoryMockGetListByUserParamPtrs contains pointers to parameters of the commentRepository.GetListByUser
type CommentRepositoryMockGetListByUserParamPtrs struct {
	ctx    *context.Context
	userID *int64
}

// CommentRepositoryMockGetListByUserResults contains results of the commentRepository.GetListByUser
type CommentRepositoryMockGetListByUserResults struct {
	cpa1 []*domain.Comment
	err  error
}

// CommentRepositoryMockGetListByUserOrigins contains origins of expectations of the commentRepository.GetListByUser
type CommentRepositoryMockGetListByUserExpectationOrigins struct {
	origin       string
	originCtx    string
	originUserID string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetListByUser *mCommentRepositoryMockGetListByUser) Optional() *mCommentRepositoryMockGetListByUser {
	mmGetListByUser.optional = true
	return mmGetListByUser
}

// Expect sets up expected params for commentRepository.GetListByUser
func (mmGetListByUser *mCommentRepositoryMockGetListByUser) Expect(ctx context.Context, userID int64) *mCommentRepositoryMockGetListByUser {
	if mmGetListByUser.mock.funcGetListByUser != nil {
		mmGetListByUser.mock.t.Fatalf("CommentRepositoryMock.GetListByUser mock is already set by Set")
	}

	if mmGetListByUser.defaultExpectation == nil {
		mmGetListByUser.defaultExpectation = &CommentRepositoryMockGetListByUserExpectation{}
	}

	if mmGetListByUser.defaultExpectation.paramPtrs != nil {
		mmGetListByUser.mock.t.Fatalf("CommentRepositoryMock.GetListByUser mock is already set by ExpectParams functions")
	}

	mmGetListByUser.defaultExpectation.params = &CommentRepositoryMockGetListByUserParams{ctx, userID}
	mmGetListByUser.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetListByUser.expectations {
		if minimock.Equal(e.params, mmGetListByUser.defaultExpectation.params) {
			mmGetListByUser.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetListByUser.defaultExpectation.params)
		}
	}

	return mmGetListByUser
}

// ExpectCtxParam1 sets up expected param ctx for commentRepository.GetListByUser
func (mmGetListByUser *mCommentRepositoryMockGetListByUser) ExpectCtxParam1(ctx context.Context) *mCommentRepositoryMockGetListByUser {
	if mmGetListByUser.mock.funcGetListByUser != nil {
		mmGetListByUser.mock.t.Fatalf("CommentRepositoryMock.GetListByUser mock is already set by Set")
	}

	if mmGetListByUser.defaultExpectation == nil {
		mmGetListByUser.defaultExpectation = &CommentRepositoryMockGetListByUserExpectation{}
	}

	if mmGetListByUser.defaultExpectation.params != nil {
		mmGetListByUser.mock.t.Fatalf("CommentRepositoryMock.GetListByUser mock is already set by Expect")
	}

	if mmGetListByUser.defaultExpectation.paramPtrs == nil {
		mmGetListByUser.defaultExpectation.paramPtrs = &CommentRepositoryMockGetListByUserParamPtrs{}
	}
	mmGetListByUser.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetListByUser.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetListByUser
}

// ExpectUserIDParam2 sets up expected param userID for commentRepository.GetListByUser
func (mmGetListByUser *mCommentRepositoryMockGetListByUser) ExpectUserIDParam2(userID int64) *mCommentRepositoryMockGetListByUser {
	if mmGetListByUser.mock.funcGetListByUser != nil {
		mmGetListByUser.mock.t.Fatalf("CommentRepositoryMock.GetListByUser mock is already set by Set")
	}

	if mmGetListByUser.defaultExpectation == nil {
		mmGetListByUser.defaultExpectation = &CommentRepositoryMockGetListByUserExpectation{}
	}

	if mmGetListByUser.defaultExpectation.params != nil {
		mmGetListByUser.mock.t.Fatalf("CommentRepositoryMock.GetListByUser mock is already set by Expect")
	}

	if mmGetListByUser.defaultExpectation.paramPtrs == nil {
		mmGetListByUser.defaultExpectation.paramPtrs = &CommentRepositoryMockGetListByUserParamPtrs{}
	}
	mmGetListByUser.defaultExpectation.paramPtrs.userID = &userID
	mmGetListByUser.defaultExpectation.expectationOrigins.originUserID = minimock.CallerInfo(1)

	return mmGetListByUser
}

// Inspect accepts an inspector function that has same arguments as the commentRepository.GetListByUser
func (mmGetListByUser *mCommentRepositoryMockGetListByUser) Inspect(f func(ctx context.Context, userID int64)) *mCommentRepositoryMockGetListByUser {
	if mmGetListByUser.mock.inspectFuncGetListByUser != nil {
		mmGetListByUser.mock.t.Fatalf("Inspect function is already set for CommentRepositoryMock.GetListByUser")
	}

	mmGetListByUser.mock.inspectFuncGetListByUser = f

	return mmGetListByUser
}

// Return sets up results that will be returned by commentRepository.GetListByUser
func (mmGetListByUser *mCommentRepositoryMockGetListByUser) Return(cpa1 []*domain.Comment, err error) *CommentRepositoryMock {
	if mmGetListByUser.mock.funcGetListByUser != nil {
		mmGetListByUser.mock.t.Fatalf("CommentRepositoryMock.GetListByUser mock is already set by Set")
	}

	if mmGetListByUser.defaultExpectation == nil {
		mmGetListByUser.defaultExpectation = &CommentRepositoryMockGetListByUserExpectation{mock: mmGetListByUser.mock}
	}
	mmGetListByUser.defaultExpectation.results = &CommentRepositoryMockGetListByUserResults{cpa1, err}
	mmGetListByUser.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetListByUser.mock
}

// Set uses given function f to mock the commentRepository.GetListByUser method
func (mmGetListByUser *mCommentRepositoryMockGetListByUser) Set(f func(ctx context.Context, userID int64) (cpa1 []*domain.Comment, err error)) *CommentRepositoryMock {
	if mmGetListByUser.defaultExpectation != nil {
		mmGetListByUser.mock.t.Fatalf("Default expectation is already set for the commentRepository.GetListByUser method")
	}

	if len(mmGetListByUser.expectations) > 0 {
		mmGetListByUser.mock.t.Fatalf("Some expectations are already set for the commentRepository.GetListByUser method")
	}

	mmGetListByUser.mock.funcGetListByUser = f
	mmGetListByUser.mock.funcGetListByUserOrigin = minimock.CallerInfo(1)
	return mmGetListByUser.mock
}

// When sets expectation for the commentRepository.GetListByUser which will trigger the result defined by the following
// Then helper
func (mmGetListByUser *mCommentRepositoryMockGetListByUser) When(ctx context.Context, userID int64) *CommentRepositoryMockGetListByUserExpectation {
	if mmGetListByUser.mock.funcGetListByUser != nil {
		mmGetListByUser.mock.t.Fatalf("CommentRepositoryMock.GetListByUser mock is already set by Set")
	}

	expectation := &CommentRepositoryMockGetListByUserExpectation{
		mock:               mmGetListByUser.mock,
		params:             &CommentRepositoryMockGetListByUserParams{ctx, userID},
		expectationOrigins: CommentRepositoryMockGetListByUserExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetListByUser.expectations = append(mmGetListByUser.expectations, expectation)
	return expectation
}

// Then sets up commentRepository.GetListByUser return parameters for the expectation previously defined by the When method
func (e *CommentRepositoryMockGetListByUserExpectation) Then(cpa1 []*domain.Comment, err error) *CommentRepositoryMock {
	e.results = &CommentRepositoryMockGetListByUserResults{cpa1, err}
	return e.mock
}

// Times sets number of times commentRepository.GetListByUser should be invoked
func (mmGetListByUser *mCommentRepositoryMockGetListByUser) Times(n uint64) *mCommentRepositoryMockGetListByUser {
	if n == 0 {
		mmGetListByUser.mock.t.Fatalf("Times of CommentRepositoryMock.GetListByUser mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetListByUser.expectedInvocations, n)
	mmGetListByUser.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetListByUser
}

func (mmGetListByUser *mCommentRepositoryMockGetListByUser) invocationsDone() bool {
	if len(mmGetListByUser.expectations) == 0 && mmGetListByUser.defaultExpectation == nil && mmGetListByUser.mock.funcGetListByUser == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetListByUser.mock.afterGetListByUserCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetListByUser.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetListByUser implements mm_service.commentRepository
func (mmGetListByUser *CommentRepositoryMock) GetListByUser(ctx context.Context, userID int64) (cpa1 []*domain.Comment, err error) {
	mm_atomic.AddUint64(&mmGetListByUser.beforeGetListByUserCounter, 1)
	defer mm_atomic.AddUint64(&mmGetListByUser.afterGetListByUserCounter, 1)

	mmGetListByUser.t.Helper()

	if mmGetListByUser.inspectFuncGetListByUser != nil {
		mmGetListByUser.inspectFuncGetListByUser(ctx, userID)
	}

	mm_params := CommentRepositoryMockGetListByUserParams{ctx, userID}

	// Record call args
	mmGetListByUser.GetListByUserMock.mutex.Lock()
	mmGetListByUser.GetListByUserMock.callArgs = append(mmGetListByUser.GetListByUserMock.callArgs, &mm_params)
	mmGetListByUser.GetListByUserMock.mutex.Unlock()

	for _, e := range mmGetListByUser.GetListByUserMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.cpa1, e.results.err
		}
	}

	if mmGetListByUser.GetListByUserMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetListByUser.GetListByUserMock.defaultExpectation.Counter, 1)
		mm_want := mmGetListByUser.GetListByUserMock.defaultExpectation.params
		mm_want_ptrs := mmGetListByUser.GetListByUserMock.defaultExpectation.paramPtrs

		mm_got := CommentRepositoryMockGetListByUserParams{ctx, userID}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetListByUser.t.Errorf("CommentRepositoryMock.GetListByUser got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetListByUser.GetListByUserMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.userID != nil && !minimock.Equal(*mm_want_ptrs.userID, mm_got.userID) {
				mmGetListByUser.t.Errorf("CommentRepositoryMock.GetListByUser got unexpected parameter userID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetListByUser.GetListByUserMock.defaultExpectation.expectationOrigins.originUserID, *mm_want_ptrs.userID, mm_got.userID, minimock.Diff(*mm_want_ptrs.userID, mm_got.userID))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetListByUser.t.Errorf("CommentRepositoryMock.GetListByUser got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetListByUser.GetListByUserMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetListByUser.GetListByUserMock.defaultExpectation.results
		if mm_results == nil {
			mmGetListByUser.t.Fatal("No results are set for the CommentRepositoryMock.GetListByUser")
		}
		return (*mm_results).cpa1, (*mm_results).err
	}
	if mmGetListByUser.funcGetListByUser != nil {
		return mmGetListByUser.funcGetListByUser(ctx, userID)
	}
	mmGetListByUser.t.Fatalf("Unexpected call to CommentRepositoryMock.GetListByUser. %v %v", ctx, userID)
	return
}

// GetListByUserAfterCounter returns a count of finished CommentRepositoryMock.GetListByUser invocations
func (mmGetListByUser *CommentRepositoryMock) GetListByUserAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetListByUser.afterGetListByUserCounter)
}

// GetListByUserBeforeCounter returns a count of CommentRepositoryMock.GetListByUser invocations
func (mmGetListByUser *CommentRepositoryMock) GetListByUserBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetListByUser.beforeGetListByUserCounter)
}

// Calls returns a list of arguments used in each call to CommentRepositoryMock.GetListByUser.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetListByUser *mCommentRepositoryMockGetListByUser) Calls() []*CommentRepositoryMockGetListByUserParams {
	mmGetListByUser.mutex.RLock()

	argCopy := make([]*CommentRepositoryMockGetListByUserParams, len(mmGetListByUser.callArgs))
	copy(argCopy, mmGetListByUser.callArgs)

	mmGetListByUser.mutex.RUnlock()

	return argCopy
}

// MinimockGetListByUserDone returns true if the count of the GetListByUser invocations corresponds
// the number of defined expectations
func (m *CommentRepositoryMock) MinimockGetListByUserDone() bool {
	if m.GetListByUserMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetListByUserMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetListByUserMock.invocationsDone()
}

// MinimockGetListByUserInspect logs each unmet expectation
func (m *CommentRepositoryMock) MinimockGetListByUserInspect() {
	for _, e := range m.GetListByUserMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to CommentRepositoryMock.GetListByUser at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetListByUserCounter := mm_atomic.LoadUint64(&m.afterGetListByUserCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetListByUserMock.defaultExpectation != nil && afterGetListByUserCounter < 1 {
		if m.GetListByUserMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to CommentRepositoryMock.GetListByUser at\n%s", m.GetListByUserMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to CommentRepositoryMock.GetListByUser at\n%s with params: %#v", m.GetListByUserMock.defaultExpectation.expectationOrigins.origin, *m.GetListByUserMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetListByUser != nil && afterGetListByUserCounter < 1 {
		m.t.Errorf("Expected call to CommentRepositoryMock.GetListByUser at\n%s", m.funcGetListByUserOrigin)
	}

	if !m.GetListByUserMock.invocationsDone() && afterGetListByUserCounter > 0 {
		m.t.Errorf("Expected %d calls to CommentRepositoryMock.GetListByUser at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetListByUserMock.expectedInvocations), m.GetListByUserMock.expectedInvocationsOrigin, afterGetListByUserCounter)
	}
}

type mCommentRepositoryMockInsert struct {
	optional           bool
	mock               *CommentRepositoryMock
	defaultExpectation *CommentRepositoryMockInsertExpectation
	expectations       []*CommentRepositoryMockInsertExpectation

	callArgs []*CommentRepositoryMockInsertParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// CommentRepositoryMockInsertExpectation specifies expectation struct of the commentRepository.Insert
type CommentRepositoryMockInsertExpectation struct {
	mock               *CommentRepositoryMock
	params             *CommentRepositoryMockInsertParams
	paramPtrs          *CommentRepositoryMockInsertParamPtrs
	expectationOrigins CommentRepositoryMockInsertExpectationOrigins
	results            *CommentRepositoryMockInsertResults
	returnOrigin       string
	Counter            uint64
}

// CommentRepositoryMockInsertParams contains parameters of the commentRepository.Insert
type CommentRepositoryMockInsertParams struct {
	ctx     context.Context
	comment *domain.Comment
}

// CommentRepositoryMockInsertParamPtrs contains pointers to parameters of the commentRepository.Insert
type CommentRepositoryMockInsertParamPtrs struct {
	ctx     *context.Context
	comment **domain.Comment
}

// CommentRepositoryMockInsertResults contains results of the commentRepository.Insert
type CommentRepositoryMockInsertResults struct {
	i1  int64
	err error
}

// CommentRepositoryMockInsertOrigins contains origins of expectations of the commentRepository.Insert
type CommentRepositoryMockInsertExpectationOrigins struct {
	origin        string
	originCtx     string
	originComment string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmInsert *mCommentRepositoryMockInsert) Optional() *mCommentRepositoryMockInsert {
	mmInsert.optional = true
	return mmInsert
}

// Expect sets up expected params for commentRepository.Insert
func (mmInsert *mCommentRepositoryMockInsert) Expect(ctx context.Context, comment *domain.Comment) *mCommentRepositoryMockInsert {
	if mmInsert.mock.funcInsert != nil {
		mmInsert.mock.t.Fatalf("CommentRepositoryMock.Insert mock is already set by Set")
	}

	if mmInsert.defaultExpectation == nil {
		mmInsert.defaultExpectation = &CommentRepositoryMockInsertExpectation{}
	}

	if mmInsert.defaultExpectation.paramPtrs != nil {
		mmInsert.mock.t.Fatalf("CommentRepositoryMock.Insert mock is already set by ExpectParams functions")
	}

	mmInsert.defaultExpectation.params = &CommentRepositoryMockInsertParams{ctx, comment}
	mmInsert.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmInsert.expectations {
		if minimock.Equal(e.params, mmInsert.defaultExpectation.params) {
			mmInsert.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmInsert.defaultExpectation.params)
		}
	}

	return mmInsert
}

// ExpectCtxParam1 sets up expected param ctx for commentRepository.Insert
func (mmInsert *mCommentRepositoryMockInsert) ExpectCtxParam1(ctx context.Context) *mCommentRepositoryMockInsert {
	if mmInsert.mock.funcInsert != nil {
		mmInsert.mock.t.Fatalf("CommentRepositoryMock.Insert mock is already set by Set")
	}

	if mmInsert.defaultExpectation == nil {
		mmInsert.defaultExpectation = &CommentRepositoryMockInsertExpectation{}
	}

	if mmInsert.defaultExpectation.params != nil {
		mmInsert.mock.t.Fatalf("CommentRepositoryMock.Insert mock is already set by Expect")
	}

	if mmInsert.defaultExpectation.paramPtrs == nil {
		mmInsert.defaultExpectation.paramPtrs = &CommentRepositoryMockInsertParamPtrs{}
	}
	mmInsert.defaultExpectation.paramPtrs.ctx = &ctx
	mmInsert.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmInsert
}

// ExpectCommentParam2 sets up expected param comment for commentRepository.Insert
func (mmInsert *mCommentRepositoryMockInsert) ExpectCommentParam2(comment *domain.Comment) *mCommentRepositoryMockInsert {
	if mmInsert.mock.funcInsert != nil {
		mmInsert.mock.t.Fatalf("CommentRepositoryMock.Insert mock is already set by Set")
	}

	if mmInsert.defaultExpectation == nil {
		mmInsert.defaultExpectation = &CommentRepositoryMockInsertExpectation{}
	}

	if mmInsert.defaultExpectation.params != nil {
		mmInsert.mock.t.Fatalf("CommentRepositoryMock.Insert mock is already set by Expect")
	}

	if mmInsert.defaultExpectation.paramPtrs == nil {
		mmInsert.defaultExpectation.paramPtrs = &CommentRepositoryMockInsertParamPtrs{}
	}
	mmInsert.defaultExpectation.paramPtrs.comment = &comment
	mmInsert.defaultExpectation.expectationOrigins.originComment = minimock.CallerInfo(1)

	return mmInsert
}

// Inspect accepts an inspector function that has same arguments as the commentRepository.Insert
func (mmInsert *mCommentRepositoryMockInsert) Inspect(f func(ctx context.Context, comment *domain.Comment)) *mCommentRepositoryMockInsert {
	if mmInsert.mock.inspectFuncInsert != nil {
		mmInsert.mock.t.Fatalf("Inspect function is already set for CommentRepositoryMock.Insert")
	}

	mmInsert.mock.inspectFuncInsert = f

	return mmInsert
}

// Return sets up results that will be returned by commentRepository.Insert
func (mmInsert *mCommentRepositoryMockInsert) Return(i1 int64, err error) *CommentRepositoryMock {
	if mmInsert.mock.funcInsert != nil {
		mmInsert.mock.t.Fatalf("CommentRepositoryMock.Insert mock is already set by Set")
	}

	if mmInsert.defaultExpectation == nil {
		mmInsert.defaultExpectation = &CommentRepositoryMockInsertExpectation{mock: mmInsert.mock}
	}
	mmInsert.defaultExpectation.results = &CommentRepositoryMockInsertResults{i1, err}
	mmInsert.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmInsert.mock
}

// Set uses given function f to mock the commentRepository.Insert method
func (mmInsert *mCommentRepositoryMockInsert) Set(f func(ctx context.Context, comment *domain.Comment) (i1 int64, err error)) *CommentRepositoryMock {
	if mmInsert.defaultExpectation != nil {
		mmInsert.mock.t.Fatalf("Default expectation is already set for the commentRepository.Insert method")
	}

	if len(mmInsert.expectations) > 0 {
		mmInsert.mock.t.Fatalf("Some expectations are already set for the commentRepository.Insert method")
	}

	mmInsert.mock.funcInsert = f
	mmInsert.mock.funcInsertOrigin = minimock.CallerInfo(1)
	return mmInsert.mock
}

// When sets expectation for the commentRepository.Insert which will trigger the result defined by the following
// Then helper
func (mmInsert *mCommentRepositoryMockInsert) When(ctx context.Context, comment *domain.Comment) *CommentRepositoryMockInsertExpectation {
	if mmInsert.mock.funcInsert != nil {
		mmInsert.mock.t.Fatalf("CommentRepositoryMock.Insert mock is already set by Set")
	}

	expectation := &CommentRepositoryMockInsertExpectation{
		mock:               mmInsert.mock,
		params:             &CommentRepositoryMockInsertParams{ctx, comment},
		expectationOrigins: CommentRepositoryMockInsertExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmInsert.expectations = append(mmInsert.expectations, expectation)
	return expectation
}

// Then sets up commentRepository.Insert return parameters for the expectation previously defined by the When method
func (e *CommentRepositoryMockInsertExpectation) Then(i1 int64, err error) *CommentRepositoryMock {
	e.results = &CommentRepositoryMockInsertResults{i1, err}
	return e.mock
}

// Times sets number of times commentRepository.Insert should be invoked
func (mmInsert *mCommentRepositoryMockInsert) Times(n uint64) *mCommentRepositoryMockInsert {
	if n == 0 {
		mmInsert.mock.t.Fatalf("Times of CommentRepositoryMock.Insert mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmInsert.expectedInvocations, n)
	mmInsert.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmInsert
}

func (mmInsert *mCommentRepositoryMockInsert) invocationsDone() bool {
	if len(mmInsert.expectations) == 0 && mmInsert.defaultExpectation == nil && mmInsert.mock.funcInsert == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmInsert.mock.afterInsertCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmInsert.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Insert implements mm_service.commentRepository
func (mmInsert *CommentRepositoryMock) Insert(ctx context.Context, comment *domain.Comment) (i1 int64, err error) {
	mm_atomic.AddUint64(&mmInsert.beforeInsertCounter, 1)
	defer mm_atomic.AddUint64(&mmInsert.afterInsertCounter, 1)

	mmInsert.t.Helper()

	if mmInsert.inspectFuncInsert != nil {
		mmInsert.inspectFuncInsert(ctx, comment)
	}

	mm_params := CommentRepositoryMockInsertParams{ctx, comment}

	// Record call args
	mmInsert.InsertMock.mutex.Lock()
	mmInsert.InsertMock.callArgs = append(mmInsert.InsertMock.callArgs, &mm_params)
	mmInsert.InsertMock.mutex.Unlock()

	for _, e := range mmInsert.InsertMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.i1, e.results.err
		}
	}

	if mmInsert.InsertMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmInsert.InsertMock.defaultExpectation.Counter, 1)
		mm_want := mmInsert.InsertMock.defaultExpectation.params
		mm_want_ptrs := mmInsert.InsertMock.defaultExpectation.paramPtrs

		mm_got := CommentRepositoryMockInsertParams{ctx, comment}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmInsert.t.Errorf("CommentRepositoryMock.Insert got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmInsert.InsertMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.comment != nil && !minimock.Equal(*mm_want_ptrs.comment, mm_got.comment) {
				mmInsert.t.Errorf("CommentRepositoryMock.Insert got unexpected parameter comment, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmInsert.InsertMock.defaultExpectation.expectationOrigins.originComment, *mm_want_ptrs.comment, mm_got.comment, minimock.Diff(*mm_want_ptrs.comment, mm_got.comment))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmInsert.t.Errorf("CommentRepositoryMock.Insert got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmInsert.InsertMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmInsert.InsertMock.defaultExpectation.results
		if mm_results == nil {
			mmInsert.t.Fatal("No results are set for the CommentRepositoryMock.Insert")
		}
		return (*mm_results).i1, (*mm_results).err
	}
	if mmInsert.funcInsert != nil {
		return mmInsert.funcInsert(ctx, comment)
	}
	mmInsert.t.Fatalf("Unexpected call to CommentRepositoryMock.Insert. %v %v", ctx, comment)
	return
}

// InsertAfterCounter returns a count of finished CommentRepositoryMock.Insert invocations
func (mmInsert *CommentRepositoryMock) InsertAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmInsert.afterInsertCounter)
}

// InsertBeforeCounter returns a count of CommentRepositoryMock.Insert invocations
func (mmInsert *CommentRepositoryMock) InsertBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmInsert.beforeInsertCounter)
}

// Calls returns a list of arguments used in each call to CommentRepositoryMock.Insert.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmInsert *mCommentRepositoryMockInsert) Calls() []*CommentRepositoryMockInsertParams {
	mmInsert.mutex.RLock()

	argCopy := make([]*CommentRepositoryMockInsertParams, len(mmInsert.callArgs))
	copy(argCopy, mmInsert.callArgs)

	mmInsert.mutex.RUnlock()

	return argCopy
}

// MinimockInsertDone returns true if the count of the Insert invocations corresponds
// the number of defined expectations
func (m *CommentRepositoryMock) MinimockInsertDone() bool {
	if m.InsertMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.InsertMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.InsertMock.invocationsDone()
}

// MinimockInsertInspect logs each unmet expectation
func (m *CommentRepositoryMock) MinimockInsertInspect() {
	for _, e := range m.InsertMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to CommentRepositoryMock.Insert at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterInsertCounter := mm_atomic.LoadUint64(&m.afterInsertCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.InsertMock.defaultExpectation != nil && afterInsertCounter < 1 {
		if m.InsertMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to CommentRepositoryMock.Insert at\n%s", m.InsertMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to CommentRepositoryMock.Insert at\n%s with params: %#v", m.InsertMock.defaultExpectation.expectationOrigins.origin, *m.InsertMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcInsert != nil && afterInsertCounter < 1 {
		m.t.Errorf("Expected call to CommentRepositoryMock.Insert at\n%s", m.funcInsertOrigin)
	}

	if !m.InsertMock.invocationsDone() && afterInsertCounter > 0 {
		m.t.Errorf("Expected %d calls to CommentRepositoryMock.Insert at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.InsertMock.expectedInvocations), m.InsertMock.expectedInvocationsOrigin, afterInsertCounter)
	}
}

type mCommentRepositoryMockUpdateContentWithCheck struct {
	optional           bool
	mock               *CommentRepositoryMock
	defaultExpectation *CommentRepositoryMockUpdateContentWithCheckExpectation
	expectations       []*CommentRepositoryMockUpdateContentWithCheckExpectation

	callArgs []*CommentRepositoryMockUpdateContentWithCheckParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// CommentRepositoryMockUpdateContentWithCheckExpectation specifies expectation struct of the commentRepository.UpdateContentWithCheck
type CommentRepositoryMockUpdateContentWithCheckExpectation struct {
	mock               *CommentRepositoryMock
	params             *CommentRepositoryMockUpdateContentWithCheckParams
	paramPtrs          *CommentRepositoryMockUpdateContentWithCheckParamPtrs
	expectationOrigins CommentRepositoryMockUpdateContentWithCheckExpectationOrigins
	results            *CommentRepositoryMockUpdateContentWithCheckResults
	returnOrigin       string
	Counter            uint64
}

// CommentRepositoryMockUpdateContentWithCheckParams contains parameters of the commentRepository.UpdateContentWithCheck
type CommentRepositoryMockUpdateContentWithCheckParams struct {
	ctx        context.Context
	commentID  int64
	newComment *domain.Comment
	predicate  func(oldComment *domain.Comment) error
}

// CommentRepositoryMockUpdateContentWithCheckParamPtrs contains pointers to parameters of the commentRepository.UpdateContentWithCheck
type CommentRepositoryMockUpdateContentWithCheckParamPtrs struct {
	ctx        *context.Context
	commentID  *int64
	newComment **domain.Comment
	predicate  *func(oldComment *domain.Comment) error
}

// CommentRepositoryMockUpdateContentWithCheckResults contains results of the commentRepository.UpdateContentWithCheck
type CommentRepositoryMockUpdateContentWithCheckResults struct {
	err error
}

// CommentRepositoryMockUpdateContentWithCheckOrigins contains origins of expectations of the commentRepository.UpdateContentWithCheck
type CommentRepositoryMockUpdateContentWithCheckExpectationOrigins struct {
	origin           string
	originCtx        string
	originCommentID  string
	originNewComment string
	originPredicate  string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmUpdateContentWithCheck *mCommentRepositoryMockUpdateContentWithCheck) Optional() *mCommentRepositoryMockUpdateContentWithCheck {
	mmUpdateContentWithCheck.optional = true
	return mmUpdateContentWithCheck
}

// Expect sets up expected params for commentRepository.UpdateContentWithCheck
func (mmUpdateContentWithCheck *mCommentRepositoryMockUpdateContentWithCheck) Expect(ctx context.Context, commentID int64, newComment *domain.Comment, predicate func(oldComment *domain.Comment) error) *mCommentRepositoryMockUpdateContentWithCheck {
	if mmUpdateContentWithCheck.mock.funcUpdateContentWithCheck != nil {
		mmUpdateContentWithCheck.mock.t.Fatalf("CommentRepositoryMock.UpdateContentWithCheck mock is already set by Set")
	}

	if mmUpdateContentWithCheck.defaultExpectation == nil {
		mmUpdateContentWithCheck.defaultExpectation = &CommentRepositoryMockUpdateContentWithCheckExpectation{}
	}

	if mmUpdateContentWithCheck.defaultExpectation.paramPtrs != nil {
		mmUpdateContentWithCheck.mock.t.Fatalf("CommentRepositoryMock.UpdateContentWithCheck mock is already set by ExpectParams functions")
	}

	mmUpdateContentWithCheck.defaultExpectation.params = &CommentRepositoryMockUpdateContentWithCheckParams{ctx, commentID, newComment, predicate}
	mmUpdateContentWithCheck.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmUpdateContentWithCheck.expectations {
		if minimock.Equal(e.params, mmUpdateContentWithCheck.defaultExpectation.params) {
			mmUpdateContentWithCheck.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmUpdateContentWithCheck.defaultExpectation.params)
		}
	}

	return mmUpdateContentWithCheck
}

// ExpectCtxParam1 sets up expected param ctx for commentRepository.UpdateContentWithCheck
func (mmUpdateContentWithCheck *mCommentRepositoryMockUpdateContentWithCheck) ExpectCtxParam1(ctx context.Context) *mCommentRepositoryMockUpdateContentWithCheck {
	if mmUpdateContentWithCheck.mock.funcUpdateContentWithCheck != nil {
		mmUpdateContentWithCheck.mock.t.Fatalf("CommentRepositoryMock.UpdateContentWithCheck mock is already set by Set")
	}

	if mmUpdateContentWithCheck.defaultExpectation == nil {
		mmUpdateContentWithCheck.defaultExpectation = &CommentRepositoryMockUpdateContentWithCheckExpectation{}
	}

	if mmUpdateContentWithCheck.defaultExpectation.params != nil {
		mmUpdateContentWithCheck.mock.t.Fatalf("CommentRepositoryMock.UpdateContentWithCheck mock is already set by Expect")
	}

	if mmUpdateContentWithCheck.defaultExpectation.paramPtrs == nil {
		mmUpdateContentWithCheck.defaultExpectation.paramPtrs = &CommentRepositoryMockUpdateContentWithCheckParamPtrs{}
	}
	mmUpdateContentWithCheck.defaultExpectation.paramPtrs.ctx = &ctx
	mmUpdateContentWithCheck.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmUpdateContentWithCheck
}

// ExpectCommentIDParam2 sets up expected param commentID for commentRepository.UpdateContentWithCheck
func (mmUpdateContentWithCheck *mCommentRepositoryMockUpdateContentWithCheck) ExpectCommentIDParam2(commentID int64) *mCommentRepositoryMockUpdateContentWithCheck {
	if mmUpdateContentWithCheck.mock.funcUpdateContentWithCheck != nil {
		mmUpdateContentWithCheck.mock.t.Fatalf("CommentRepositoryMock.UpdateContentWithCheck mock is already set by Set")
	}

	if mmUpdateContentWithCheck.defaultExpectation == nil {
		mmUpdateContentWithCheck.defaultExpectation = &CommentRepositoryMockUpdateContentWithCheckExpectation{}
	}

	if mmUpdateContentWithCheck.defaultExpectation.params != nil {
		mmUpdateContentWithCheck.mock.t.Fatalf("CommentRepositoryMock.UpdateContentWithCheck mock is already set by Expect")
	}

	if mmUpdateContentWithCheck.defaultExpectation.paramPtrs == nil {
		mmUpdateContentWithCheck.defaultExpectation.paramPtrs = &CommentRepositoryMockUpdateContentWithCheckParamPtrs{}
	}
	mmUpdateContentWithCheck.defaultExpectation.paramPtrs.commentID = &commentID
	mmUpdateContentWithCheck.defaultExpectation.expectationOrigins.originCommentID = minimock.CallerInfo(1)

	return mmUpdateContentWithCheck
}

// ExpectNewCommentParam3 sets up expected param newComment for commentRepository.UpdateContentWithCheck
func (mmUpdateContentWithCheck *mCommentRepositoryMockUpdateContentWithCheck) ExpectNewCommentParam3(newComment *domain.Comment) *mCommentRepositoryMockUpdateContentWithCheck {
	if mmUpdateContentWithCheck.mock.funcUpdateContentWithCheck != nil {
		mmUpdateContentWithCheck.mock.t.Fatalf("CommentRepositoryMock.UpdateContentWithCheck mock is already set by Set")
	}

	if mmUpdateContentWithCheck.defaultExpectation == nil {
		mmUpdateContentWithCheck.defaultExpectation = &CommentRepositoryMockUpdateContentWithCheckExpectation{}
	}

	if mmUpdateContentWithCheck.defaultExpectation.params != nil {
		mmUpdateContentWithCheck.mock.t.Fatalf("CommentRepositoryMock.UpdateContentWithCheck mock is already set by Expect")
	}

	if mmUpdateContentWithCheck.defaultExpectation.paramPtrs == nil {
		mmUpdateContentWithCheck.defaultExpectation.paramPtrs = &CommentRepositoryMockUpdateContentWithCheckParamPtrs{}
	}
	mmUpdateContentWithCheck.defaultExpectation.paramPtrs.newComment = &newComment
	mmUpdateContentWithCheck.defaultExpectation.expectationOrigins.originNewComment = minimock.CallerInfo(1)

	return mmUpdateContentWithCheck
}

// ExpectPredicateParam4 sets up expected param predicate for commentRepository.UpdateContentWithCheck
func (mmUpdateContentWithCheck *mCommentRepositoryMockUpdateContentWithCheck) ExpectPredicateParam4(predicate func(oldComment *domain.Comment) error) *mCommentRepositoryMockUpdateContentWithCheck {
	if mmUpdateContentWithCheck.mock.funcUpdateContentWithCheck != nil {
		mmUpdateContentWithCheck.mock.t.Fatalf("CommentRepositoryMock.UpdateContentWithCheck mock is already set by Set")
	}

	if mmUpdateContentWithCheck.defaultExpectation == nil {
		mmUpdateContentWithCheck.defaultExpectation = &CommentRepositoryMockUpdateContentWithCheckExpectation{}
	}

	if mmUpdateContentWithCheck.defaultExpectation.params != nil {
		mmUpdateContentWithCheck.mock.t.Fatalf("CommentRepositoryMock.UpdateContentWithCheck mock is already set by Expect")
	}

	if mmUpdateContentWithCheck.defaultExpectation.paramPtrs == nil {
		mmUpdateContentWithCheck.defaultExpectation.paramPtrs = &CommentRepositoryMockUpdateContentWithCheckParamPtrs{}
	}
	mmUpdateContentWithCheck.defaultExpectation.paramPtrs.predicate = &predicate
	mmUpdateContentWithCheck.defaultExpectation.expectationOrigins.originPredicate = minimock.CallerInfo(1)

	return mmUpdateContentWithCheck
}

// Inspect accepts an inspector function that has same arguments as the commentRepository.UpdateContentWithCheck
func (mmUpdateContentWithCheck *mCommentRepositoryMockUpdateContentWithCheck) Inspect(f func(ctx context.Context, commentID int64, newComment *domain.Comment, predicate func(oldComment *domain.Comment) error)) *mCommentRepositoryMockUpdateContentWithCheck {
	if mmUpdateContentWithCheck.mock.inspectFuncUpdateContentWithCheck != nil {
		mmUpdateContentWithCheck.mock.t.Fatalf("Inspect function is already set for CommentRepositoryMock.UpdateContentWithCheck")
	}

	mmUpdateContentWithCheck.mock.inspectFuncUpdateContentWithCheck = f

	return mmUpdateContentWithCheck
}

// Return sets up results that will be returned by commentRepository.UpdateContentWithCheck
func (mmUpdateContentWithCheck *mCommentRepositoryMockUpdateContentWithCheck) Return(err error) *CommentRepositoryMock {
	if mmUpdateContentWithCheck.mock.funcUpdateContentWithCheck != nil {
		mmUpdateContentWithCheck.mock.t.Fatalf("CommentRepositoryMock.UpdateContentWithCheck mock is already set by Set")
	}

	if mmUpdateContentWithCheck.defaultExpectation == nil {
		mmUpdateContentWithCheck.defaultExpectation = &CommentRepositoryMockUpdateContentWithCheckExpectation{mock: mmUpdateContentWithCheck.mock}
	}
	mmUpdateContentWithCheck.defaultExpectation.results = &CommentRepositoryMockUpdateContentWithCheckResults{err}
	mmUpdateContentWithCheck.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmUpdateContentWithCheck.mock
}

// Set uses given function f to mock the commentRepository.UpdateContentWithCheck method
func (mmUpdateContentWithCheck *mCommentRepositoryMockUpdateContentWithCheck) Set(f func(ctx context.Context, commentID int64, newComment *domain.Comment, predicate func(oldComment *domain.Comment) error) (err error)) *CommentRepositoryMock {
	if mmUpdateContentWithCheck.defaultExpectation != nil {
		mmUpdateContentWithCheck.mock.t.Fatalf("Default expectation is already set for the commentRepository.UpdateContentWithCheck method")
	}

	if len(mmUpdateContentWithCheck.expectations) > 0 {
		mmUpdateContentWithCheck.mock.t.Fatalf("Some expectations are already set for the commentRepository.UpdateContentWithCheck method")
	}

	mmUpdateContentWithCheck.mock.funcUpdateContentWithCheck = f
	mmUpdateContentWithCheck.mock.funcUpdateContentWithCheckOrigin = minimock.CallerInfo(1)
	return mmUpdateContentWithCheck.mock
}

// When sets expectation for the commentRepository.UpdateContentWithCheck which will trigger the result defined by the following
// Then helper
func (mmUpdateContentWithCheck *mCommentRepositoryMockUpdateContentWithCheck) When(ctx context.Context, commentID int64, newComment *domain.Comment, predicate func(oldComment *domain.Comment) error) *CommentRepositoryMockUpdateContentWithCheckExpectation {
	if mmUpdateContentWithCheck.mock.funcUpdateContentWithCheck != nil {
		mmUpdateContentWithCheck.mock.t.Fatalf("CommentRepositoryMock.UpdateContentWithCheck mock is already set by Set")
	}

	expectation := &CommentRepositoryMockUpdateContentWithCheckExpectation{
		mock:               mmUpdateContentWithCheck.mock,
		params:             &CommentRepositoryMockUpdateContentWithCheckParams{ctx, commentID, newComment, predicate},
		expectationOrigins: CommentRepositoryMockUpdateContentWithCheckExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmUpdateContentWithCheck.expectations = append(mmUpdateContentWithCheck.expectations, expectation)
	return expectation
}

// Then sets up commentRepository.UpdateContentWithCheck return parameters for the expectation previously defined by the When method
func (e *CommentRepositoryMockUpdateContentWithCheckExpectation) Then(err error) *CommentRepositoryMock {
	e.results = &CommentRepositoryMockUpdateContentWithCheckResults{err}
	return e.mock
}

// Times sets number of times commentRepository.UpdateContentWithCheck should be invoked
func (mmUpdateContentWithCheck *mCommentRepositoryMockUpdateContentWithCheck) Times(n uint64) *mCommentRepositoryMockUpdateContentWithCheck {
	if n == 0 {
		mmUpdateContentWithCheck.mock.t.Fatalf("Times of CommentRepositoryMock.UpdateContentWithCheck mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmUpdateContentWithCheck.expectedInvocations, n)
	mmUpdateContentWithCheck.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmUpdateContentWithCheck
}

func (mmUpdateContentWithCheck *mCommentRepositoryMockUpdateContentWithCheck) invocationsDone() bool {
	if len(mmUpdateContentWithCheck.expectations) == 0 && mmUpdateContentWithCheck.defaultExpectation == nil && mmUpdateContentWithCheck.mock.funcUpdateContentWithCheck == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmUpdateContentWithCheck.mock.afterUpdateContentWithCheckCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmUpdateContentWithCheck.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// UpdateContentWithCheck implements mm_service.commentRepository
func (mmUpdateContentWithCheck *CommentRepositoryMock) UpdateContentWithCheck(ctx context.Context, commentID int64, newComment *domain.Comment, predicate func(oldComment *domain.Comment) error) (err error) {
	mm_atomic.AddUint64(&mmUpdateContentWithCheck.beforeUpdateContentWithCheckCounter, 1)
	defer mm_atomic.AddUint64(&mmUpdateContentWithCheck.afterUpdateContentWithCheckCounter, 1)

	mmUpdateContentWithCheck.t.Helper()

	if mmUpdateContentWithCheck.inspectFuncUpdateContentWithCheck != nil {
		mmUpdateContentWithCheck.inspectFuncUpdateContentWithCheck(ctx, commentID, newComment, predicate)
	}

	mm_params := CommentRepositoryMockUpdateContentWithCheckParams{ctx, commentID, newComment, predicate}

	// Record call args
	mmUpdateContentWithCheck.UpdateContentWithCheckMock.mutex.Lock()
	mmUpdateContentWithCheck.UpdateContentWithCheckMock.callArgs = append(mmUpdateContentWithCheck.UpdateContentWithCheckMock.callArgs, &mm_params)
	mmUpdateContentWithCheck.UpdateContentWithCheckMock.mutex.Unlock()

	for _, e := range mmUpdateContentWithCheck.UpdateContentWithCheckMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmUpdateContentWithCheck.UpdateContentWithCheckMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmUpdateContentWithCheck.UpdateContentWithCheckMock.defaultExpectation.Counter, 1)
		mm_want := mmUpdateContentWithCheck.UpdateContentWithCheckMock.defaultExpectation.params
		mm_want_ptrs := mmUpdateContentWithCheck.UpdateContentWithCheckMock.defaultExpectation.paramPtrs

		mm_got := CommentRepositoryMockUpdateContentWithCheckParams{ctx, commentID, newComment, predicate}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmUpdateContentWithCheck.t.Errorf("CommentRepositoryMock.UpdateContentWithCheck got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdateContentWithCheck.UpdateContentWithCheckMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.commentID != nil && !minimock.Equal(*mm_want_ptrs.commentID, mm_got.commentID) {
				mmUpdateContentWithCheck.t.Errorf("CommentRepositoryMock.UpdateContentWithCheck got unexpected parameter commentID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdateContentWithCheck.UpdateContentWithCheckMock.defaultExpectation.expectationOrigins.originCommentID, *mm_want_ptrs.commentID, mm_got.commentID, minimock.Diff(*mm_want_ptrs.commentID, mm_got.commentID))
			}

			if mm_want_ptrs.newComment != nil && !minimock.Equal(*mm_want_ptrs.newComment, mm_got.newComment) {
				mmUpdateContentWithCheck.t.Errorf("CommentRepositoryMock.UpdateContentWithCheck got unexpected parameter newComment, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdateContentWithCheck.UpdateContentWithCheckMock.defaultExpectation.expectationOrigins.originNewComment, *mm_want_ptrs.newComment, mm_got.newComment, minimock.Diff(*mm_want_ptrs.newComment, mm_got.newComment))
			}

			if mm_want_ptrs.predicate != nil && !minimock.Equal(*mm_want_ptrs.predicate, mm_got.predicate) {
				mmUpdateContentWithCheck.t.Errorf("CommentRepositoryMock.UpdateContentWithCheck got unexpected parameter predicate, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdateContentWithCheck.UpdateContentWithCheckMock.defaultExpectation.expectationOrigins.originPredicate, *mm_want_ptrs.predicate, mm_got.predicate, minimock.Diff(*mm_want_ptrs.predicate, mm_got.predicate))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmUpdateContentWithCheck.t.Errorf("CommentRepositoryMock.UpdateContentWithCheck got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmUpdateContentWithCheck.UpdateContentWithCheckMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmUpdateContentWithCheck.UpdateContentWithCheckMock.defaultExpectation.results
		if mm_results == nil {
			mmUpdateContentWithCheck.t.Fatal("No results are set for the CommentRepositoryMock.UpdateContentWithCheck")
		}
		return (*mm_results).err
	}
	if mmUpdateContentWithCheck.funcUpdateContentWithCheck != nil {
		return mmUpdateContentWithCheck.funcUpdateContentWithCheck(ctx, commentID, newComment, predicate)
	}
	mmUpdateContentWithCheck.t.Fatalf("Unexpected call to CommentRepositoryMock.UpdateContentWithCheck. %v %v %v %v", ctx, commentID, newComment, predicate)
	return
}

// UpdateContentWithCheckAfterCounter returns a count of finished CommentRepositoryMock.UpdateContentWithCheck invocations
func (mmUpdateContentWithCheck *CommentRepositoryMock) UpdateContentWithCheckAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateContentWithCheck.afterUpdateContentWithCheckCounter)
}

// UpdateContentWithCheckBeforeCounter returns a count of CommentRepositoryMock.UpdateContentWithCheck invocations
func (mmUpdateContentWithCheck *CommentRepositoryMock) UpdateContentWithCheckBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateContentWithCheck.beforeUpdateContentWithCheckCounter)
}

// Calls returns a list of arguments used in each call to CommentRepositoryMock.UpdateContentWithCheck.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmUpdateContentWithCheck *mCommentRepositoryMockUpdateContentWithCheck) Calls() []*CommentRepositoryMockUpdateContentWithCheckParams {
	mmUpdateContentWithCheck.mutex.RLock()

	argCopy := make([]*CommentRepositoryMockUpdateContentWithCheckParams, len(mmUpdateContentWithCheck.callArgs))
	copy(argCopy, mmUpdateContentWithCheck.callArgs)

	mmUpdateContentWithCheck.mutex.RUnlock()

	return argCopy
}

// MinimockUpdateContentWithCheckDone returns true if the count of the UpdateContentWithCheck invocations corresponds
// the number of defined expectations
func (m *CommentRepositoryMock) MinimockUpdateContentWithCheckDone() bool {
	if m.UpdateContentWithCheckMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.UpdateContentWithCheckMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.UpdateContentWithCheckMock.invocationsDone()
}

// MinimockUpdateContentWithCheckInspect logs each unmet expectation
func (m *CommentRepositoryMock) MinimockUpdateContentWithCheckInspect() {
	for _, e := range m.UpdateContentWithCheckMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to CommentRepositoryMock.UpdateContentWithCheck at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterUpdateContentWithCheckCounter := mm_atomic.LoadUint64(&m.afterUpdateContentWithCheckCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.UpdateContentWithCheckMock.defaultExpectation != nil && afterUpdateContentWithCheckCounter < 1 {
		if m.UpdateContentWithCheckMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to CommentRepositoryMock.UpdateContentWithCheck at\n%s", m.UpdateContentWithCheckMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to CommentRepositoryMock.UpdateContentWithCheck at\n%s with params: %#v", m.UpdateContentWithCheckMock.defaultExpectation.expectationOrigins.origin, *m.UpdateContentWithCheckMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpdateContentWithCheck != nil && afterUpdateContentWithCheckCounter < 1 {
		m.t.Errorf("Expected call to CommentRepositoryMock.UpdateContentWithCheck at\n%s", m.funcUpdateContentWithCheckOrigin)
	}

	if !m.UpdateContentWithCheckMock.invocationsDone() && afterUpdateContentWithCheckCounter > 0 {
		m.t.Errorf("Expected %d calls to CommentRepositoryMock.UpdateContentWithCheck at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.UpdateContentWithCheckMock.expectedInvocations), m.UpdateContentWithCheckMock.expectedInvocationsOrigin, afterUpdateContentWithCheckCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *CommentRepositoryMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockGetByIDInspect()

			m.MinimockGetListBySKUInspect()

			m.MinimockGetListByUserInspect()

			m.MinimockInsertInspect()

			m.MinimockUpdateContentWithCheckInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *CommentRepositoryMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *CommentRepositoryMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockGetByIDDone() &&
		m.MinimockGetListBySKUDone() &&
		m.MinimockGetListByUserDone() &&
		m.MinimockInsertDone() &&
		m.MinimockUpdateContentWithCheckDone()
}
