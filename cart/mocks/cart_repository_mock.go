// Code generated by http://github.com/gojuno/minimock (v3.4.5). DO NOT EDIT.

package mocks

//go:generate minimock -i route256/cart/internal/service.CartRepository -o cart_repository_mock.go -n CartRepositoryMock -p mocks

import (
	"context"
	"route256/cart/internal/domain"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
)

// CartRepositoryMock implements mm_service.CartRepository
type CartRepositoryMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcDeleteCart          func(ctx context.Context, userID int64) (err error)
	funcDeleteCartOrigin    string
	inspectFuncDeleteCart   func(ctx context.Context, userID int64)
	afterDeleteCartCounter  uint64
	beforeDeleteCartCounter uint64
	DeleteCartMock          mCartRepositoryMockDeleteCart

	funcDeleteCartItem          func(ctx context.Context, userID int64, skuID int64) (err error)
	funcDeleteCartItemOrigin    string
	inspectFuncDeleteCartItem   func(ctx context.Context, userID int64, skuID int64)
	afterDeleteCartItemCounter  uint64
	beforeDeleteCartItemCounter uint64
	DeleteCartItemMock          mCartRepositoryMockDeleteCartItem

	funcGetCartByUserIDOrderBySku          func(ctx context.Context, userID int64) (cp1 *domain.Cart, err error)
	funcGetCartByUserIDOrderBySkuOrigin    string
	inspectFuncGetCartByUserIDOrderBySku   func(ctx context.Context, userID int64)
	afterGetCartByUserIDOrderBySkuCounter  uint64
	beforeGetCartByUserIDOrderBySkuCounter uint64
	GetCartByUserIDOrderBySkuMock          mCartRepositoryMockGetCartByUserIDOrderBySku

	funcUpsertCartItem          func(ctx context.Context, userID int64, newItem *domain.CartItem) (cp1 *domain.CartItem, err error)
	funcUpsertCartItemOrigin    string
	inspectFuncUpsertCartItem   func(ctx context.Context, userID int64, newItem *domain.CartItem)
	afterUpsertCartItemCounter  uint64
	beforeUpsertCartItemCounter uint64
	UpsertCartItemMock          mCartRepositoryMockUpsertCartItem
}

// NewCartRepositoryMock returns a mock for mm_service.CartRepository
func NewCartRepositoryMock(t minimock.Tester) *CartRepositoryMock {
	m := &CartRepositoryMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.DeleteCartMock = mCartRepositoryMockDeleteCart{mock: m}
	m.DeleteCartMock.callArgs = []*CartRepositoryMockDeleteCartParams{}

	m.DeleteCartItemMock = mCartRepositoryMockDeleteCartItem{mock: m}
	m.DeleteCartItemMock.callArgs = []*CartRepositoryMockDeleteCartItemParams{}

	m.GetCartByUserIDOrderBySkuMock = mCartRepositoryMockGetCartByUserIDOrderBySku{mock: m}
	m.GetCartByUserIDOrderBySkuMock.callArgs = []*CartRepositoryMockGetCartByUserIDOrderBySkuParams{}

	m.UpsertCartItemMock = mCartRepositoryMockUpsertCartItem{mock: m}
	m.UpsertCartItemMock.callArgs = []*CartRepositoryMockUpsertCartItemParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mCartRepositoryMockDeleteCart struct {
	optional           bool
	mock               *CartRepositoryMock
	defaultExpectation *CartRepositoryMockDeleteCartExpectation
	expectations       []*CartRepositoryMockDeleteCartExpectation

	callArgs []*CartRepositoryMockDeleteCartParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// CartRepositoryMockDeleteCartExpectation specifies expectation struct of the CartRepository.DeleteCart
type CartRepositoryMockDeleteCartExpectation struct {
	mock               *CartRepositoryMock
	params             *CartRepositoryMockDeleteCartParams
	paramPtrs          *CartRepositoryMockDeleteCartParamPtrs
	expectationOrigins CartRepositoryMockDeleteCartExpectationOrigins
	results            *CartRepositoryMockDeleteCartResults
	returnOrigin       string
	Counter            uint64
}

// CartRepositoryMockDeleteCartParams contains parameters of the CartRepository.DeleteCart
type CartRepositoryMockDeleteCartParams struct {
	ctx    context.Context
	userID int64
}

// CartRepositoryMockDeleteCartParamPtrs contains pointers to parameters of the CartRepository.DeleteCart
type CartRepositoryMockDeleteCartParamPtrs struct {
	ctx    *context.Context
	userID *int64
}

// CartRepositoryMockDeleteCartResults contains results of the CartRepository.DeleteCart
type CartRepositoryMockDeleteCartResults struct {
	err error
}

// CartRepositoryMockDeleteCartOrigins contains origins of expectations of the CartRepository.DeleteCart
type CartRepositoryMockDeleteCartExpectationOrigins struct {
	origin       string
	originCtx    string
	originUserID string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmDeleteCart *mCartRepositoryMockDeleteCart) Optional() *mCartRepositoryMockDeleteCart {
	mmDeleteCart.optional = true
	return mmDeleteCart
}

// Expect sets up expected params for CartRepository.DeleteCart
func (mmDeleteCart *mCartRepositoryMockDeleteCart) Expect(ctx context.Context, userID int64) *mCartRepositoryMockDeleteCart {
	if mmDeleteCart.mock.funcDeleteCart != nil {
		mmDeleteCart.mock.t.Fatalf("CartRepositoryMock.DeleteCart mock is already set by Set")
	}

	if mmDeleteCart.defaultExpectation == nil {
		mmDeleteCart.defaultExpectation = &CartRepositoryMockDeleteCartExpectation{}
	}

	if mmDeleteCart.defaultExpectation.paramPtrs != nil {
		mmDeleteCart.mock.t.Fatalf("CartRepositoryMock.DeleteCart mock is already set by ExpectParams functions")
	}

	mmDeleteCart.defaultExpectation.params = &CartRepositoryMockDeleteCartParams{ctx, userID}
	mmDeleteCart.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmDeleteCart.expectations {
		if minimock.Equal(e.params, mmDeleteCart.defaultExpectation.params) {
			mmDeleteCart.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDeleteCart.defaultExpectation.params)
		}
	}

	return mmDeleteCart
}

// ExpectCtxParam1 sets up expected param ctx for CartRepository.DeleteCart
func (mmDeleteCart *mCartRepositoryMockDeleteCart) ExpectCtxParam1(ctx context.Context) *mCartRepositoryMockDeleteCart {
	if mmDeleteCart.mock.funcDeleteCart != nil {
		mmDeleteCart.mock.t.Fatalf("CartRepositoryMock.DeleteCart mock is already set by Set")
	}

	if mmDeleteCart.defaultExpectation == nil {
		mmDeleteCart.defaultExpectation = &CartRepositoryMockDeleteCartExpectation{}
	}

	if mmDeleteCart.defaultExpectation.params != nil {
		mmDeleteCart.mock.t.Fatalf("CartRepositoryMock.DeleteCart mock is already set by Expect")
	}

	if mmDeleteCart.defaultExpectation.paramPtrs == nil {
		mmDeleteCart.defaultExpectation.paramPtrs = &CartRepositoryMockDeleteCartParamPtrs{}
	}
	mmDeleteCart.defaultExpectation.paramPtrs.ctx = &ctx
	mmDeleteCart.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmDeleteCart
}

// ExpectUserIDParam2 sets up expected param userID for CartRepository.DeleteCart
func (mmDeleteCart *mCartRepositoryMockDeleteCart) ExpectUserIDParam2(userID int64) *mCartRepositoryMockDeleteCart {
	if mmDeleteCart.mock.funcDeleteCart != nil {
		mmDeleteCart.mock.t.Fatalf("CartRepositoryMock.DeleteCart mock is already set by Set")
	}

	if mmDeleteCart.defaultExpectation == nil {
		mmDeleteCart.defaultExpectation = &CartRepositoryMockDeleteCartExpectation{}
	}

	if mmDeleteCart.defaultExpectation.params != nil {
		mmDeleteCart.mock.t.Fatalf("CartRepositoryMock.DeleteCart mock is already set by Expect")
	}

	if mmDeleteCart.defaultExpectation.paramPtrs == nil {
		mmDeleteCart.defaultExpectation.paramPtrs = &CartRepositoryMockDeleteCartParamPtrs{}
	}
	mmDeleteCart.defaultExpectation.paramPtrs.userID = &userID
	mmDeleteCart.defaultExpectation.expectationOrigins.originUserID = minimock.CallerInfo(1)

	return mmDeleteCart
}

// Inspect accepts an inspector function that has same arguments as the CartRepository.DeleteCart
func (mmDeleteCart *mCartRepositoryMockDeleteCart) Inspect(f func(ctx context.Context, userID int64)) *mCartRepositoryMockDeleteCart {
	if mmDeleteCart.mock.inspectFuncDeleteCart != nil {
		mmDeleteCart.mock.t.Fatalf("Inspect function is already set for CartRepositoryMock.DeleteCart")
	}

	mmDeleteCart.mock.inspectFuncDeleteCart = f

	return mmDeleteCart
}

// Return sets up results that will be returned by CartRepository.DeleteCart
func (mmDeleteCart *mCartRepositoryMockDeleteCart) Return(err error) *CartRepositoryMock {
	if mmDeleteCart.mock.funcDeleteCart != nil {
		mmDeleteCart.mock.t.Fatalf("CartRepositoryMock.DeleteCart mock is already set by Set")
	}

	if mmDeleteCart.defaultExpectation == nil {
		mmDeleteCart.defaultExpectation = &CartRepositoryMockDeleteCartExpectation{mock: mmDeleteCart.mock}
	}
	mmDeleteCart.defaultExpectation.results = &CartRepositoryMockDeleteCartResults{err}
	mmDeleteCart.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmDeleteCart.mock
}

// Set uses given function f to mock the CartRepository.DeleteCart method
func (mmDeleteCart *mCartRepositoryMockDeleteCart) Set(f func(ctx context.Context, userID int64) (err error)) *CartRepositoryMock {
	if mmDeleteCart.defaultExpectation != nil {
		mmDeleteCart.mock.t.Fatalf("Default expectation is already set for the CartRepository.DeleteCart method")
	}

	if len(mmDeleteCart.expectations) > 0 {
		mmDeleteCart.mock.t.Fatalf("Some expectations are already set for the CartRepository.DeleteCart method")
	}

	mmDeleteCart.mock.funcDeleteCart = f
	mmDeleteCart.mock.funcDeleteCartOrigin = minimock.CallerInfo(1)
	return mmDeleteCart.mock
}

// When sets expectation for the CartRepository.DeleteCart which will trigger the result defined by the following
// Then helper
func (mmDeleteCart *mCartRepositoryMockDeleteCart) When(ctx context.Context, userID int64) *CartRepositoryMockDeleteCartExpectation {
	if mmDeleteCart.mock.funcDeleteCart != nil {
		mmDeleteCart.mock.t.Fatalf("CartRepositoryMock.DeleteCart mock is already set by Set")
	}

	expectation := &CartRepositoryMockDeleteCartExpectation{
		mock:               mmDeleteCart.mock,
		params:             &CartRepositoryMockDeleteCartParams{ctx, userID},
		expectationOrigins: CartRepositoryMockDeleteCartExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmDeleteCart.expectations = append(mmDeleteCart.expectations, expectation)
	return expectation
}

// Then sets up CartRepository.DeleteCart return parameters for the expectation previously defined by the When method
func (e *CartRepositoryMockDeleteCartExpectation) Then(err error) *CartRepositoryMock {
	e.results = &CartRepositoryMockDeleteCartResults{err}
	return e.mock
}

// Times sets number of times CartRepository.DeleteCart should be invoked
func (mmDeleteCart *mCartRepositoryMockDeleteCart) Times(n uint64) *mCartRepositoryMockDeleteCart {
	if n == 0 {
		mmDeleteCart.mock.t.Fatalf("Times of CartRepositoryMock.DeleteCart mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmDeleteCart.expectedInvocations, n)
	mmDeleteCart.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmDeleteCart
}

func (mmDeleteCart *mCartRepositoryMockDeleteCart) invocationsDone() bool {
	if len(mmDeleteCart.expectations) == 0 && mmDeleteCart.defaultExpectation == nil && mmDeleteCart.mock.funcDeleteCart == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmDeleteCart.mock.afterDeleteCartCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmDeleteCart.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// DeleteCart implements mm_service.CartRepository
func (mmDeleteCart *CartRepositoryMock) DeleteCart(ctx context.Context, userID int64) (err error) {
	mm_atomic.AddUint64(&mmDeleteCart.beforeDeleteCartCounter, 1)
	defer mm_atomic.AddUint64(&mmDeleteCart.afterDeleteCartCounter, 1)

	mmDeleteCart.t.Helper()

	if mmDeleteCart.inspectFuncDeleteCart != nil {
		mmDeleteCart.inspectFuncDeleteCart(ctx, userID)
	}

	mm_params := CartRepositoryMockDeleteCartParams{ctx, userID}

	// Record call args
	mmDeleteCart.DeleteCartMock.mutex.Lock()
	mmDeleteCart.DeleteCartMock.callArgs = append(mmDeleteCart.DeleteCartMock.callArgs, &mm_params)
	mmDeleteCart.DeleteCartMock.mutex.Unlock()

	for _, e := range mmDeleteCart.DeleteCartMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmDeleteCart.DeleteCartMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDeleteCart.DeleteCartMock.defaultExpectation.Counter, 1)
		mm_want := mmDeleteCart.DeleteCartMock.defaultExpectation.params
		mm_want_ptrs := mmDeleteCart.DeleteCartMock.defaultExpectation.paramPtrs

		mm_got := CartRepositoryMockDeleteCartParams{ctx, userID}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmDeleteCart.t.Errorf("CartRepositoryMock.DeleteCart got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteCart.DeleteCartMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.userID != nil && !minimock.Equal(*mm_want_ptrs.userID, mm_got.userID) {
				mmDeleteCart.t.Errorf("CartRepositoryMock.DeleteCart got unexpected parameter userID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteCart.DeleteCartMock.defaultExpectation.expectationOrigins.originUserID, *mm_want_ptrs.userID, mm_got.userID, minimock.Diff(*mm_want_ptrs.userID, mm_got.userID))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDeleteCart.t.Errorf("CartRepositoryMock.DeleteCart got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmDeleteCart.DeleteCartMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDeleteCart.DeleteCartMock.defaultExpectation.results
		if mm_results == nil {
			mmDeleteCart.t.Fatal("No results are set for the CartRepositoryMock.DeleteCart")
		}
		return (*mm_results).err
	}
	if mmDeleteCart.funcDeleteCart != nil {
		return mmDeleteCart.funcDeleteCart(ctx, userID)
	}
	mmDeleteCart.t.Fatalf("Unexpected call to CartRepositoryMock.DeleteCart. %v %v", ctx, userID)
	return
}

// DeleteCartAfterCounter returns a count of finished CartRepositoryMock.DeleteCart invocations
func (mmDeleteCart *CartRepositoryMock) DeleteCartAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteCart.afterDeleteCartCounter)
}

// DeleteCartBeforeCounter returns a count of CartRepositoryMock.DeleteCart invocations
func (mmDeleteCart *CartRepositoryMock) DeleteCartBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteCart.beforeDeleteCartCounter)
}

// Calls returns a list of arguments used in each call to CartRepositoryMock.DeleteCart.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDeleteCart *mCartRepositoryMockDeleteCart) Calls() []*CartRepositoryMockDeleteCartParams {
	mmDeleteCart.mutex.RLock()

	argCopy := make([]*CartRepositoryMockDeleteCartParams, len(mmDeleteCart.callArgs))
	copy(argCopy, mmDeleteCart.callArgs)

	mmDeleteCart.mutex.RUnlock()

	return argCopy
}

// MinimockDeleteCartDone returns true if the count of the DeleteCart invocations corresponds
// the number of defined expectations
func (m *CartRepositoryMock) MinimockDeleteCartDone() bool {
	if m.DeleteCartMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.DeleteCartMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.DeleteCartMock.invocationsDone()
}

// MinimockDeleteCartInspect logs each unmet expectation
func (m *CartRepositoryMock) MinimockDeleteCartInspect() {
	for _, e := range m.DeleteCartMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to CartRepositoryMock.DeleteCart at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterDeleteCartCounter := mm_atomic.LoadUint64(&m.afterDeleteCartCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteCartMock.defaultExpectation != nil && afterDeleteCartCounter < 1 {
		if m.DeleteCartMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to CartRepositoryMock.DeleteCart at\n%s", m.DeleteCartMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to CartRepositoryMock.DeleteCart at\n%s with params: %#v", m.DeleteCartMock.defaultExpectation.expectationOrigins.origin, *m.DeleteCartMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeleteCart != nil && afterDeleteCartCounter < 1 {
		m.t.Errorf("Expected call to CartRepositoryMock.DeleteCart at\n%s", m.funcDeleteCartOrigin)
	}

	if !m.DeleteCartMock.invocationsDone() && afterDeleteCartCounter > 0 {
		m.t.Errorf("Expected %d calls to CartRepositoryMock.DeleteCart at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.DeleteCartMock.expectedInvocations), m.DeleteCartMock.expectedInvocationsOrigin, afterDeleteCartCounter)
	}
}

type mCartRepositoryMockDeleteCartItem struct {
	optional           bool
	mock               *CartRepositoryMock
	defaultExpectation *CartRepositoryMockDeleteCartItemExpectation
	expectations       []*CartRepositoryMockDeleteCartItemExpectation

	callArgs []*CartRepositoryMockDeleteCartItemParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// CartRepositoryMockDeleteCartItemExpectation specifies expectation struct of the CartRepository.DeleteCartItem
type CartRepositoryMockDeleteCartItemExpectation struct {
	mock               *CartRepositoryMock
	params             *CartRepositoryMockDeleteCartItemParams
	paramPtrs          *CartRepositoryMockDeleteCartItemParamPtrs
	expectationOrigins CartRepositoryMockDeleteCartItemExpectationOrigins
	results            *CartRepositoryMockDeleteCartItemResults
	returnOrigin       string
	Counter            uint64
}

// CartRepositoryMockDeleteCartItemParams contains parameters of the CartRepository.DeleteCartItem
type CartRepositoryMockDeleteCartItemParams struct {
	ctx    context.Context
	userID int64
	skuID  int64
}

// CartRepositoryMockDeleteCartItemParamPtrs contains pointers to parameters of the CartRepository.DeleteCartItem
type CartRepositoryMockDeleteCartItemParamPtrs struct {
	ctx    *context.Context
	userID *int64
	skuID  *int64
}

// CartRepositoryMockDeleteCartItemResults contains results of the CartRepository.DeleteCartItem
type CartRepositoryMockDeleteCartItemResults struct {
	err error
}

// CartRepositoryMockDeleteCartItemOrigins contains origins of expectations of the CartRepository.DeleteCartItem
type CartRepositoryMockDeleteCartItemExpectationOrigins struct {
	origin       string
	originCtx    string
	originUserID string
	originSkuID  string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmDeleteCartItem *mCartRepositoryMockDeleteCartItem) Optional() *mCartRepositoryMockDeleteCartItem {
	mmDeleteCartItem.optional = true
	return mmDeleteCartItem
}

// Expect sets up expected params for CartRepository.DeleteCartItem
func (mmDeleteCartItem *mCartRepositoryMockDeleteCartItem) Expect(ctx context.Context, userID int64, skuID int64) *mCartRepositoryMockDeleteCartItem {
	if mmDeleteCartItem.mock.funcDeleteCartItem != nil {
		mmDeleteCartItem.mock.t.Fatalf("CartRepositoryMock.DeleteCartItem mock is already set by Set")
	}

	if mmDeleteCartItem.defaultExpectation == nil {
		mmDeleteCartItem.defaultExpectation = &CartRepositoryMockDeleteCartItemExpectation{}
	}

	if mmDeleteCartItem.defaultExpectation.paramPtrs != nil {
		mmDeleteCartItem.mock.t.Fatalf("CartRepositoryMock.DeleteCartItem mock is already set by ExpectParams functions")
	}

	mmDeleteCartItem.defaultExpectation.params = &CartRepositoryMockDeleteCartItemParams{ctx, userID, skuID}
	mmDeleteCartItem.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmDeleteCartItem.expectations {
		if minimock.Equal(e.params, mmDeleteCartItem.defaultExpectation.params) {
			mmDeleteCartItem.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDeleteCartItem.defaultExpectation.params)
		}
	}

	return mmDeleteCartItem
}

// ExpectCtxParam1 sets up expected param ctx for CartRepository.DeleteCartItem
func (mmDeleteCartItem *mCartRepositoryMockDeleteCartItem) ExpectCtxParam1(ctx context.Context) *mCartRepositoryMockDeleteCartItem {
	if mmDeleteCartItem.mock.funcDeleteCartItem != nil {
		mmDeleteCartItem.mock.t.Fatalf("CartRepositoryMock.DeleteCartItem mock is already set by Set")
	}

	if mmDeleteCartItem.defaultExpectation == nil {
		mmDeleteCartItem.defaultExpectation = &CartRepositoryMockDeleteCartItemExpectation{}
	}

	if mmDeleteCartItem.defaultExpectation.params != nil {
		mmDeleteCartItem.mock.t.Fatalf("CartRepositoryMock.DeleteCartItem mock is already set by Expect")
	}

	if mmDeleteCartItem.defaultExpectation.paramPtrs == nil {
		mmDeleteCartItem.defaultExpectation.paramPtrs = &CartRepositoryMockDeleteCartItemParamPtrs{}
	}
	mmDeleteCartItem.defaultExpectation.paramPtrs.ctx = &ctx
	mmDeleteCartItem.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmDeleteCartItem
}

// ExpectUserIDParam2 sets up expected param userID for CartRepository.DeleteCartItem
func (mmDeleteCartItem *mCartRepositoryMockDeleteCartItem) ExpectUserIDParam2(userID int64) *mCartRepositoryMockDeleteCartItem {
	if mmDeleteCartItem.mock.funcDeleteCartItem != nil {
		mmDeleteCartItem.mock.t.Fatalf("CartRepositoryMock.DeleteCartItem mock is already set by Set")
	}

	if mmDeleteCartItem.defaultExpectation == nil {
		mmDeleteCartItem.defaultExpectation = &CartRepositoryMockDeleteCartItemExpectation{}
	}

	if mmDeleteCartItem.defaultExpectation.params != nil {
		mmDeleteCartItem.mock.t.Fatalf("CartRepositoryMock.DeleteCartItem mock is already set by Expect")
	}

	if mmDeleteCartItem.defaultExpectation.paramPtrs == nil {
		mmDeleteCartItem.defaultExpectation.paramPtrs = &CartRepositoryMockDeleteCartItemParamPtrs{}
	}
	mmDeleteCartItem.defaultExpectation.paramPtrs.userID = &userID
	mmDeleteCartItem.defaultExpectation.expectationOrigins.originUserID = minimock.CallerInfo(1)

	return mmDeleteCartItem
}

// ExpectSkuIDParam3 sets up expected param skuID for CartRepository.DeleteCartItem
func (mmDeleteCartItem *mCartRepositoryMockDeleteCartItem) ExpectSkuIDParam3(skuID int64) *mCartRepositoryMockDeleteCartItem {
	if mmDeleteCartItem.mock.funcDeleteCartItem != nil {
		mmDeleteCartItem.mock.t.Fatalf("CartRepositoryMock.DeleteCartItem mock is already set by Set")
	}

	if mmDeleteCartItem.defaultExpectation == nil {
		mmDeleteCartItem.defaultExpectation = &CartRepositoryMockDeleteCartItemExpectation{}
	}

	if mmDeleteCartItem.defaultExpectation.params != nil {
		mmDeleteCartItem.mock.t.Fatalf("CartRepositoryMock.DeleteCartItem mock is already set by Expect")
	}

	if mmDeleteCartItem.defaultExpectation.paramPtrs == nil {
		mmDeleteCartItem.defaultExpectation.paramPtrs = &CartRepositoryMockDeleteCartItemParamPtrs{}
	}
	mmDeleteCartItem.defaultExpectation.paramPtrs.skuID = &skuID
	mmDeleteCartItem.defaultExpectation.expectationOrigins.originSkuID = minimock.CallerInfo(1)

	return mmDeleteCartItem
}

// Inspect accepts an inspector function that has same arguments as the CartRepository.DeleteCartItem
func (mmDeleteCartItem *mCartRepositoryMockDeleteCartItem) Inspect(f func(ctx context.Context, userID int64, skuID int64)) *mCartRepositoryMockDeleteCartItem {
	if mmDeleteCartItem.mock.inspectFuncDeleteCartItem != nil {
		mmDeleteCartItem.mock.t.Fatalf("Inspect function is already set for CartRepositoryMock.DeleteCartItem")
	}

	mmDeleteCartItem.mock.inspectFuncDeleteCartItem = f

	return mmDeleteCartItem
}

// Return sets up results that will be returned by CartRepository.DeleteCartItem
func (mmDeleteCartItem *mCartRepositoryMockDeleteCartItem) Return(err error) *CartRepositoryMock {
	if mmDeleteCartItem.mock.funcDeleteCartItem != nil {
		mmDeleteCartItem.mock.t.Fatalf("CartRepositoryMock.DeleteCartItem mock is already set by Set")
	}

	if mmDeleteCartItem.defaultExpectation == nil {
		mmDeleteCartItem.defaultExpectation = &CartRepositoryMockDeleteCartItemExpectation{mock: mmDeleteCartItem.mock}
	}
	mmDeleteCartItem.defaultExpectation.results = &CartRepositoryMockDeleteCartItemResults{err}
	mmDeleteCartItem.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmDeleteCartItem.mock
}

// Set uses given function f to mock the CartRepository.DeleteCartItem method
func (mmDeleteCartItem *mCartRepositoryMockDeleteCartItem) Set(f func(ctx context.Context, userID int64, skuID int64) (err error)) *CartRepositoryMock {
	if mmDeleteCartItem.defaultExpectation != nil {
		mmDeleteCartItem.mock.t.Fatalf("Default expectation is already set for the CartRepository.DeleteCartItem method")
	}

	if len(mmDeleteCartItem.expectations) > 0 {
		mmDeleteCartItem.mock.t.Fatalf("Some expectations are already set for the CartRepository.DeleteCartItem method")
	}

	mmDeleteCartItem.mock.funcDeleteCartItem = f
	mmDeleteCartItem.mock.funcDeleteCartItemOrigin = minimock.CallerInfo(1)
	return mmDeleteCartItem.mock
}

// When sets expectation for the CartRepository.DeleteCartItem which will trigger the result defined by the following
// Then helper
func (mmDeleteCartItem *mCartRepositoryMockDeleteCartItem) When(ctx context.Context, userID int64, skuID int64) *CartRepositoryMockDeleteCartItemExpectation {
	if mmDeleteCartItem.mock.funcDeleteCartItem != nil {
		mmDeleteCartItem.mock.t.Fatalf("CartRepositoryMock.DeleteCartItem mock is already set by Set")
	}

	expectation := &CartRepositoryMockDeleteCartItemExpectation{
		mock:               mmDeleteCartItem.mock,
		params:             &CartRepositoryMockDeleteCartItemParams{ctx, userID, skuID},
		expectationOrigins: CartRepositoryMockDeleteCartItemExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmDeleteCartItem.expectations = append(mmDeleteCartItem.expectations, expectation)
	return expectation
}

// Then sets up CartRepository.DeleteCartItem return parameters for the expectation previously defined by the When method
func (e *CartRepositoryMockDeleteCartItemExpectation) Then(err error) *CartRepositoryMock {
	e.results = &CartRepositoryMockDeleteCartItemResults{err}
	return e.mock
}

// Times sets number of times CartRepository.DeleteCartItem should be invoked
func (mmDeleteCartItem *mCartRepositoryMockDeleteCartItem) Times(n uint64) *mCartRepositoryMockDeleteCartItem {
	if n == 0 {
		mmDeleteCartItem.mock.t.Fatalf("Times of CartRepositoryMock.DeleteCartItem mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmDeleteCartItem.expectedInvocations, n)
	mmDeleteCartItem.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmDeleteCartItem
}

func (mmDeleteCartItem *mCartRepositoryMockDeleteCartItem) invocationsDone() bool {
	if len(mmDeleteCartItem.expectations) == 0 && mmDeleteCartItem.defaultExpectation == nil && mmDeleteCartItem.mock.funcDeleteCartItem == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmDeleteCartItem.mock.afterDeleteCartItemCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmDeleteCartItem.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// DeleteCartItem implements mm_service.CartRepository
func (mmDeleteCartItem *CartRepositoryMock) DeleteCartItem(ctx context.Context, userID int64, skuID int64) (err error) {
	mm_atomic.AddUint64(&mmDeleteCartItem.beforeDeleteCartItemCounter, 1)
	defer mm_atomic.AddUint64(&mmDeleteCartItem.afterDeleteCartItemCounter, 1)

	mmDeleteCartItem.t.Helper()

	if mmDeleteCartItem.inspectFuncDeleteCartItem != nil {
		mmDeleteCartItem.inspectFuncDeleteCartItem(ctx, userID, skuID)
	}

	mm_params := CartRepositoryMockDeleteCartItemParams{ctx, userID, skuID}

	// Record call args
	mmDeleteCartItem.DeleteCartItemMock.mutex.Lock()
	mmDeleteCartItem.DeleteCartItemMock.callArgs = append(mmDeleteCartItem.DeleteCartItemMock.callArgs, &mm_params)
	mmDeleteCartItem.DeleteCartItemMock.mutex.Unlock()

	for _, e := range mmDeleteCartItem.DeleteCartItemMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmDeleteCartItem.DeleteCartItemMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDeleteCartItem.DeleteCartItemMock.defaultExpectation.Counter, 1)
		mm_want := mmDeleteCartItem.DeleteCartItemMock.defaultExpectation.params
		mm_want_ptrs := mmDeleteCartItem.DeleteCartItemMock.defaultExpectation.paramPtrs

		mm_got := CartRepositoryMockDeleteCartItemParams{ctx, userID, skuID}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmDeleteCartItem.t.Errorf("CartRepositoryMock.DeleteCartItem got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteCartItem.DeleteCartItemMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.userID != nil && !minimock.Equal(*mm_want_ptrs.userID, mm_got.userID) {
				mmDeleteCartItem.t.Errorf("CartRepositoryMock.DeleteCartItem got unexpected parameter userID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteCartItem.DeleteCartItemMock.defaultExpectation.expectationOrigins.originUserID, *mm_want_ptrs.userID, mm_got.userID, minimock.Diff(*mm_want_ptrs.userID, mm_got.userID))
			}

			if mm_want_ptrs.skuID != nil && !minimock.Equal(*mm_want_ptrs.skuID, mm_got.skuID) {
				mmDeleteCartItem.t.Errorf("CartRepositoryMock.DeleteCartItem got unexpected parameter skuID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteCartItem.DeleteCartItemMock.defaultExpectation.expectationOrigins.originSkuID, *mm_want_ptrs.skuID, mm_got.skuID, minimock.Diff(*mm_want_ptrs.skuID, mm_got.skuID))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDeleteCartItem.t.Errorf("CartRepositoryMock.DeleteCartItem got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmDeleteCartItem.DeleteCartItemMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDeleteCartItem.DeleteCartItemMock.defaultExpectation.results
		if mm_results == nil {
			mmDeleteCartItem.t.Fatal("No results are set for the CartRepositoryMock.DeleteCartItem")
		}
		return (*mm_results).err
	}
	if mmDeleteCartItem.funcDeleteCartItem != nil {
		return mmDeleteCartItem.funcDeleteCartItem(ctx, userID, skuID)
	}
	mmDeleteCartItem.t.Fatalf("Unexpected call to CartRepositoryMock.DeleteCartItem. %v %v %v", ctx, userID, skuID)
	return
}

// DeleteCartItemAfterCounter returns a count of finished CartRepositoryMock.DeleteCartItem invocations
func (mmDeleteCartItem *CartRepositoryMock) DeleteCartItemAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteCartItem.afterDeleteCartItemCounter)
}

// DeleteCartItemBeforeCounter returns a count of CartRepositoryMock.DeleteCartItem invocations
func (mmDeleteCartItem *CartRepositoryMock) DeleteCartItemBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteCartItem.beforeDeleteCartItemCounter)
}

// Calls returns a list of arguments used in each call to CartRepositoryMock.DeleteCartItem.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDeleteCartItem *mCartRepositoryMockDeleteCartItem) Calls() []*CartRepositoryMockDeleteCartItemParams {
	mmDeleteCartItem.mutex.RLock()

	argCopy := make([]*CartRepositoryMockDeleteCartItemParams, len(mmDeleteCartItem.callArgs))
	copy(argCopy, mmDeleteCartItem.callArgs)

	mmDeleteCartItem.mutex.RUnlock()

	return argCopy
}

// MinimockDeleteCartItemDone returns true if the count of the DeleteCartItem invocations corresponds
// the number of defined expectations
func (m *CartRepositoryMock) MinimockDeleteCartItemDone() bool {
	if m.DeleteCartItemMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.DeleteCartItemMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.DeleteCartItemMock.invocationsDone()
}

// MinimockDeleteCartItemInspect logs each unmet expectation
func (m *CartRepositoryMock) MinimockDeleteCartItemInspect() {
	for _, e := range m.DeleteCartItemMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to CartRepositoryMock.DeleteCartItem at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterDeleteCartItemCounter := mm_atomic.LoadUint64(&m.afterDeleteCartItemCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteCartItemMock.defaultExpectation != nil && afterDeleteCartItemCounter < 1 {
		if m.DeleteCartItemMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to CartRepositoryMock.DeleteCartItem at\n%s", m.DeleteCartItemMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to CartRepositoryMock.DeleteCartItem at\n%s with params: %#v", m.DeleteCartItemMock.defaultExpectation.expectationOrigins.origin, *m.DeleteCartItemMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeleteCartItem != nil && afterDeleteCartItemCounter < 1 {
		m.t.Errorf("Expected call to CartRepositoryMock.DeleteCartItem at\n%s", m.funcDeleteCartItemOrigin)
	}

	if !m.DeleteCartItemMock.invocationsDone() && afterDeleteCartItemCounter > 0 {
		m.t.Errorf("Expected %d calls to CartRepositoryMock.DeleteCartItem at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.DeleteCartItemMock.expectedInvocations), m.DeleteCartItemMock.expectedInvocationsOrigin, afterDeleteCartItemCounter)
	}
}

type mCartRepositoryMockGetCartByUserIDOrderBySku struct {
	optional           bool
	mock               *CartRepositoryMock
	defaultExpectation *CartRepositoryMockGetCartByUserIDOrderBySkuExpectation
	expectations       []*CartRepositoryMockGetCartByUserIDOrderBySkuExpectation

	callArgs []*CartRepositoryMockGetCartByUserIDOrderBySkuParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// CartRepositoryMockGetCartByUserIDOrderBySkuExpectation specifies expectation struct of the CartRepository.GetCartByUserIDOrderBySku
type CartRepositoryMockGetCartByUserIDOrderBySkuExpectation struct {
	mock               *CartRepositoryMock
	params             *CartRepositoryMockGetCartByUserIDOrderBySkuParams
	paramPtrs          *CartRepositoryMockGetCartByUserIDOrderBySkuParamPtrs
	expectationOrigins CartRepositoryMockGetCartByUserIDOrderBySkuExpectationOrigins
	results            *CartRepositoryMockGetCartByUserIDOrderBySkuResults
	returnOrigin       string
	Counter            uint64
}

// CartRepositoryMockGetCartByUserIDOrderBySkuParams contains parameters of the CartRepository.GetCartByUserIDOrderBySku
type CartRepositoryMockGetCartByUserIDOrderBySkuParams struct {
	ctx    context.Context
	userID int64
}

// CartRepositoryMockGetCartByUserIDOrderBySkuParamPtrs contains pointers to parameters of the CartRepository.GetCartByUserIDOrderBySku
type CartRepositoryMockGetCartByUserIDOrderBySkuParamPtrs struct {
	ctx    *context.Context
	userID *int64
}

// CartRepositoryMockGetCartByUserIDOrderBySkuResults contains results of the CartRepository.GetCartByUserIDOrderBySku
type CartRepositoryMockGetCartByUserIDOrderBySkuResults struct {
	cp1 *domain.Cart
	err error
}

// CartRepositoryMockGetCartByUserIDOrderBySkuOrigins contains origins of expectations of the CartRepository.GetCartByUserIDOrderBySku
type CartRepositoryMockGetCartByUserIDOrderBySkuExpectationOrigins struct {
	origin       string
	originCtx    string
	originUserID string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetCartByUserIDOrderBySku *mCartRepositoryMockGetCartByUserIDOrderBySku) Optional() *mCartRepositoryMockGetCartByUserIDOrderBySku {
	mmGetCartByUserIDOrderBySku.optional = true
	return mmGetCartByUserIDOrderBySku
}

// Expect sets up expected params for CartRepository.GetCartByUserIDOrderBySku
func (mmGetCartByUserIDOrderBySku *mCartRepositoryMockGetCartByUserIDOrderBySku) Expect(ctx context.Context, userID int64) *mCartRepositoryMockGetCartByUserIDOrderBySku {
	if mmGetCartByUserIDOrderBySku.mock.funcGetCartByUserIDOrderBySku != nil {
		mmGetCartByUserIDOrderBySku.mock.t.Fatalf("CartRepositoryMock.GetCartByUserIDOrderBySku mock is already set by Set")
	}

	if mmGetCartByUserIDOrderBySku.defaultExpectation == nil {
		mmGetCartByUserIDOrderBySku.defaultExpectation = &CartRepositoryMockGetCartByUserIDOrderBySkuExpectation{}
	}

	if mmGetCartByUserIDOrderBySku.defaultExpectation.paramPtrs != nil {
		mmGetCartByUserIDOrderBySku.mock.t.Fatalf("CartRepositoryMock.GetCartByUserIDOrderBySku mock is already set by ExpectParams functions")
	}

	mmGetCartByUserIDOrderBySku.defaultExpectation.params = &CartRepositoryMockGetCartByUserIDOrderBySkuParams{ctx, userID}
	mmGetCartByUserIDOrderBySku.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetCartByUserIDOrderBySku.expectations {
		if minimock.Equal(e.params, mmGetCartByUserIDOrderBySku.defaultExpectation.params) {
			mmGetCartByUserIDOrderBySku.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetCartByUserIDOrderBySku.defaultExpectation.params)
		}
	}

	return mmGetCartByUserIDOrderBySku
}

// ExpectCtxParam1 sets up expected param ctx for CartRepository.GetCartByUserIDOrderBySku
func (mmGetCartByUserIDOrderBySku *mCartRepositoryMockGetCartByUserIDOrderBySku) ExpectCtxParam1(ctx context.Context) *mCartRepositoryMockGetCartByUserIDOrderBySku {
	if mmGetCartByUserIDOrderBySku.mock.funcGetCartByUserIDOrderBySku != nil {
		mmGetCartByUserIDOrderBySku.mock.t.Fatalf("CartRepositoryMock.GetCartByUserIDOrderBySku mock is already set by Set")
	}

	if mmGetCartByUserIDOrderBySku.defaultExpectation == nil {
		mmGetCartByUserIDOrderBySku.defaultExpectation = &CartRepositoryMockGetCartByUserIDOrderBySkuExpectation{}
	}

	if mmGetCartByUserIDOrderBySku.defaultExpectation.params != nil {
		mmGetCartByUserIDOrderBySku.mock.t.Fatalf("CartRepositoryMock.GetCartByUserIDOrderBySku mock is already set by Expect")
	}

	if mmGetCartByUserIDOrderBySku.defaultExpectation.paramPtrs == nil {
		mmGetCartByUserIDOrderBySku.defaultExpectation.paramPtrs = &CartRepositoryMockGetCartByUserIDOrderBySkuParamPtrs{}
	}
	mmGetCartByUserIDOrderBySku.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetCartByUserIDOrderBySku.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetCartByUserIDOrderBySku
}

// ExpectUserIDParam2 sets up expected param userID for CartRepository.GetCartByUserIDOrderBySku
func (mmGetCartByUserIDOrderBySku *mCartRepositoryMockGetCartByUserIDOrderBySku) ExpectUserIDParam2(userID int64) *mCartRepositoryMockGetCartByUserIDOrderBySku {
	if mmGetCartByUserIDOrderBySku.mock.funcGetCartByUserIDOrderBySku != nil {
		mmGetCartByUserIDOrderBySku.mock.t.Fatalf("CartRepositoryMock.GetCartByUserIDOrderBySku mock is already set by Set")
	}

	if mmGetCartByUserIDOrderBySku.defaultExpectation == nil {
		mmGetCartByUserIDOrderBySku.defaultExpectation = &CartRepositoryMockGetCartByUserIDOrderBySkuExpectation{}
	}

	if mmGetCartByUserIDOrderBySku.defaultExpectation.params != nil {
		mmGetCartByUserIDOrderBySku.mock.t.Fatalf("CartRepositoryMock.GetCartByUserIDOrderBySku mock is already set by Expect")
	}

	if mmGetCartByUserIDOrderBySku.defaultExpectation.paramPtrs == nil {
		mmGetCartByUserIDOrderBySku.defaultExpectation.paramPtrs = &CartRepositoryMockGetCartByUserIDOrderBySkuParamPtrs{}
	}
	mmGetCartByUserIDOrderBySku.defaultExpectation.paramPtrs.userID = &userID
	mmGetCartByUserIDOrderBySku.defaultExpectation.expectationOrigins.originUserID = minimock.CallerInfo(1)

	return mmGetCartByUserIDOrderBySku
}

// Inspect accepts an inspector function that has same arguments as the CartRepository.GetCartByUserIDOrderBySku
func (mmGetCartByUserIDOrderBySku *mCartRepositoryMockGetCartByUserIDOrderBySku) Inspect(f func(ctx context.Context, userID int64)) *mCartRepositoryMockGetCartByUserIDOrderBySku {
	if mmGetCartByUserIDOrderBySku.mock.inspectFuncGetCartByUserIDOrderBySku != nil {
		mmGetCartByUserIDOrderBySku.mock.t.Fatalf("Inspect function is already set for CartRepositoryMock.GetCartByUserIDOrderBySku")
	}

	mmGetCartByUserIDOrderBySku.mock.inspectFuncGetCartByUserIDOrderBySku = f

	return mmGetCartByUserIDOrderBySku
}

// Return sets up results that will be returned by CartRepository.GetCartByUserIDOrderBySku
func (mmGetCartByUserIDOrderBySku *mCartRepositoryMockGetCartByUserIDOrderBySku) Return(cp1 *domain.Cart, err error) *CartRepositoryMock {
	if mmGetCartByUserIDOrderBySku.mock.funcGetCartByUserIDOrderBySku != nil {
		mmGetCartByUserIDOrderBySku.mock.t.Fatalf("CartRepositoryMock.GetCartByUserIDOrderBySku mock is already set by Set")
	}

	if mmGetCartByUserIDOrderBySku.defaultExpectation == nil {
		mmGetCartByUserIDOrderBySku.defaultExpectation = &CartRepositoryMockGetCartByUserIDOrderBySkuExpectation{mock: mmGetCartByUserIDOrderBySku.mock}
	}
	mmGetCartByUserIDOrderBySku.defaultExpectation.results = &CartRepositoryMockGetCartByUserIDOrderBySkuResults{cp1, err}
	mmGetCartByUserIDOrderBySku.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetCartByUserIDOrderBySku.mock
}

// Set uses given function f to mock the CartRepository.GetCartByUserIDOrderBySku method
func (mmGetCartByUserIDOrderBySku *mCartRepositoryMockGetCartByUserIDOrderBySku) Set(f func(ctx context.Context, userID int64) (cp1 *domain.Cart, err error)) *CartRepositoryMock {
	if mmGetCartByUserIDOrderBySku.defaultExpectation != nil {
		mmGetCartByUserIDOrderBySku.mock.t.Fatalf("Default expectation is already set for the CartRepository.GetCartByUserIDOrderBySku method")
	}

	if len(mmGetCartByUserIDOrderBySku.expectations) > 0 {
		mmGetCartByUserIDOrderBySku.mock.t.Fatalf("Some expectations are already set for the CartRepository.GetCartByUserIDOrderBySku method")
	}

	mmGetCartByUserIDOrderBySku.mock.funcGetCartByUserIDOrderBySku = f
	mmGetCartByUserIDOrderBySku.mock.funcGetCartByUserIDOrderBySkuOrigin = minimock.CallerInfo(1)
	return mmGetCartByUserIDOrderBySku.mock
}

// When sets expectation for the CartRepository.GetCartByUserIDOrderBySku which will trigger the result defined by the following
// Then helper
func (mmGetCartByUserIDOrderBySku *mCartRepositoryMockGetCartByUserIDOrderBySku) When(ctx context.Context, userID int64) *CartRepositoryMockGetCartByUserIDOrderBySkuExpectation {
	if mmGetCartByUserIDOrderBySku.mock.funcGetCartByUserIDOrderBySku != nil {
		mmGetCartByUserIDOrderBySku.mock.t.Fatalf("CartRepositoryMock.GetCartByUserIDOrderBySku mock is already set by Set")
	}

	expectation := &CartRepositoryMockGetCartByUserIDOrderBySkuExpectation{
		mock:               mmGetCartByUserIDOrderBySku.mock,
		params:             &CartRepositoryMockGetCartByUserIDOrderBySkuParams{ctx, userID},
		expectationOrigins: CartRepositoryMockGetCartByUserIDOrderBySkuExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetCartByUserIDOrderBySku.expectations = append(mmGetCartByUserIDOrderBySku.expectations, expectation)
	return expectation
}

// Then sets up CartRepository.GetCartByUserIDOrderBySku return parameters for the expectation previously defined by the When method
func (e *CartRepositoryMockGetCartByUserIDOrderBySkuExpectation) Then(cp1 *domain.Cart, err error) *CartRepositoryMock {
	e.results = &CartRepositoryMockGetCartByUserIDOrderBySkuResults{cp1, err}
	return e.mock
}

// Times sets number of times CartRepository.GetCartByUserIDOrderBySku should be invoked
func (mmGetCartByUserIDOrderBySku *mCartRepositoryMockGetCartByUserIDOrderBySku) Times(n uint64) *mCartRepositoryMockGetCartByUserIDOrderBySku {
	if n == 0 {
		mmGetCartByUserIDOrderBySku.mock.t.Fatalf("Times of CartRepositoryMock.GetCartByUserIDOrderBySku mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetCartByUserIDOrderBySku.expectedInvocations, n)
	mmGetCartByUserIDOrderBySku.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetCartByUserIDOrderBySku
}

func (mmGetCartByUserIDOrderBySku *mCartRepositoryMockGetCartByUserIDOrderBySku) invocationsDone() bool {
	if len(mmGetCartByUserIDOrderBySku.expectations) == 0 && mmGetCartByUserIDOrderBySku.defaultExpectation == nil && mmGetCartByUserIDOrderBySku.mock.funcGetCartByUserIDOrderBySku == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetCartByUserIDOrderBySku.mock.afterGetCartByUserIDOrderBySkuCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetCartByUserIDOrderBySku.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetCartByUserIDOrderBySku implements mm_service.CartRepository
func (mmGetCartByUserIDOrderBySku *CartRepositoryMock) GetCartByUserIDOrderBySku(ctx context.Context, userID int64) (cp1 *domain.Cart, err error) {
	mm_atomic.AddUint64(&mmGetCartByUserIDOrderBySku.beforeGetCartByUserIDOrderBySkuCounter, 1)
	defer mm_atomic.AddUint64(&mmGetCartByUserIDOrderBySku.afterGetCartByUserIDOrderBySkuCounter, 1)

	mmGetCartByUserIDOrderBySku.t.Helper()

	if mmGetCartByUserIDOrderBySku.inspectFuncGetCartByUserIDOrderBySku != nil {
		mmGetCartByUserIDOrderBySku.inspectFuncGetCartByUserIDOrderBySku(ctx, userID)
	}

	mm_params := CartRepositoryMockGetCartByUserIDOrderBySkuParams{ctx, userID}

	// Record call args
	mmGetCartByUserIDOrderBySku.GetCartByUserIDOrderBySkuMock.mutex.Lock()
	mmGetCartByUserIDOrderBySku.GetCartByUserIDOrderBySkuMock.callArgs = append(mmGetCartByUserIDOrderBySku.GetCartByUserIDOrderBySkuMock.callArgs, &mm_params)
	mmGetCartByUserIDOrderBySku.GetCartByUserIDOrderBySkuMock.mutex.Unlock()

	for _, e := range mmGetCartByUserIDOrderBySku.GetCartByUserIDOrderBySkuMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.cp1, e.results.err
		}
	}

	if mmGetCartByUserIDOrderBySku.GetCartByUserIDOrderBySkuMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetCartByUserIDOrderBySku.GetCartByUserIDOrderBySkuMock.defaultExpectation.Counter, 1)
		mm_want := mmGetCartByUserIDOrderBySku.GetCartByUserIDOrderBySkuMock.defaultExpectation.params
		mm_want_ptrs := mmGetCartByUserIDOrderBySku.GetCartByUserIDOrderBySkuMock.defaultExpectation.paramPtrs

		mm_got := CartRepositoryMockGetCartByUserIDOrderBySkuParams{ctx, userID}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetCartByUserIDOrderBySku.t.Errorf("CartRepositoryMock.GetCartByUserIDOrderBySku got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetCartByUserIDOrderBySku.GetCartByUserIDOrderBySkuMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.userID != nil && !minimock.Equal(*mm_want_ptrs.userID, mm_got.userID) {
				mmGetCartByUserIDOrderBySku.t.Errorf("CartRepositoryMock.GetCartByUserIDOrderBySku got unexpected parameter userID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetCartByUserIDOrderBySku.GetCartByUserIDOrderBySkuMock.defaultExpectation.expectationOrigins.originUserID, *mm_want_ptrs.userID, mm_got.userID, minimock.Diff(*mm_want_ptrs.userID, mm_got.userID))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetCartByUserIDOrderBySku.t.Errorf("CartRepositoryMock.GetCartByUserIDOrderBySku got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetCartByUserIDOrderBySku.GetCartByUserIDOrderBySkuMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetCartByUserIDOrderBySku.GetCartByUserIDOrderBySkuMock.defaultExpectation.results
		if mm_results == nil {
			mmGetCartByUserIDOrderBySku.t.Fatal("No results are set for the CartRepositoryMock.GetCartByUserIDOrderBySku")
		}
		return (*mm_results).cp1, (*mm_results).err
	}
	if mmGetCartByUserIDOrderBySku.funcGetCartByUserIDOrderBySku != nil {
		return mmGetCartByUserIDOrderBySku.funcGetCartByUserIDOrderBySku(ctx, userID)
	}
	mmGetCartByUserIDOrderBySku.t.Fatalf("Unexpected call to CartRepositoryMock.GetCartByUserIDOrderBySku. %v %v", ctx, userID)
	return
}

// GetCartByUserIDOrderBySkuAfterCounter returns a count of finished CartRepositoryMock.GetCartByUserIDOrderBySku invocations
func (mmGetCartByUserIDOrderBySku *CartRepositoryMock) GetCartByUserIDOrderBySkuAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetCartByUserIDOrderBySku.afterGetCartByUserIDOrderBySkuCounter)
}

// GetCartByUserIDOrderBySkuBeforeCounter returns a count of CartRepositoryMock.GetCartByUserIDOrderBySku invocations
func (mmGetCartByUserIDOrderBySku *CartRepositoryMock) GetCartByUserIDOrderBySkuBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetCartByUserIDOrderBySku.beforeGetCartByUserIDOrderBySkuCounter)
}

// Calls returns a list of arguments used in each call to CartRepositoryMock.GetCartByUserIDOrderBySku.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetCartByUserIDOrderBySku *mCartRepositoryMockGetCartByUserIDOrderBySku) Calls() []*CartRepositoryMockGetCartByUserIDOrderBySkuParams {
	mmGetCartByUserIDOrderBySku.mutex.RLock()

	argCopy := make([]*CartRepositoryMockGetCartByUserIDOrderBySkuParams, len(mmGetCartByUserIDOrderBySku.callArgs))
	copy(argCopy, mmGetCartByUserIDOrderBySku.callArgs)

	mmGetCartByUserIDOrderBySku.mutex.RUnlock()

	return argCopy
}

// MinimockGetCartByUserIDOrderBySkuDone returns true if the count of the GetCartByUserIDOrderBySku invocations corresponds
// the number of defined expectations
func (m *CartRepositoryMock) MinimockGetCartByUserIDOrderBySkuDone() bool {
	if m.GetCartByUserIDOrderBySkuMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetCartByUserIDOrderBySkuMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetCartByUserIDOrderBySkuMock.invocationsDone()
}

// MinimockGetCartByUserIDOrderBySkuInspect logs each unmet expectation
func (m *CartRepositoryMock) MinimockGetCartByUserIDOrderBySkuInspect() {
	for _, e := range m.GetCartByUserIDOrderBySkuMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to CartRepositoryMock.GetCartByUserIDOrderBySku at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetCartByUserIDOrderBySkuCounter := mm_atomic.LoadUint64(&m.afterGetCartByUserIDOrderBySkuCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetCartByUserIDOrderBySkuMock.defaultExpectation != nil && afterGetCartByUserIDOrderBySkuCounter < 1 {
		if m.GetCartByUserIDOrderBySkuMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to CartRepositoryMock.GetCartByUserIDOrderBySku at\n%s", m.GetCartByUserIDOrderBySkuMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to CartRepositoryMock.GetCartByUserIDOrderBySku at\n%s with params: %#v", m.GetCartByUserIDOrderBySkuMock.defaultExpectation.expectationOrigins.origin, *m.GetCartByUserIDOrderBySkuMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetCartByUserIDOrderBySku != nil && afterGetCartByUserIDOrderBySkuCounter < 1 {
		m.t.Errorf("Expected call to CartRepositoryMock.GetCartByUserIDOrderBySku at\n%s", m.funcGetCartByUserIDOrderBySkuOrigin)
	}

	if !m.GetCartByUserIDOrderBySkuMock.invocationsDone() && afterGetCartByUserIDOrderBySkuCounter > 0 {
		m.t.Errorf("Expected %d calls to CartRepositoryMock.GetCartByUserIDOrderBySku at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetCartByUserIDOrderBySkuMock.expectedInvocations), m.GetCartByUserIDOrderBySkuMock.expectedInvocationsOrigin, afterGetCartByUserIDOrderBySkuCounter)
	}
}

type mCartRepositoryMockUpsertCartItem struct {
	optional           bool
	mock               *CartRepositoryMock
	defaultExpectation *CartRepositoryMockUpsertCartItemExpectation
	expectations       []*CartRepositoryMockUpsertCartItemExpectation

	callArgs []*CartRepositoryMockUpsertCartItemParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// CartRepositoryMockUpsertCartItemExpectation specifies expectation struct of the CartRepository.UpsertCartItem
type CartRepositoryMockUpsertCartItemExpectation struct {
	mock               *CartRepositoryMock
	params             *CartRepositoryMockUpsertCartItemParams
	paramPtrs          *CartRepositoryMockUpsertCartItemParamPtrs
	expectationOrigins CartRepositoryMockUpsertCartItemExpectationOrigins
	results            *CartRepositoryMockUpsertCartItemResults
	returnOrigin       string
	Counter            uint64
}

// CartRepositoryMockUpsertCartItemParams contains parameters of the CartRepository.UpsertCartItem
type CartRepositoryMockUpsertCartItemParams struct {
	ctx     context.Context
	userID  int64
	newItem *domain.CartItem
}

// CartRepositoryMockUpsertCartItemParamPtrs contains pointers to parameters of the CartRepository.UpsertCartItem
type CartRepositoryMockUpsertCartItemParamPtrs struct {
	ctx     *context.Context
	userID  *int64
	newItem **domain.CartItem
}

// CartRepositoryMockUpsertCartItemResults contains results of the CartRepository.UpsertCartItem
type CartRepositoryMockUpsertCartItemResults struct {
	cp1 *domain.CartItem
	err error
}

// CartRepositoryMockUpsertCartItemOrigins contains origins of expectations of the CartRepository.UpsertCartItem
type CartRepositoryMockUpsertCartItemExpectationOrigins struct {
	origin        string
	originCtx     string
	originUserID  string
	originNewItem string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmUpsertCartItem *mCartRepositoryMockUpsertCartItem) Optional() *mCartRepositoryMockUpsertCartItem {
	mmUpsertCartItem.optional = true
	return mmUpsertCartItem
}

// Expect sets up expected params for CartRepository.UpsertCartItem
func (mmUpsertCartItem *mCartRepositoryMockUpsertCartItem) Expect(ctx context.Context, userID int64, newItem *domain.CartItem) *mCartRepositoryMockUpsertCartItem {
	if mmUpsertCartItem.mock.funcUpsertCartItem != nil {
		mmUpsertCartItem.mock.t.Fatalf("CartRepositoryMock.UpsertCartItem mock is already set by Set")
	}

	if mmUpsertCartItem.defaultExpectation == nil {
		mmUpsertCartItem.defaultExpectation = &CartRepositoryMockUpsertCartItemExpectation{}
	}

	if mmUpsertCartItem.defaultExpectation.paramPtrs != nil {
		mmUpsertCartItem.mock.t.Fatalf("CartRepositoryMock.UpsertCartItem mock is already set by ExpectParams functions")
	}

	mmUpsertCartItem.defaultExpectation.params = &CartRepositoryMockUpsertCartItemParams{ctx, userID, newItem}
	mmUpsertCartItem.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmUpsertCartItem.expectations {
		if minimock.Equal(e.params, mmUpsertCartItem.defaultExpectation.params) {
			mmUpsertCartItem.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmUpsertCartItem.defaultExpectation.params)
		}
	}

	return mmUpsertCartItem
}

// ExpectCtxParam1 sets up expected param ctx for CartRepository.UpsertCartItem
func (mmUpsertCartItem *mCartRepositoryMockUpsertCartItem) ExpectCtxParam1(ctx context.Context) *mCartRepositoryMockUpsertCartItem {
	if mmUpsertCartItem.mock.funcUpsertCartItem != nil {
		mmUpsertCartItem.mock.t.Fatalf("CartRepositoryMock.UpsertCartItem mock is already set by Set")
	}

	if mmUpsertCartItem.defaultExpectation == nil {
		mmUpsertCartItem.defaultExpectation = &CartRepositoryMockUpsertCartItemExpectation{}
	}

	if mmUpsertCartItem.defaultExpectation.params != nil {
		mmUpsertCartItem.mock.t.Fatalf("CartRepositoryMock.UpsertCartItem mock is already set by Expect")
	}

	if mmUpsertCartItem.defaultExpectation.paramPtrs == nil {
		mmUpsertCartItem.defaultExpectation.paramPtrs = &CartRepositoryMockUpsertCartItemParamPtrs{}
	}
	mmUpsertCartItem.defaultExpectation.paramPtrs.ctx = &ctx
	mmUpsertCartItem.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmUpsertCartItem
}

// ExpectUserIDParam2 sets up expected param userID for CartRepository.UpsertCartItem
func (mmUpsertCartItem *mCartRepositoryMockUpsertCartItem) ExpectUserIDParam2(userID int64) *mCartRepositoryMockUpsertCartItem {
	if mmUpsertCartItem.mock.funcUpsertCartItem != nil {
		mmUpsertCartItem.mock.t.Fatalf("CartRepositoryMock.UpsertCartItem mock is already set by Set")
	}

	if mmUpsertCartItem.defaultExpectation == nil {
		mmUpsertCartItem.defaultExpectation = &CartRepositoryMockUpsertCartItemExpectation{}
	}

	if mmUpsertCartItem.defaultExpectation.params != nil {
		mmUpsertCartItem.mock.t.Fatalf("CartRepositoryMock.UpsertCartItem mock is already set by Expect")
	}

	if mmUpsertCartItem.defaultExpectation.paramPtrs == nil {
		mmUpsertCartItem.defaultExpectation.paramPtrs = &CartRepositoryMockUpsertCartItemParamPtrs{}
	}
	mmUpsertCartItem.defaultExpectation.paramPtrs.userID = &userID
	mmUpsertCartItem.defaultExpectation.expectationOrigins.originUserID = minimock.CallerInfo(1)

	return mmUpsertCartItem
}

// ExpectNewItemParam3 sets up expected param newItem for CartRepository.UpsertCartItem
func (mmUpsertCartItem *mCartRepositoryMockUpsertCartItem) ExpectNewItemParam3(newItem *domain.CartItem) *mCartRepositoryMockUpsertCartItem {
	if mmUpsertCartItem.mock.funcUpsertCartItem != nil {
		mmUpsertCartItem.mock.t.Fatalf("CartRepositoryMock.UpsertCartItem mock is already set by Set")
	}

	if mmUpsertCartItem.defaultExpectation == nil {
		mmUpsertCartItem.defaultExpectation = &CartRepositoryMockUpsertCartItemExpectation{}
	}

	if mmUpsertCartItem.defaultExpectation.params != nil {
		mmUpsertCartItem.mock.t.Fatalf("CartRepositoryMock.UpsertCartItem mock is already set by Expect")
	}

	if mmUpsertCartItem.defaultExpectation.paramPtrs == nil {
		mmUpsertCartItem.defaultExpectation.paramPtrs = &CartRepositoryMockUpsertCartItemParamPtrs{}
	}
	mmUpsertCartItem.defaultExpectation.paramPtrs.newItem = &newItem
	mmUpsertCartItem.defaultExpectation.expectationOrigins.originNewItem = minimock.CallerInfo(1)

	return mmUpsertCartItem
}

// Inspect accepts an inspector function that has same arguments as the CartRepository.UpsertCartItem
func (mmUpsertCartItem *mCartRepositoryMockUpsertCartItem) Inspect(f func(ctx context.Context, userID int64, newItem *domain.CartItem)) *mCartRepositoryMockUpsertCartItem {
	if mmUpsertCartItem.mock.inspectFuncUpsertCartItem != nil {
		mmUpsertCartItem.mock.t.Fatalf("Inspect function is already set for CartRepositoryMock.UpsertCartItem")
	}

	mmUpsertCartItem.mock.inspectFuncUpsertCartItem = f

	return mmUpsertCartItem
}

// Return sets up results that will be returned by CartRepository.UpsertCartItem
func (mmUpsertCartItem *mCartRepositoryMockUpsertCartItem) Return(cp1 *domain.CartItem, err error) *CartRepositoryMock {
	if mmUpsertCartItem.mock.funcUpsertCartItem != nil {
		mmUpsertCartItem.mock.t.Fatalf("CartRepositoryMock.UpsertCartItem mock is already set by Set")
	}

	if mmUpsertCartItem.defaultExpectation == nil {
		mmUpsertCartItem.defaultExpectation = &CartRepositoryMockUpsertCartItemExpectation{mock: mmUpsertCartItem.mock}
	}
	mmUpsertCartItem.defaultExpectation.results = &CartRepositoryMockUpsertCartItemResults{cp1, err}
	mmUpsertCartItem.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmUpsertCartItem.mock
}

// Set uses given function f to mock the CartRepository.UpsertCartItem method
func (mmUpsertCartItem *mCartRepositoryMockUpsertCartItem) Set(f func(ctx context.Context, userID int64, newItem *domain.CartItem) (cp1 *domain.CartItem, err error)) *CartRepositoryMock {
	if mmUpsertCartItem.defaultExpectation != nil {
		mmUpsertCartItem.mock.t.Fatalf("Default expectation is already set for the CartRepository.UpsertCartItem method")
	}

	if len(mmUpsertCartItem.expectations) > 0 {
		mmUpsertCartItem.mock.t.Fatalf("Some expectations are already set for the CartRepository.UpsertCartItem method")
	}

	mmUpsertCartItem.mock.funcUpsertCartItem = f
	mmUpsertCartItem.mock.funcUpsertCartItemOrigin = minimock.CallerInfo(1)
	return mmUpsertCartItem.mock
}

// When sets expectation for the CartRepository.UpsertCartItem which will trigger the result defined by the following
// Then helper
func (mmUpsertCartItem *mCartRepositoryMockUpsertCartItem) When(ctx context.Context, userID int64, newItem *domain.CartItem) *CartRepositoryMockUpsertCartItemExpectation {
	if mmUpsertCartItem.mock.funcUpsertCartItem != nil {
		mmUpsertCartItem.mock.t.Fatalf("CartRepositoryMock.UpsertCartItem mock is already set by Set")
	}

	expectation := &CartRepositoryMockUpsertCartItemExpectation{
		mock:               mmUpsertCartItem.mock,
		params:             &CartRepositoryMockUpsertCartItemParams{ctx, userID, newItem},
		expectationOrigins: CartRepositoryMockUpsertCartItemExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmUpsertCartItem.expectations = append(mmUpsertCartItem.expectations, expectation)
	return expectation
}

// Then sets up CartRepository.UpsertCartItem return parameters for the expectation previously defined by the When method
func (e *CartRepositoryMockUpsertCartItemExpectation) Then(cp1 *domain.CartItem, err error) *CartRepositoryMock {
	e.results = &CartRepositoryMockUpsertCartItemResults{cp1, err}
	return e.mock
}

// Times sets number of times CartRepository.UpsertCartItem should be invoked
func (mmUpsertCartItem *mCartRepositoryMockUpsertCartItem) Times(n uint64) *mCartRepositoryMockUpsertCartItem {
	if n == 0 {
		mmUpsertCartItem.mock.t.Fatalf("Times of CartRepositoryMock.UpsertCartItem mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmUpsertCartItem.expectedInvocations, n)
	mmUpsertCartItem.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmUpsertCartItem
}

func (mmUpsertCartItem *mCartRepositoryMockUpsertCartItem) invocationsDone() bool {
	if len(mmUpsertCartItem.expectations) == 0 && mmUpsertCartItem.defaultExpectation == nil && mmUpsertCartItem.mock.funcUpsertCartItem == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmUpsertCartItem.mock.afterUpsertCartItemCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmUpsertCartItem.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// UpsertCartItem implements mm_service.CartRepository
func (mmUpsertCartItem *CartRepositoryMock) UpsertCartItem(ctx context.Context, userID int64, newItem *domain.CartItem) (cp1 *domain.CartItem, err error) {
	mm_atomic.AddUint64(&mmUpsertCartItem.beforeUpsertCartItemCounter, 1)
	defer mm_atomic.AddUint64(&mmUpsertCartItem.afterUpsertCartItemCounter, 1)

	mmUpsertCartItem.t.Helper()

	if mmUpsertCartItem.inspectFuncUpsertCartItem != nil {
		mmUpsertCartItem.inspectFuncUpsertCartItem(ctx, userID, newItem)
	}

	mm_params := CartRepositoryMockUpsertCartItemParams{ctx, userID, newItem}

	// Record call args
	mmUpsertCartItem.UpsertCartItemMock.mutex.Lock()
	mmUpsertCartItem.UpsertCartItemMock.callArgs = append(mmUpsertCartItem.UpsertCartItemMock.callArgs, &mm_params)
	mmUpsertCartItem.UpsertCartItemMock.mutex.Unlock()

	for _, e := range mmUpsertCartItem.UpsertCartItemMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.cp1, e.results.err
		}
	}

	if mmUpsertCartItem.UpsertCartItemMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmUpsertCartItem.UpsertCartItemMock.defaultExpectation.Counter, 1)
		mm_want := mmUpsertCartItem.UpsertCartItemMock.defaultExpectation.params
		mm_want_ptrs := mmUpsertCartItem.UpsertCartItemMock.defaultExpectation.paramPtrs

		mm_got := CartRepositoryMockUpsertCartItemParams{ctx, userID, newItem}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmUpsertCartItem.t.Errorf("CartRepositoryMock.UpsertCartItem got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpsertCartItem.UpsertCartItemMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.userID != nil && !minimock.Equal(*mm_want_ptrs.userID, mm_got.userID) {
				mmUpsertCartItem.t.Errorf("CartRepositoryMock.UpsertCartItem got unexpected parameter userID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpsertCartItem.UpsertCartItemMock.defaultExpectation.expectationOrigins.originUserID, *mm_want_ptrs.userID, mm_got.userID, minimock.Diff(*mm_want_ptrs.userID, mm_got.userID))
			}

			if mm_want_ptrs.newItem != nil && !minimock.Equal(*mm_want_ptrs.newItem, mm_got.newItem) {
				mmUpsertCartItem.t.Errorf("CartRepositoryMock.UpsertCartItem got unexpected parameter newItem, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpsertCartItem.UpsertCartItemMock.defaultExpectation.expectationOrigins.originNewItem, *mm_want_ptrs.newItem, mm_got.newItem, minimock.Diff(*mm_want_ptrs.newItem, mm_got.newItem))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmUpsertCartItem.t.Errorf("CartRepositoryMock.UpsertCartItem got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmUpsertCartItem.UpsertCartItemMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmUpsertCartItem.UpsertCartItemMock.defaultExpectation.results
		if mm_results == nil {
			mmUpsertCartItem.t.Fatal("No results are set for the CartRepositoryMock.UpsertCartItem")
		}
		return (*mm_results).cp1, (*mm_results).err
	}
	if mmUpsertCartItem.funcUpsertCartItem != nil {
		return mmUpsertCartItem.funcUpsertCartItem(ctx, userID, newItem)
	}
	mmUpsertCartItem.t.Fatalf("Unexpected call to CartRepositoryMock.UpsertCartItem. %v %v %v", ctx, userID, newItem)
	return
}

// UpsertCartItemAfterCounter returns a count of finished CartRepositoryMock.UpsertCartItem invocations
func (mmUpsertCartItem *CartRepositoryMock) UpsertCartItemAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpsertCartItem.afterUpsertCartItemCounter)
}

// UpsertCartItemBeforeCounter returns a count of CartRepositoryMock.UpsertCartItem invocations
func (mmUpsertCartItem *CartRepositoryMock) UpsertCartItemBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpsertCartItem.beforeUpsertCartItemCounter)
}

// Calls returns a list of arguments used in each call to CartRepositoryMock.UpsertCartItem.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmUpsertCartItem *mCartRepositoryMockUpsertCartItem) Calls() []*CartRepositoryMockUpsertCartItemParams {
	mmUpsertCartItem.mutex.RLock()

	argCopy := make([]*CartRepositoryMockUpsertCartItemParams, len(mmUpsertCartItem.callArgs))
	copy(argCopy, mmUpsertCartItem.callArgs)

	mmUpsertCartItem.mutex.RUnlock()

	return argCopy
}

// MinimockUpsertCartItemDone returns true if the count of the UpsertCartItem invocations corresponds
// the number of defined expectations
func (m *CartRepositoryMock) MinimockUpsertCartItemDone() bool {
	if m.UpsertCartItemMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.UpsertCartItemMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.UpsertCartItemMock.invocationsDone()
}

// MinimockUpsertCartItemInspect logs each unmet expectation
func (m *CartRepositoryMock) MinimockUpsertCartItemInspect() {
	for _, e := range m.UpsertCartItemMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to CartRepositoryMock.UpsertCartItem at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterUpsertCartItemCounter := mm_atomic.LoadUint64(&m.afterUpsertCartItemCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.UpsertCartItemMock.defaultExpectation != nil && afterUpsertCartItemCounter < 1 {
		if m.UpsertCartItemMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to CartRepositoryMock.UpsertCartItem at\n%s", m.UpsertCartItemMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to CartRepositoryMock.UpsertCartItem at\n%s with params: %#v", m.UpsertCartItemMock.defaultExpectation.expectationOrigins.origin, *m.UpsertCartItemMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpsertCartItem != nil && afterUpsertCartItemCounter < 1 {
		m.t.Errorf("Expected call to CartRepositoryMock.UpsertCartItem at\n%s", m.funcUpsertCartItemOrigin)
	}

	if !m.UpsertCartItemMock.invocationsDone() && afterUpsertCartItemCounter > 0 {
		m.t.Errorf("Expected %d calls to CartRepositoryMock.UpsertCartItem at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.UpsertCartItemMock.expectedInvocations), m.UpsertCartItemMock.expectedInvocationsOrigin, afterUpsertCartItemCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *CartRepositoryMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockDeleteCartInspect()

			m.MinimockDeleteCartItemInspect()

			m.MinimockGetCartByUserIDOrderBySkuInspect()

			m.MinimockUpsertCartItemInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *CartRepositoryMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *CartRepositoryMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockDeleteCartDone() &&
		m.MinimockDeleteCartItemDone() &&
		m.MinimockGetCartByUserIDOrderBySkuDone() &&
		m.MinimockUpsertCartItemDone()
}
