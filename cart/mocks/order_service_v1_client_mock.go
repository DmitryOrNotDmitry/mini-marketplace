// Code generated by http://github.com/gojuno/minimock (v3.4.5). DO NOT EDIT.

package mocks

//go:generate minimock -i route256/loms/pkg/api/orders/v1.OrderServiceV1Client -o order_service_v1_client_mock.go -n OrderServiceV1ClientMock -p mocks

import (
	context "context"
	mm_orders "route256/loms/pkg/api/orders/v1"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
	grpc "google.golang.org/grpc"
)

// OrderServiceV1ClientMock implements mm_orders.OrderServiceV1Client
type OrderServiceV1ClientMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcOrderCancelV1          func(ctx context.Context, in *mm_orders.OrderCancelRequest, opts ...grpc.CallOption) (op1 *mm_orders.OrderCancelResponse, err error)
	funcOrderCancelV1Origin    string
	inspectFuncOrderCancelV1   func(ctx context.Context, in *mm_orders.OrderCancelRequest, opts ...grpc.CallOption)
	afterOrderCancelV1Counter  uint64
	beforeOrderCancelV1Counter uint64
	OrderCancelV1Mock          mOrderServiceV1ClientMockOrderCancelV1

	funcOrderCreateV1          func(ctx context.Context, in *mm_orders.OrderCreateRequest, opts ...grpc.CallOption) (op1 *mm_orders.OrderCreateResponse, err error)
	funcOrderCreateV1Origin    string
	inspectFuncOrderCreateV1   func(ctx context.Context, in *mm_orders.OrderCreateRequest, opts ...grpc.CallOption)
	afterOrderCreateV1Counter  uint64
	beforeOrderCreateV1Counter uint64
	OrderCreateV1Mock          mOrderServiceV1ClientMockOrderCreateV1

	funcOrderInfoV1          func(ctx context.Context, in *mm_orders.OrderInfoRequest, opts ...grpc.CallOption) (op1 *mm_orders.OrderInfoResponse, err error)
	funcOrderInfoV1Origin    string
	inspectFuncOrderInfoV1   func(ctx context.Context, in *mm_orders.OrderInfoRequest, opts ...grpc.CallOption)
	afterOrderInfoV1Counter  uint64
	beforeOrderInfoV1Counter uint64
	OrderInfoV1Mock          mOrderServiceV1ClientMockOrderInfoV1

	funcOrderPayV1          func(ctx context.Context, in *mm_orders.OrderPayRequest, opts ...grpc.CallOption) (op1 *mm_orders.OrderPayResponse, err error)
	funcOrderPayV1Origin    string
	inspectFuncOrderPayV1   func(ctx context.Context, in *mm_orders.OrderPayRequest, opts ...grpc.CallOption)
	afterOrderPayV1Counter  uint64
	beforeOrderPayV1Counter uint64
	OrderPayV1Mock          mOrderServiceV1ClientMockOrderPayV1
}

// NewOrderServiceV1ClientMock returns a mock for mm_orders.OrderServiceV1Client
func NewOrderServiceV1ClientMock(t minimock.Tester) *OrderServiceV1ClientMock {
	m := &OrderServiceV1ClientMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.OrderCancelV1Mock = mOrderServiceV1ClientMockOrderCancelV1{mock: m}
	m.OrderCancelV1Mock.callArgs = []*OrderServiceV1ClientMockOrderCancelV1Params{}

	m.OrderCreateV1Mock = mOrderServiceV1ClientMockOrderCreateV1{mock: m}
	m.OrderCreateV1Mock.callArgs = []*OrderServiceV1ClientMockOrderCreateV1Params{}

	m.OrderInfoV1Mock = mOrderServiceV1ClientMockOrderInfoV1{mock: m}
	m.OrderInfoV1Mock.callArgs = []*OrderServiceV1ClientMockOrderInfoV1Params{}

	m.OrderPayV1Mock = mOrderServiceV1ClientMockOrderPayV1{mock: m}
	m.OrderPayV1Mock.callArgs = []*OrderServiceV1ClientMockOrderPayV1Params{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mOrderServiceV1ClientMockOrderCancelV1 struct {
	optional           bool
	mock               *OrderServiceV1ClientMock
	defaultExpectation *OrderServiceV1ClientMockOrderCancelV1Expectation
	expectations       []*OrderServiceV1ClientMockOrderCancelV1Expectation

	callArgs []*OrderServiceV1ClientMockOrderCancelV1Params
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// OrderServiceV1ClientMockOrderCancelV1Expectation specifies expectation struct of the OrderServiceV1Client.OrderCancelV1
type OrderServiceV1ClientMockOrderCancelV1Expectation struct {
	mock               *OrderServiceV1ClientMock
	params             *OrderServiceV1ClientMockOrderCancelV1Params
	paramPtrs          *OrderServiceV1ClientMockOrderCancelV1ParamPtrs
	expectationOrigins OrderServiceV1ClientMockOrderCancelV1ExpectationOrigins
	results            *OrderServiceV1ClientMockOrderCancelV1Results
	returnOrigin       string
	Counter            uint64
}

// OrderServiceV1ClientMockOrderCancelV1Params contains parameters of the OrderServiceV1Client.OrderCancelV1
type OrderServiceV1ClientMockOrderCancelV1Params struct {
	ctx  context.Context
	in   *mm_orders.OrderCancelRequest
	opts []grpc.CallOption
}

// OrderServiceV1ClientMockOrderCancelV1ParamPtrs contains pointers to parameters of the OrderServiceV1Client.OrderCancelV1
type OrderServiceV1ClientMockOrderCancelV1ParamPtrs struct {
	ctx  *context.Context
	in   **mm_orders.OrderCancelRequest
	opts *[]grpc.CallOption
}

// OrderServiceV1ClientMockOrderCancelV1Results contains results of the OrderServiceV1Client.OrderCancelV1
type OrderServiceV1ClientMockOrderCancelV1Results struct {
	op1 *mm_orders.OrderCancelResponse
	err error
}

// OrderServiceV1ClientMockOrderCancelV1Origins contains origins of expectations of the OrderServiceV1Client.OrderCancelV1
type OrderServiceV1ClientMockOrderCancelV1ExpectationOrigins struct {
	origin     string
	originCtx  string
	originIn   string
	originOpts string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmOrderCancelV1 *mOrderServiceV1ClientMockOrderCancelV1) Optional() *mOrderServiceV1ClientMockOrderCancelV1 {
	mmOrderCancelV1.optional = true
	return mmOrderCancelV1
}

// Expect sets up expected params for OrderServiceV1Client.OrderCancelV1
func (mmOrderCancelV1 *mOrderServiceV1ClientMockOrderCancelV1) Expect(ctx context.Context, in *mm_orders.OrderCancelRequest, opts ...grpc.CallOption) *mOrderServiceV1ClientMockOrderCancelV1 {
	if mmOrderCancelV1.mock.funcOrderCancelV1 != nil {
		mmOrderCancelV1.mock.t.Fatalf("OrderServiceV1ClientMock.OrderCancelV1 mock is already set by Set")
	}

	if mmOrderCancelV1.defaultExpectation == nil {
		mmOrderCancelV1.defaultExpectation = &OrderServiceV1ClientMockOrderCancelV1Expectation{}
	}

	if mmOrderCancelV1.defaultExpectation.paramPtrs != nil {
		mmOrderCancelV1.mock.t.Fatalf("OrderServiceV1ClientMock.OrderCancelV1 mock is already set by ExpectParams functions")
	}

	mmOrderCancelV1.defaultExpectation.params = &OrderServiceV1ClientMockOrderCancelV1Params{ctx, in, opts}
	mmOrderCancelV1.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmOrderCancelV1.expectations {
		if minimock.Equal(e.params, mmOrderCancelV1.defaultExpectation.params) {
			mmOrderCancelV1.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmOrderCancelV1.defaultExpectation.params)
		}
	}

	return mmOrderCancelV1
}

// ExpectCtxParam1 sets up expected param ctx for OrderServiceV1Client.OrderCancelV1
func (mmOrderCancelV1 *mOrderServiceV1ClientMockOrderCancelV1) ExpectCtxParam1(ctx context.Context) *mOrderServiceV1ClientMockOrderCancelV1 {
	if mmOrderCancelV1.mock.funcOrderCancelV1 != nil {
		mmOrderCancelV1.mock.t.Fatalf("OrderServiceV1ClientMock.OrderCancelV1 mock is already set by Set")
	}

	if mmOrderCancelV1.defaultExpectation == nil {
		mmOrderCancelV1.defaultExpectation = &OrderServiceV1ClientMockOrderCancelV1Expectation{}
	}

	if mmOrderCancelV1.defaultExpectation.params != nil {
		mmOrderCancelV1.mock.t.Fatalf("OrderServiceV1ClientMock.OrderCancelV1 mock is already set by Expect")
	}

	if mmOrderCancelV1.defaultExpectation.paramPtrs == nil {
		mmOrderCancelV1.defaultExpectation.paramPtrs = &OrderServiceV1ClientMockOrderCancelV1ParamPtrs{}
	}
	mmOrderCancelV1.defaultExpectation.paramPtrs.ctx = &ctx
	mmOrderCancelV1.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmOrderCancelV1
}

// ExpectInParam2 sets up expected param in for OrderServiceV1Client.OrderCancelV1
func (mmOrderCancelV1 *mOrderServiceV1ClientMockOrderCancelV1) ExpectInParam2(in *mm_orders.OrderCancelRequest) *mOrderServiceV1ClientMockOrderCancelV1 {
	if mmOrderCancelV1.mock.funcOrderCancelV1 != nil {
		mmOrderCancelV1.mock.t.Fatalf("OrderServiceV1ClientMock.OrderCancelV1 mock is already set by Set")
	}

	if mmOrderCancelV1.defaultExpectation == nil {
		mmOrderCancelV1.defaultExpectation = &OrderServiceV1ClientMockOrderCancelV1Expectation{}
	}

	if mmOrderCancelV1.defaultExpectation.params != nil {
		mmOrderCancelV1.mock.t.Fatalf("OrderServiceV1ClientMock.OrderCancelV1 mock is already set by Expect")
	}

	if mmOrderCancelV1.defaultExpectation.paramPtrs == nil {
		mmOrderCancelV1.defaultExpectation.paramPtrs = &OrderServiceV1ClientMockOrderCancelV1ParamPtrs{}
	}
	mmOrderCancelV1.defaultExpectation.paramPtrs.in = &in
	mmOrderCancelV1.defaultExpectation.expectationOrigins.originIn = minimock.CallerInfo(1)

	return mmOrderCancelV1
}

// ExpectOptsParam3 sets up expected param opts for OrderServiceV1Client.OrderCancelV1
func (mmOrderCancelV1 *mOrderServiceV1ClientMockOrderCancelV1) ExpectOptsParam3(opts ...grpc.CallOption) *mOrderServiceV1ClientMockOrderCancelV1 {
	if mmOrderCancelV1.mock.funcOrderCancelV1 != nil {
		mmOrderCancelV1.mock.t.Fatalf("OrderServiceV1ClientMock.OrderCancelV1 mock is already set by Set")
	}

	if mmOrderCancelV1.defaultExpectation == nil {
		mmOrderCancelV1.defaultExpectation = &OrderServiceV1ClientMockOrderCancelV1Expectation{}
	}

	if mmOrderCancelV1.defaultExpectation.params != nil {
		mmOrderCancelV1.mock.t.Fatalf("OrderServiceV1ClientMock.OrderCancelV1 mock is already set by Expect")
	}

	if mmOrderCancelV1.defaultExpectation.paramPtrs == nil {
		mmOrderCancelV1.defaultExpectation.paramPtrs = &OrderServiceV1ClientMockOrderCancelV1ParamPtrs{}
	}
	mmOrderCancelV1.defaultExpectation.paramPtrs.opts = &opts
	mmOrderCancelV1.defaultExpectation.expectationOrigins.originOpts = minimock.CallerInfo(1)

	return mmOrderCancelV1
}

// Inspect accepts an inspector function that has same arguments as the OrderServiceV1Client.OrderCancelV1
func (mmOrderCancelV1 *mOrderServiceV1ClientMockOrderCancelV1) Inspect(f func(ctx context.Context, in *mm_orders.OrderCancelRequest, opts ...grpc.CallOption)) *mOrderServiceV1ClientMockOrderCancelV1 {
	if mmOrderCancelV1.mock.inspectFuncOrderCancelV1 != nil {
		mmOrderCancelV1.mock.t.Fatalf("Inspect function is already set for OrderServiceV1ClientMock.OrderCancelV1")
	}

	mmOrderCancelV1.mock.inspectFuncOrderCancelV1 = f

	return mmOrderCancelV1
}

// Return sets up results that will be returned by OrderServiceV1Client.OrderCancelV1
func (mmOrderCancelV1 *mOrderServiceV1ClientMockOrderCancelV1) Return(op1 *mm_orders.OrderCancelResponse, err error) *OrderServiceV1ClientMock {
	if mmOrderCancelV1.mock.funcOrderCancelV1 != nil {
		mmOrderCancelV1.mock.t.Fatalf("OrderServiceV1ClientMock.OrderCancelV1 mock is already set by Set")
	}

	if mmOrderCancelV1.defaultExpectation == nil {
		mmOrderCancelV1.defaultExpectation = &OrderServiceV1ClientMockOrderCancelV1Expectation{mock: mmOrderCancelV1.mock}
	}
	mmOrderCancelV1.defaultExpectation.results = &OrderServiceV1ClientMockOrderCancelV1Results{op1, err}
	mmOrderCancelV1.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmOrderCancelV1.mock
}

// Set uses given function f to mock the OrderServiceV1Client.OrderCancelV1 method
func (mmOrderCancelV1 *mOrderServiceV1ClientMockOrderCancelV1) Set(f func(ctx context.Context, in *mm_orders.OrderCancelRequest, opts ...grpc.CallOption) (op1 *mm_orders.OrderCancelResponse, err error)) *OrderServiceV1ClientMock {
	if mmOrderCancelV1.defaultExpectation != nil {
		mmOrderCancelV1.mock.t.Fatalf("Default expectation is already set for the OrderServiceV1Client.OrderCancelV1 method")
	}

	if len(mmOrderCancelV1.expectations) > 0 {
		mmOrderCancelV1.mock.t.Fatalf("Some expectations are already set for the OrderServiceV1Client.OrderCancelV1 method")
	}

	mmOrderCancelV1.mock.funcOrderCancelV1 = f
	mmOrderCancelV1.mock.funcOrderCancelV1Origin = minimock.CallerInfo(1)
	return mmOrderCancelV1.mock
}

// When sets expectation for the OrderServiceV1Client.OrderCancelV1 which will trigger the result defined by the following
// Then helper
func (mmOrderCancelV1 *mOrderServiceV1ClientMockOrderCancelV1) When(ctx context.Context, in *mm_orders.OrderCancelRequest, opts ...grpc.CallOption) *OrderServiceV1ClientMockOrderCancelV1Expectation {
	if mmOrderCancelV1.mock.funcOrderCancelV1 != nil {
		mmOrderCancelV1.mock.t.Fatalf("OrderServiceV1ClientMock.OrderCancelV1 mock is already set by Set")
	}

	expectation := &OrderServiceV1ClientMockOrderCancelV1Expectation{
		mock:               mmOrderCancelV1.mock,
		params:             &OrderServiceV1ClientMockOrderCancelV1Params{ctx, in, opts},
		expectationOrigins: OrderServiceV1ClientMockOrderCancelV1ExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmOrderCancelV1.expectations = append(mmOrderCancelV1.expectations, expectation)
	return expectation
}

// Then sets up OrderServiceV1Client.OrderCancelV1 return parameters for the expectation previously defined by the When method
func (e *OrderServiceV1ClientMockOrderCancelV1Expectation) Then(op1 *mm_orders.OrderCancelResponse, err error) *OrderServiceV1ClientMock {
	e.results = &OrderServiceV1ClientMockOrderCancelV1Results{op1, err}
	return e.mock
}

// Times sets number of times OrderServiceV1Client.OrderCancelV1 should be invoked
func (mmOrderCancelV1 *mOrderServiceV1ClientMockOrderCancelV1) Times(n uint64) *mOrderServiceV1ClientMockOrderCancelV1 {
	if n == 0 {
		mmOrderCancelV1.mock.t.Fatalf("Times of OrderServiceV1ClientMock.OrderCancelV1 mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmOrderCancelV1.expectedInvocations, n)
	mmOrderCancelV1.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmOrderCancelV1
}

func (mmOrderCancelV1 *mOrderServiceV1ClientMockOrderCancelV1) invocationsDone() bool {
	if len(mmOrderCancelV1.expectations) == 0 && mmOrderCancelV1.defaultExpectation == nil && mmOrderCancelV1.mock.funcOrderCancelV1 == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmOrderCancelV1.mock.afterOrderCancelV1Counter)
	expectedInvocations := mm_atomic.LoadUint64(&mmOrderCancelV1.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// OrderCancelV1 implements mm_orders.OrderServiceV1Client
func (mmOrderCancelV1 *OrderServiceV1ClientMock) OrderCancelV1(ctx context.Context, in *mm_orders.OrderCancelRequest, opts ...grpc.CallOption) (op1 *mm_orders.OrderCancelResponse, err error) {
	mm_atomic.AddUint64(&mmOrderCancelV1.beforeOrderCancelV1Counter, 1)
	defer mm_atomic.AddUint64(&mmOrderCancelV1.afterOrderCancelV1Counter, 1)

	mmOrderCancelV1.t.Helper()

	if mmOrderCancelV1.inspectFuncOrderCancelV1 != nil {
		mmOrderCancelV1.inspectFuncOrderCancelV1(ctx, in, opts...)
	}

	mm_params := OrderServiceV1ClientMockOrderCancelV1Params{ctx, in, opts}

	// Record call args
	mmOrderCancelV1.OrderCancelV1Mock.mutex.Lock()
	mmOrderCancelV1.OrderCancelV1Mock.callArgs = append(mmOrderCancelV1.OrderCancelV1Mock.callArgs, &mm_params)
	mmOrderCancelV1.OrderCancelV1Mock.mutex.Unlock()

	for _, e := range mmOrderCancelV1.OrderCancelV1Mock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.op1, e.results.err
		}
	}

	if mmOrderCancelV1.OrderCancelV1Mock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmOrderCancelV1.OrderCancelV1Mock.defaultExpectation.Counter, 1)
		mm_want := mmOrderCancelV1.OrderCancelV1Mock.defaultExpectation.params
		mm_want_ptrs := mmOrderCancelV1.OrderCancelV1Mock.defaultExpectation.paramPtrs

		mm_got := OrderServiceV1ClientMockOrderCancelV1Params{ctx, in, opts}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmOrderCancelV1.t.Errorf("OrderServiceV1ClientMock.OrderCancelV1 got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmOrderCancelV1.OrderCancelV1Mock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.in != nil && !minimock.Equal(*mm_want_ptrs.in, mm_got.in) {
				mmOrderCancelV1.t.Errorf("OrderServiceV1ClientMock.OrderCancelV1 got unexpected parameter in, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmOrderCancelV1.OrderCancelV1Mock.defaultExpectation.expectationOrigins.originIn, *mm_want_ptrs.in, mm_got.in, minimock.Diff(*mm_want_ptrs.in, mm_got.in))
			}

			if mm_want_ptrs.opts != nil && !minimock.Equal(*mm_want_ptrs.opts, mm_got.opts) {
				mmOrderCancelV1.t.Errorf("OrderServiceV1ClientMock.OrderCancelV1 got unexpected parameter opts, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmOrderCancelV1.OrderCancelV1Mock.defaultExpectation.expectationOrigins.originOpts, *mm_want_ptrs.opts, mm_got.opts, minimock.Diff(*mm_want_ptrs.opts, mm_got.opts))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmOrderCancelV1.t.Errorf("OrderServiceV1ClientMock.OrderCancelV1 got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmOrderCancelV1.OrderCancelV1Mock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmOrderCancelV1.OrderCancelV1Mock.defaultExpectation.results
		if mm_results == nil {
			mmOrderCancelV1.t.Fatal("No results are set for the OrderServiceV1ClientMock.OrderCancelV1")
		}
		return (*mm_results).op1, (*mm_results).err
	}
	if mmOrderCancelV1.funcOrderCancelV1 != nil {
		return mmOrderCancelV1.funcOrderCancelV1(ctx, in, opts...)
	}
	mmOrderCancelV1.t.Fatalf("Unexpected call to OrderServiceV1ClientMock.OrderCancelV1. %v %v %v", ctx, in, opts)
	return
}

// OrderCancelV1AfterCounter returns a count of finished OrderServiceV1ClientMock.OrderCancelV1 invocations
func (mmOrderCancelV1 *OrderServiceV1ClientMock) OrderCancelV1AfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmOrderCancelV1.afterOrderCancelV1Counter)
}

// OrderCancelV1BeforeCounter returns a count of OrderServiceV1ClientMock.OrderCancelV1 invocations
func (mmOrderCancelV1 *OrderServiceV1ClientMock) OrderCancelV1BeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmOrderCancelV1.beforeOrderCancelV1Counter)
}

// Calls returns a list of arguments used in each call to OrderServiceV1ClientMock.OrderCancelV1.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmOrderCancelV1 *mOrderServiceV1ClientMockOrderCancelV1) Calls() []*OrderServiceV1ClientMockOrderCancelV1Params {
	mmOrderCancelV1.mutex.RLock()

	argCopy := make([]*OrderServiceV1ClientMockOrderCancelV1Params, len(mmOrderCancelV1.callArgs))
	copy(argCopy, mmOrderCancelV1.callArgs)

	mmOrderCancelV1.mutex.RUnlock()

	return argCopy
}

// MinimockOrderCancelV1Done returns true if the count of the OrderCancelV1 invocations corresponds
// the number of defined expectations
func (m *OrderServiceV1ClientMock) MinimockOrderCancelV1Done() bool {
	if m.OrderCancelV1Mock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.OrderCancelV1Mock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.OrderCancelV1Mock.invocationsDone()
}

// MinimockOrderCancelV1Inspect logs each unmet expectation
func (m *OrderServiceV1ClientMock) MinimockOrderCancelV1Inspect() {
	for _, e := range m.OrderCancelV1Mock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to OrderServiceV1ClientMock.OrderCancelV1 at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterOrderCancelV1Counter := mm_atomic.LoadUint64(&m.afterOrderCancelV1Counter)
	// if default expectation was set then invocations count should be greater than zero
	if m.OrderCancelV1Mock.defaultExpectation != nil && afterOrderCancelV1Counter < 1 {
		if m.OrderCancelV1Mock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to OrderServiceV1ClientMock.OrderCancelV1 at\n%s", m.OrderCancelV1Mock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to OrderServiceV1ClientMock.OrderCancelV1 at\n%s with params: %#v", m.OrderCancelV1Mock.defaultExpectation.expectationOrigins.origin, *m.OrderCancelV1Mock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcOrderCancelV1 != nil && afterOrderCancelV1Counter < 1 {
		m.t.Errorf("Expected call to OrderServiceV1ClientMock.OrderCancelV1 at\n%s", m.funcOrderCancelV1Origin)
	}

	if !m.OrderCancelV1Mock.invocationsDone() && afterOrderCancelV1Counter > 0 {
		m.t.Errorf("Expected %d calls to OrderServiceV1ClientMock.OrderCancelV1 at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.OrderCancelV1Mock.expectedInvocations), m.OrderCancelV1Mock.expectedInvocationsOrigin, afterOrderCancelV1Counter)
	}
}

type mOrderServiceV1ClientMockOrderCreateV1 struct {
	optional           bool
	mock               *OrderServiceV1ClientMock
	defaultExpectation *OrderServiceV1ClientMockOrderCreateV1Expectation
	expectations       []*OrderServiceV1ClientMockOrderCreateV1Expectation

	callArgs []*OrderServiceV1ClientMockOrderCreateV1Params
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// OrderServiceV1ClientMockOrderCreateV1Expectation specifies expectation struct of the OrderServiceV1Client.OrderCreateV1
type OrderServiceV1ClientMockOrderCreateV1Expectation struct {
	mock               *OrderServiceV1ClientMock
	params             *OrderServiceV1ClientMockOrderCreateV1Params
	paramPtrs          *OrderServiceV1ClientMockOrderCreateV1ParamPtrs
	expectationOrigins OrderServiceV1ClientMockOrderCreateV1ExpectationOrigins
	results            *OrderServiceV1ClientMockOrderCreateV1Results
	returnOrigin       string
	Counter            uint64
}

// OrderServiceV1ClientMockOrderCreateV1Params contains parameters of the OrderServiceV1Client.OrderCreateV1
type OrderServiceV1ClientMockOrderCreateV1Params struct {
	ctx  context.Context
	in   *mm_orders.OrderCreateRequest
	opts []grpc.CallOption
}

// OrderServiceV1ClientMockOrderCreateV1ParamPtrs contains pointers to parameters of the OrderServiceV1Client.OrderCreateV1
type OrderServiceV1ClientMockOrderCreateV1ParamPtrs struct {
	ctx  *context.Context
	in   **mm_orders.OrderCreateRequest
	opts *[]grpc.CallOption
}

// OrderServiceV1ClientMockOrderCreateV1Results contains results of the OrderServiceV1Client.OrderCreateV1
type OrderServiceV1ClientMockOrderCreateV1Results struct {
	op1 *mm_orders.OrderCreateResponse
	err error
}

// OrderServiceV1ClientMockOrderCreateV1Origins contains origins of expectations of the OrderServiceV1Client.OrderCreateV1
type OrderServiceV1ClientMockOrderCreateV1ExpectationOrigins struct {
	origin     string
	originCtx  string
	originIn   string
	originOpts string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmOrderCreateV1 *mOrderServiceV1ClientMockOrderCreateV1) Optional() *mOrderServiceV1ClientMockOrderCreateV1 {
	mmOrderCreateV1.optional = true
	return mmOrderCreateV1
}

// Expect sets up expected params for OrderServiceV1Client.OrderCreateV1
func (mmOrderCreateV1 *mOrderServiceV1ClientMockOrderCreateV1) Expect(ctx context.Context, in *mm_orders.OrderCreateRequest, opts ...grpc.CallOption) *mOrderServiceV1ClientMockOrderCreateV1 {
	if mmOrderCreateV1.mock.funcOrderCreateV1 != nil {
		mmOrderCreateV1.mock.t.Fatalf("OrderServiceV1ClientMock.OrderCreateV1 mock is already set by Set")
	}

	if mmOrderCreateV1.defaultExpectation == nil {
		mmOrderCreateV1.defaultExpectation = &OrderServiceV1ClientMockOrderCreateV1Expectation{}
	}

	if mmOrderCreateV1.defaultExpectation.paramPtrs != nil {
		mmOrderCreateV1.mock.t.Fatalf("OrderServiceV1ClientMock.OrderCreateV1 mock is already set by ExpectParams functions")
	}

	mmOrderCreateV1.defaultExpectation.params = &OrderServiceV1ClientMockOrderCreateV1Params{ctx, in, opts}
	mmOrderCreateV1.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmOrderCreateV1.expectations {
		if minimock.Equal(e.params, mmOrderCreateV1.defaultExpectation.params) {
			mmOrderCreateV1.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmOrderCreateV1.defaultExpectation.params)
		}
	}

	return mmOrderCreateV1
}

// ExpectCtxParam1 sets up expected param ctx for OrderServiceV1Client.OrderCreateV1
func (mmOrderCreateV1 *mOrderServiceV1ClientMockOrderCreateV1) ExpectCtxParam1(ctx context.Context) *mOrderServiceV1ClientMockOrderCreateV1 {
	if mmOrderCreateV1.mock.funcOrderCreateV1 != nil {
		mmOrderCreateV1.mock.t.Fatalf("OrderServiceV1ClientMock.OrderCreateV1 mock is already set by Set")
	}

	if mmOrderCreateV1.defaultExpectation == nil {
		mmOrderCreateV1.defaultExpectation = &OrderServiceV1ClientMockOrderCreateV1Expectation{}
	}

	if mmOrderCreateV1.defaultExpectation.params != nil {
		mmOrderCreateV1.mock.t.Fatalf("OrderServiceV1ClientMock.OrderCreateV1 mock is already set by Expect")
	}

	if mmOrderCreateV1.defaultExpectation.paramPtrs == nil {
		mmOrderCreateV1.defaultExpectation.paramPtrs = &OrderServiceV1ClientMockOrderCreateV1ParamPtrs{}
	}
	mmOrderCreateV1.defaultExpectation.paramPtrs.ctx = &ctx
	mmOrderCreateV1.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmOrderCreateV1
}

// ExpectInParam2 sets up expected param in for OrderServiceV1Client.OrderCreateV1
func (mmOrderCreateV1 *mOrderServiceV1ClientMockOrderCreateV1) ExpectInParam2(in *mm_orders.OrderCreateRequest) *mOrderServiceV1ClientMockOrderCreateV1 {
	if mmOrderCreateV1.mock.funcOrderCreateV1 != nil {
		mmOrderCreateV1.mock.t.Fatalf("OrderServiceV1ClientMock.OrderCreateV1 mock is already set by Set")
	}

	if mmOrderCreateV1.defaultExpectation == nil {
		mmOrderCreateV1.defaultExpectation = &OrderServiceV1ClientMockOrderCreateV1Expectation{}
	}

	if mmOrderCreateV1.defaultExpectation.params != nil {
		mmOrderCreateV1.mock.t.Fatalf("OrderServiceV1ClientMock.OrderCreateV1 mock is already set by Expect")
	}

	if mmOrderCreateV1.defaultExpectation.paramPtrs == nil {
		mmOrderCreateV1.defaultExpectation.paramPtrs = &OrderServiceV1ClientMockOrderCreateV1ParamPtrs{}
	}
	mmOrderCreateV1.defaultExpectation.paramPtrs.in = &in
	mmOrderCreateV1.defaultExpectation.expectationOrigins.originIn = minimock.CallerInfo(1)

	return mmOrderCreateV1
}

// ExpectOptsParam3 sets up expected param opts for OrderServiceV1Client.OrderCreateV1
func (mmOrderCreateV1 *mOrderServiceV1ClientMockOrderCreateV1) ExpectOptsParam3(opts ...grpc.CallOption) *mOrderServiceV1ClientMockOrderCreateV1 {
	if mmOrderCreateV1.mock.funcOrderCreateV1 != nil {
		mmOrderCreateV1.mock.t.Fatalf("OrderServiceV1ClientMock.OrderCreateV1 mock is already set by Set")
	}

	if mmOrderCreateV1.defaultExpectation == nil {
		mmOrderCreateV1.defaultExpectation = &OrderServiceV1ClientMockOrderCreateV1Expectation{}
	}

	if mmOrderCreateV1.defaultExpectation.params != nil {
		mmOrderCreateV1.mock.t.Fatalf("OrderServiceV1ClientMock.OrderCreateV1 mock is already set by Expect")
	}

	if mmOrderCreateV1.defaultExpectation.paramPtrs == nil {
		mmOrderCreateV1.defaultExpectation.paramPtrs = &OrderServiceV1ClientMockOrderCreateV1ParamPtrs{}
	}
	mmOrderCreateV1.defaultExpectation.paramPtrs.opts = &opts
	mmOrderCreateV1.defaultExpectation.expectationOrigins.originOpts = minimock.CallerInfo(1)

	return mmOrderCreateV1
}

// Inspect accepts an inspector function that has same arguments as the OrderServiceV1Client.OrderCreateV1
func (mmOrderCreateV1 *mOrderServiceV1ClientMockOrderCreateV1) Inspect(f func(ctx context.Context, in *mm_orders.OrderCreateRequest, opts ...grpc.CallOption)) *mOrderServiceV1ClientMockOrderCreateV1 {
	if mmOrderCreateV1.mock.inspectFuncOrderCreateV1 != nil {
		mmOrderCreateV1.mock.t.Fatalf("Inspect function is already set for OrderServiceV1ClientMock.OrderCreateV1")
	}

	mmOrderCreateV1.mock.inspectFuncOrderCreateV1 = f

	return mmOrderCreateV1
}

// Return sets up results that will be returned by OrderServiceV1Client.OrderCreateV1
func (mmOrderCreateV1 *mOrderServiceV1ClientMockOrderCreateV1) Return(op1 *mm_orders.OrderCreateResponse, err error) *OrderServiceV1ClientMock {
	if mmOrderCreateV1.mock.funcOrderCreateV1 != nil {
		mmOrderCreateV1.mock.t.Fatalf("OrderServiceV1ClientMock.OrderCreateV1 mock is already set by Set")
	}

	if mmOrderCreateV1.defaultExpectation == nil {
		mmOrderCreateV1.defaultExpectation = &OrderServiceV1ClientMockOrderCreateV1Expectation{mock: mmOrderCreateV1.mock}
	}
	mmOrderCreateV1.defaultExpectation.results = &OrderServiceV1ClientMockOrderCreateV1Results{op1, err}
	mmOrderCreateV1.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmOrderCreateV1.mock
}

// Set uses given function f to mock the OrderServiceV1Client.OrderCreateV1 method
func (mmOrderCreateV1 *mOrderServiceV1ClientMockOrderCreateV1) Set(f func(ctx context.Context, in *mm_orders.OrderCreateRequest, opts ...grpc.CallOption) (op1 *mm_orders.OrderCreateResponse, err error)) *OrderServiceV1ClientMock {
	if mmOrderCreateV1.defaultExpectation != nil {
		mmOrderCreateV1.mock.t.Fatalf("Default expectation is already set for the OrderServiceV1Client.OrderCreateV1 method")
	}

	if len(mmOrderCreateV1.expectations) > 0 {
		mmOrderCreateV1.mock.t.Fatalf("Some expectations are already set for the OrderServiceV1Client.OrderCreateV1 method")
	}

	mmOrderCreateV1.mock.funcOrderCreateV1 = f
	mmOrderCreateV1.mock.funcOrderCreateV1Origin = minimock.CallerInfo(1)
	return mmOrderCreateV1.mock
}

// When sets expectation for the OrderServiceV1Client.OrderCreateV1 which will trigger the result defined by the following
// Then helper
func (mmOrderCreateV1 *mOrderServiceV1ClientMockOrderCreateV1) When(ctx context.Context, in *mm_orders.OrderCreateRequest, opts ...grpc.CallOption) *OrderServiceV1ClientMockOrderCreateV1Expectation {
	if mmOrderCreateV1.mock.funcOrderCreateV1 != nil {
		mmOrderCreateV1.mock.t.Fatalf("OrderServiceV1ClientMock.OrderCreateV1 mock is already set by Set")
	}

	expectation := &OrderServiceV1ClientMockOrderCreateV1Expectation{
		mock:               mmOrderCreateV1.mock,
		params:             &OrderServiceV1ClientMockOrderCreateV1Params{ctx, in, opts},
		expectationOrigins: OrderServiceV1ClientMockOrderCreateV1ExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmOrderCreateV1.expectations = append(mmOrderCreateV1.expectations, expectation)
	return expectation
}

// Then sets up OrderServiceV1Client.OrderCreateV1 return parameters for the expectation previously defined by the When method
func (e *OrderServiceV1ClientMockOrderCreateV1Expectation) Then(op1 *mm_orders.OrderCreateResponse, err error) *OrderServiceV1ClientMock {
	e.results = &OrderServiceV1ClientMockOrderCreateV1Results{op1, err}
	return e.mock
}

// Times sets number of times OrderServiceV1Client.OrderCreateV1 should be invoked
func (mmOrderCreateV1 *mOrderServiceV1ClientMockOrderCreateV1) Times(n uint64) *mOrderServiceV1ClientMockOrderCreateV1 {
	if n == 0 {
		mmOrderCreateV1.mock.t.Fatalf("Times of OrderServiceV1ClientMock.OrderCreateV1 mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmOrderCreateV1.expectedInvocations, n)
	mmOrderCreateV1.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmOrderCreateV1
}

func (mmOrderCreateV1 *mOrderServiceV1ClientMockOrderCreateV1) invocationsDone() bool {
	if len(mmOrderCreateV1.expectations) == 0 && mmOrderCreateV1.defaultExpectation == nil && mmOrderCreateV1.mock.funcOrderCreateV1 == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmOrderCreateV1.mock.afterOrderCreateV1Counter)
	expectedInvocations := mm_atomic.LoadUint64(&mmOrderCreateV1.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// OrderCreateV1 implements mm_orders.OrderServiceV1Client
func (mmOrderCreateV1 *OrderServiceV1ClientMock) OrderCreateV1(ctx context.Context, in *mm_orders.OrderCreateRequest, opts ...grpc.CallOption) (op1 *mm_orders.OrderCreateResponse, err error) {
	mm_atomic.AddUint64(&mmOrderCreateV1.beforeOrderCreateV1Counter, 1)
	defer mm_atomic.AddUint64(&mmOrderCreateV1.afterOrderCreateV1Counter, 1)

	mmOrderCreateV1.t.Helper()

	if mmOrderCreateV1.inspectFuncOrderCreateV1 != nil {
		mmOrderCreateV1.inspectFuncOrderCreateV1(ctx, in, opts...)
	}

	mm_params := OrderServiceV1ClientMockOrderCreateV1Params{ctx, in, opts}

	// Record call args
	mmOrderCreateV1.OrderCreateV1Mock.mutex.Lock()
	mmOrderCreateV1.OrderCreateV1Mock.callArgs = append(mmOrderCreateV1.OrderCreateV1Mock.callArgs, &mm_params)
	mmOrderCreateV1.OrderCreateV1Mock.mutex.Unlock()

	for _, e := range mmOrderCreateV1.OrderCreateV1Mock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.op1, e.results.err
		}
	}

	if mmOrderCreateV1.OrderCreateV1Mock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmOrderCreateV1.OrderCreateV1Mock.defaultExpectation.Counter, 1)
		mm_want := mmOrderCreateV1.OrderCreateV1Mock.defaultExpectation.params
		mm_want_ptrs := mmOrderCreateV1.OrderCreateV1Mock.defaultExpectation.paramPtrs

		mm_got := OrderServiceV1ClientMockOrderCreateV1Params{ctx, in, opts}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmOrderCreateV1.t.Errorf("OrderServiceV1ClientMock.OrderCreateV1 got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmOrderCreateV1.OrderCreateV1Mock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.in != nil && !minimock.Equal(*mm_want_ptrs.in, mm_got.in) {
				mmOrderCreateV1.t.Errorf("OrderServiceV1ClientMock.OrderCreateV1 got unexpected parameter in, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmOrderCreateV1.OrderCreateV1Mock.defaultExpectation.expectationOrigins.originIn, *mm_want_ptrs.in, mm_got.in, minimock.Diff(*mm_want_ptrs.in, mm_got.in))
			}

			if mm_want_ptrs.opts != nil && !minimock.Equal(*mm_want_ptrs.opts, mm_got.opts) {
				mmOrderCreateV1.t.Errorf("OrderServiceV1ClientMock.OrderCreateV1 got unexpected parameter opts, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmOrderCreateV1.OrderCreateV1Mock.defaultExpectation.expectationOrigins.originOpts, *mm_want_ptrs.opts, mm_got.opts, minimock.Diff(*mm_want_ptrs.opts, mm_got.opts))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmOrderCreateV1.t.Errorf("OrderServiceV1ClientMock.OrderCreateV1 got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmOrderCreateV1.OrderCreateV1Mock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmOrderCreateV1.OrderCreateV1Mock.defaultExpectation.results
		if mm_results == nil {
			mmOrderCreateV1.t.Fatal("No results are set for the OrderServiceV1ClientMock.OrderCreateV1")
		}
		return (*mm_results).op1, (*mm_results).err
	}
	if mmOrderCreateV1.funcOrderCreateV1 != nil {
		return mmOrderCreateV1.funcOrderCreateV1(ctx, in, opts...)
	}
	mmOrderCreateV1.t.Fatalf("Unexpected call to OrderServiceV1ClientMock.OrderCreateV1. %v %v %v", ctx, in, opts)
	return
}

// OrderCreateV1AfterCounter returns a count of finished OrderServiceV1ClientMock.OrderCreateV1 invocations
func (mmOrderCreateV1 *OrderServiceV1ClientMock) OrderCreateV1AfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmOrderCreateV1.afterOrderCreateV1Counter)
}

// OrderCreateV1BeforeCounter returns a count of OrderServiceV1ClientMock.OrderCreateV1 invocations
func (mmOrderCreateV1 *OrderServiceV1ClientMock) OrderCreateV1BeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmOrderCreateV1.beforeOrderCreateV1Counter)
}

// Calls returns a list of arguments used in each call to OrderServiceV1ClientMock.OrderCreateV1.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmOrderCreateV1 *mOrderServiceV1ClientMockOrderCreateV1) Calls() []*OrderServiceV1ClientMockOrderCreateV1Params {
	mmOrderCreateV1.mutex.RLock()

	argCopy := make([]*OrderServiceV1ClientMockOrderCreateV1Params, len(mmOrderCreateV1.callArgs))
	copy(argCopy, mmOrderCreateV1.callArgs)

	mmOrderCreateV1.mutex.RUnlock()

	return argCopy
}

// MinimockOrderCreateV1Done returns true if the count of the OrderCreateV1 invocations corresponds
// the number of defined expectations
func (m *OrderServiceV1ClientMock) MinimockOrderCreateV1Done() bool {
	if m.OrderCreateV1Mock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.OrderCreateV1Mock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.OrderCreateV1Mock.invocationsDone()
}

// MinimockOrderCreateV1Inspect logs each unmet expectation
func (m *OrderServiceV1ClientMock) MinimockOrderCreateV1Inspect() {
	for _, e := range m.OrderCreateV1Mock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to OrderServiceV1ClientMock.OrderCreateV1 at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterOrderCreateV1Counter := mm_atomic.LoadUint64(&m.afterOrderCreateV1Counter)
	// if default expectation was set then invocations count should be greater than zero
	if m.OrderCreateV1Mock.defaultExpectation != nil && afterOrderCreateV1Counter < 1 {
		if m.OrderCreateV1Mock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to OrderServiceV1ClientMock.OrderCreateV1 at\n%s", m.OrderCreateV1Mock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to OrderServiceV1ClientMock.OrderCreateV1 at\n%s with params: %#v", m.OrderCreateV1Mock.defaultExpectation.expectationOrigins.origin, *m.OrderCreateV1Mock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcOrderCreateV1 != nil && afterOrderCreateV1Counter < 1 {
		m.t.Errorf("Expected call to OrderServiceV1ClientMock.OrderCreateV1 at\n%s", m.funcOrderCreateV1Origin)
	}

	if !m.OrderCreateV1Mock.invocationsDone() && afterOrderCreateV1Counter > 0 {
		m.t.Errorf("Expected %d calls to OrderServiceV1ClientMock.OrderCreateV1 at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.OrderCreateV1Mock.expectedInvocations), m.OrderCreateV1Mock.expectedInvocationsOrigin, afterOrderCreateV1Counter)
	}
}

type mOrderServiceV1ClientMockOrderInfoV1 struct {
	optional           bool
	mock               *OrderServiceV1ClientMock
	defaultExpectation *OrderServiceV1ClientMockOrderInfoV1Expectation
	expectations       []*OrderServiceV1ClientMockOrderInfoV1Expectation

	callArgs []*OrderServiceV1ClientMockOrderInfoV1Params
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// OrderServiceV1ClientMockOrderInfoV1Expectation specifies expectation struct of the OrderServiceV1Client.OrderInfoV1
type OrderServiceV1ClientMockOrderInfoV1Expectation struct {
	mock               *OrderServiceV1ClientMock
	params             *OrderServiceV1ClientMockOrderInfoV1Params
	paramPtrs          *OrderServiceV1ClientMockOrderInfoV1ParamPtrs
	expectationOrigins OrderServiceV1ClientMockOrderInfoV1ExpectationOrigins
	results            *OrderServiceV1ClientMockOrderInfoV1Results
	returnOrigin       string
	Counter            uint64
}

// OrderServiceV1ClientMockOrderInfoV1Params contains parameters of the OrderServiceV1Client.OrderInfoV1
type OrderServiceV1ClientMockOrderInfoV1Params struct {
	ctx  context.Context
	in   *mm_orders.OrderInfoRequest
	opts []grpc.CallOption
}

// OrderServiceV1ClientMockOrderInfoV1ParamPtrs contains pointers to parameters of the OrderServiceV1Client.OrderInfoV1
type OrderServiceV1ClientMockOrderInfoV1ParamPtrs struct {
	ctx  *context.Context
	in   **mm_orders.OrderInfoRequest
	opts *[]grpc.CallOption
}

// OrderServiceV1ClientMockOrderInfoV1Results contains results of the OrderServiceV1Client.OrderInfoV1
type OrderServiceV1ClientMockOrderInfoV1Results struct {
	op1 *mm_orders.OrderInfoResponse
	err error
}

// OrderServiceV1ClientMockOrderInfoV1Origins contains origins of expectations of the OrderServiceV1Client.OrderInfoV1
type OrderServiceV1ClientMockOrderInfoV1ExpectationOrigins struct {
	origin     string
	originCtx  string
	originIn   string
	originOpts string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmOrderInfoV1 *mOrderServiceV1ClientMockOrderInfoV1) Optional() *mOrderServiceV1ClientMockOrderInfoV1 {
	mmOrderInfoV1.optional = true
	return mmOrderInfoV1
}

// Expect sets up expected params for OrderServiceV1Client.OrderInfoV1
func (mmOrderInfoV1 *mOrderServiceV1ClientMockOrderInfoV1) Expect(ctx context.Context, in *mm_orders.OrderInfoRequest, opts ...grpc.CallOption) *mOrderServiceV1ClientMockOrderInfoV1 {
	if mmOrderInfoV1.mock.funcOrderInfoV1 != nil {
		mmOrderInfoV1.mock.t.Fatalf("OrderServiceV1ClientMock.OrderInfoV1 mock is already set by Set")
	}

	if mmOrderInfoV1.defaultExpectation == nil {
		mmOrderInfoV1.defaultExpectation = &OrderServiceV1ClientMockOrderInfoV1Expectation{}
	}

	if mmOrderInfoV1.defaultExpectation.paramPtrs != nil {
		mmOrderInfoV1.mock.t.Fatalf("OrderServiceV1ClientMock.OrderInfoV1 mock is already set by ExpectParams functions")
	}

	mmOrderInfoV1.defaultExpectation.params = &OrderServiceV1ClientMockOrderInfoV1Params{ctx, in, opts}
	mmOrderInfoV1.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmOrderInfoV1.expectations {
		if minimock.Equal(e.params, mmOrderInfoV1.defaultExpectation.params) {
			mmOrderInfoV1.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmOrderInfoV1.defaultExpectation.params)
		}
	}

	return mmOrderInfoV1
}

// ExpectCtxParam1 sets up expected param ctx for OrderServiceV1Client.OrderInfoV1
func (mmOrderInfoV1 *mOrderServiceV1ClientMockOrderInfoV1) ExpectCtxParam1(ctx context.Context) *mOrderServiceV1ClientMockOrderInfoV1 {
	if mmOrderInfoV1.mock.funcOrderInfoV1 != nil {
		mmOrderInfoV1.mock.t.Fatalf("OrderServiceV1ClientMock.OrderInfoV1 mock is already set by Set")
	}

	if mmOrderInfoV1.defaultExpectation == nil {
		mmOrderInfoV1.defaultExpectation = &OrderServiceV1ClientMockOrderInfoV1Expectation{}
	}

	if mmOrderInfoV1.defaultExpectation.params != nil {
		mmOrderInfoV1.mock.t.Fatalf("OrderServiceV1ClientMock.OrderInfoV1 mock is already set by Expect")
	}

	if mmOrderInfoV1.defaultExpectation.paramPtrs == nil {
		mmOrderInfoV1.defaultExpectation.paramPtrs = &OrderServiceV1ClientMockOrderInfoV1ParamPtrs{}
	}
	mmOrderInfoV1.defaultExpectation.paramPtrs.ctx = &ctx
	mmOrderInfoV1.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmOrderInfoV1
}

// ExpectInParam2 sets up expected param in for OrderServiceV1Client.OrderInfoV1
func (mmOrderInfoV1 *mOrderServiceV1ClientMockOrderInfoV1) ExpectInParam2(in *mm_orders.OrderInfoRequest) *mOrderServiceV1ClientMockOrderInfoV1 {
	if mmOrderInfoV1.mock.funcOrderInfoV1 != nil {
		mmOrderInfoV1.mock.t.Fatalf("OrderServiceV1ClientMock.OrderInfoV1 mock is already set by Set")
	}

	if mmOrderInfoV1.defaultExpectation == nil {
		mmOrderInfoV1.defaultExpectation = &OrderServiceV1ClientMockOrderInfoV1Expectation{}
	}

	if mmOrderInfoV1.defaultExpectation.params != nil {
		mmOrderInfoV1.mock.t.Fatalf("OrderServiceV1ClientMock.OrderInfoV1 mock is already set by Expect")
	}

	if mmOrderInfoV1.defaultExpectation.paramPtrs == nil {
		mmOrderInfoV1.defaultExpectation.paramPtrs = &OrderServiceV1ClientMockOrderInfoV1ParamPtrs{}
	}
	mmOrderInfoV1.defaultExpectation.paramPtrs.in = &in
	mmOrderInfoV1.defaultExpectation.expectationOrigins.originIn = minimock.CallerInfo(1)

	return mmOrderInfoV1
}

// ExpectOptsParam3 sets up expected param opts for OrderServiceV1Client.OrderInfoV1
func (mmOrderInfoV1 *mOrderServiceV1ClientMockOrderInfoV1) ExpectOptsParam3(opts ...grpc.CallOption) *mOrderServiceV1ClientMockOrderInfoV1 {
	if mmOrderInfoV1.mock.funcOrderInfoV1 != nil {
		mmOrderInfoV1.mock.t.Fatalf("OrderServiceV1ClientMock.OrderInfoV1 mock is already set by Set")
	}

	if mmOrderInfoV1.defaultExpectation == nil {
		mmOrderInfoV1.defaultExpectation = &OrderServiceV1ClientMockOrderInfoV1Expectation{}
	}

	if mmOrderInfoV1.defaultExpectation.params != nil {
		mmOrderInfoV1.mock.t.Fatalf("OrderServiceV1ClientMock.OrderInfoV1 mock is already set by Expect")
	}

	if mmOrderInfoV1.defaultExpectation.paramPtrs == nil {
		mmOrderInfoV1.defaultExpectation.paramPtrs = &OrderServiceV1ClientMockOrderInfoV1ParamPtrs{}
	}
	mmOrderInfoV1.defaultExpectation.paramPtrs.opts = &opts
	mmOrderInfoV1.defaultExpectation.expectationOrigins.originOpts = minimock.CallerInfo(1)

	return mmOrderInfoV1
}

// Inspect accepts an inspector function that has same arguments as the OrderServiceV1Client.OrderInfoV1
func (mmOrderInfoV1 *mOrderServiceV1ClientMockOrderInfoV1) Inspect(f func(ctx context.Context, in *mm_orders.OrderInfoRequest, opts ...grpc.CallOption)) *mOrderServiceV1ClientMockOrderInfoV1 {
	if mmOrderInfoV1.mock.inspectFuncOrderInfoV1 != nil {
		mmOrderInfoV1.mock.t.Fatalf("Inspect function is already set for OrderServiceV1ClientMock.OrderInfoV1")
	}

	mmOrderInfoV1.mock.inspectFuncOrderInfoV1 = f

	return mmOrderInfoV1
}

// Return sets up results that will be returned by OrderServiceV1Client.OrderInfoV1
func (mmOrderInfoV1 *mOrderServiceV1ClientMockOrderInfoV1) Return(op1 *mm_orders.OrderInfoResponse, err error) *OrderServiceV1ClientMock {
	if mmOrderInfoV1.mock.funcOrderInfoV1 != nil {
		mmOrderInfoV1.mock.t.Fatalf("OrderServiceV1ClientMock.OrderInfoV1 mock is already set by Set")
	}

	if mmOrderInfoV1.defaultExpectation == nil {
		mmOrderInfoV1.defaultExpectation = &OrderServiceV1ClientMockOrderInfoV1Expectation{mock: mmOrderInfoV1.mock}
	}
	mmOrderInfoV1.defaultExpectation.results = &OrderServiceV1ClientMockOrderInfoV1Results{op1, err}
	mmOrderInfoV1.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmOrderInfoV1.mock
}

// Set uses given function f to mock the OrderServiceV1Client.OrderInfoV1 method
func (mmOrderInfoV1 *mOrderServiceV1ClientMockOrderInfoV1) Set(f func(ctx context.Context, in *mm_orders.OrderInfoRequest, opts ...grpc.CallOption) (op1 *mm_orders.OrderInfoResponse, err error)) *OrderServiceV1ClientMock {
	if mmOrderInfoV1.defaultExpectation != nil {
		mmOrderInfoV1.mock.t.Fatalf("Default expectation is already set for the OrderServiceV1Client.OrderInfoV1 method")
	}

	if len(mmOrderInfoV1.expectations) > 0 {
		mmOrderInfoV1.mock.t.Fatalf("Some expectations are already set for the OrderServiceV1Client.OrderInfoV1 method")
	}

	mmOrderInfoV1.mock.funcOrderInfoV1 = f
	mmOrderInfoV1.mock.funcOrderInfoV1Origin = minimock.CallerInfo(1)
	return mmOrderInfoV1.mock
}

// When sets expectation for the OrderServiceV1Client.OrderInfoV1 which will trigger the result defined by the following
// Then helper
func (mmOrderInfoV1 *mOrderServiceV1ClientMockOrderInfoV1) When(ctx context.Context, in *mm_orders.OrderInfoRequest, opts ...grpc.CallOption) *OrderServiceV1ClientMockOrderInfoV1Expectation {
	if mmOrderInfoV1.mock.funcOrderInfoV1 != nil {
		mmOrderInfoV1.mock.t.Fatalf("OrderServiceV1ClientMock.OrderInfoV1 mock is already set by Set")
	}

	expectation := &OrderServiceV1ClientMockOrderInfoV1Expectation{
		mock:               mmOrderInfoV1.mock,
		params:             &OrderServiceV1ClientMockOrderInfoV1Params{ctx, in, opts},
		expectationOrigins: OrderServiceV1ClientMockOrderInfoV1ExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmOrderInfoV1.expectations = append(mmOrderInfoV1.expectations, expectation)
	return expectation
}

// Then sets up OrderServiceV1Client.OrderInfoV1 return parameters for the expectation previously defined by the When method
func (e *OrderServiceV1ClientMockOrderInfoV1Expectation) Then(op1 *mm_orders.OrderInfoResponse, err error) *OrderServiceV1ClientMock {
	e.results = &OrderServiceV1ClientMockOrderInfoV1Results{op1, err}
	return e.mock
}

// Times sets number of times OrderServiceV1Client.OrderInfoV1 should be invoked
func (mmOrderInfoV1 *mOrderServiceV1ClientMockOrderInfoV1) Times(n uint64) *mOrderServiceV1ClientMockOrderInfoV1 {
	if n == 0 {
		mmOrderInfoV1.mock.t.Fatalf("Times of OrderServiceV1ClientMock.OrderInfoV1 mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmOrderInfoV1.expectedInvocations, n)
	mmOrderInfoV1.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmOrderInfoV1
}

func (mmOrderInfoV1 *mOrderServiceV1ClientMockOrderInfoV1) invocationsDone() bool {
	if len(mmOrderInfoV1.expectations) == 0 && mmOrderInfoV1.defaultExpectation == nil && mmOrderInfoV1.mock.funcOrderInfoV1 == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmOrderInfoV1.mock.afterOrderInfoV1Counter)
	expectedInvocations := mm_atomic.LoadUint64(&mmOrderInfoV1.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// OrderInfoV1 implements mm_orders.OrderServiceV1Client
func (mmOrderInfoV1 *OrderServiceV1ClientMock) OrderInfoV1(ctx context.Context, in *mm_orders.OrderInfoRequest, opts ...grpc.CallOption) (op1 *mm_orders.OrderInfoResponse, err error) {
	mm_atomic.AddUint64(&mmOrderInfoV1.beforeOrderInfoV1Counter, 1)
	defer mm_atomic.AddUint64(&mmOrderInfoV1.afterOrderInfoV1Counter, 1)

	mmOrderInfoV1.t.Helper()

	if mmOrderInfoV1.inspectFuncOrderInfoV1 != nil {
		mmOrderInfoV1.inspectFuncOrderInfoV1(ctx, in, opts...)
	}

	mm_params := OrderServiceV1ClientMockOrderInfoV1Params{ctx, in, opts}

	// Record call args
	mmOrderInfoV1.OrderInfoV1Mock.mutex.Lock()
	mmOrderInfoV1.OrderInfoV1Mock.callArgs = append(mmOrderInfoV1.OrderInfoV1Mock.callArgs, &mm_params)
	mmOrderInfoV1.OrderInfoV1Mock.mutex.Unlock()

	for _, e := range mmOrderInfoV1.OrderInfoV1Mock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.op1, e.results.err
		}
	}

	if mmOrderInfoV1.OrderInfoV1Mock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmOrderInfoV1.OrderInfoV1Mock.defaultExpectation.Counter, 1)
		mm_want := mmOrderInfoV1.OrderInfoV1Mock.defaultExpectation.params
		mm_want_ptrs := mmOrderInfoV1.OrderInfoV1Mock.defaultExpectation.paramPtrs

		mm_got := OrderServiceV1ClientMockOrderInfoV1Params{ctx, in, opts}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmOrderInfoV1.t.Errorf("OrderServiceV1ClientMock.OrderInfoV1 got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmOrderInfoV1.OrderInfoV1Mock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.in != nil && !minimock.Equal(*mm_want_ptrs.in, mm_got.in) {
				mmOrderInfoV1.t.Errorf("OrderServiceV1ClientMock.OrderInfoV1 got unexpected parameter in, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmOrderInfoV1.OrderInfoV1Mock.defaultExpectation.expectationOrigins.originIn, *mm_want_ptrs.in, mm_got.in, minimock.Diff(*mm_want_ptrs.in, mm_got.in))
			}

			if mm_want_ptrs.opts != nil && !minimock.Equal(*mm_want_ptrs.opts, mm_got.opts) {
				mmOrderInfoV1.t.Errorf("OrderServiceV1ClientMock.OrderInfoV1 got unexpected parameter opts, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmOrderInfoV1.OrderInfoV1Mock.defaultExpectation.expectationOrigins.originOpts, *mm_want_ptrs.opts, mm_got.opts, minimock.Diff(*mm_want_ptrs.opts, mm_got.opts))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmOrderInfoV1.t.Errorf("OrderServiceV1ClientMock.OrderInfoV1 got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmOrderInfoV1.OrderInfoV1Mock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmOrderInfoV1.OrderInfoV1Mock.defaultExpectation.results
		if mm_results == nil {
			mmOrderInfoV1.t.Fatal("No results are set for the OrderServiceV1ClientMock.OrderInfoV1")
		}
		return (*mm_results).op1, (*mm_results).err
	}
	if mmOrderInfoV1.funcOrderInfoV1 != nil {
		return mmOrderInfoV1.funcOrderInfoV1(ctx, in, opts...)
	}
	mmOrderInfoV1.t.Fatalf("Unexpected call to OrderServiceV1ClientMock.OrderInfoV1. %v %v %v", ctx, in, opts)
	return
}

// OrderInfoV1AfterCounter returns a count of finished OrderServiceV1ClientMock.OrderInfoV1 invocations
func (mmOrderInfoV1 *OrderServiceV1ClientMock) OrderInfoV1AfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmOrderInfoV1.afterOrderInfoV1Counter)
}

// OrderInfoV1BeforeCounter returns a count of OrderServiceV1ClientMock.OrderInfoV1 invocations
func (mmOrderInfoV1 *OrderServiceV1ClientMock) OrderInfoV1BeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmOrderInfoV1.beforeOrderInfoV1Counter)
}

// Calls returns a list of arguments used in each call to OrderServiceV1ClientMock.OrderInfoV1.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmOrderInfoV1 *mOrderServiceV1ClientMockOrderInfoV1) Calls() []*OrderServiceV1ClientMockOrderInfoV1Params {
	mmOrderInfoV1.mutex.RLock()

	argCopy := make([]*OrderServiceV1ClientMockOrderInfoV1Params, len(mmOrderInfoV1.callArgs))
	copy(argCopy, mmOrderInfoV1.callArgs)

	mmOrderInfoV1.mutex.RUnlock()

	return argCopy
}

// MinimockOrderInfoV1Done returns true if the count of the OrderInfoV1 invocations corresponds
// the number of defined expectations
func (m *OrderServiceV1ClientMock) MinimockOrderInfoV1Done() bool {
	if m.OrderInfoV1Mock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.OrderInfoV1Mock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.OrderInfoV1Mock.invocationsDone()
}

// MinimockOrderInfoV1Inspect logs each unmet expectation
func (m *OrderServiceV1ClientMock) MinimockOrderInfoV1Inspect() {
	for _, e := range m.OrderInfoV1Mock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to OrderServiceV1ClientMock.OrderInfoV1 at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterOrderInfoV1Counter := mm_atomic.LoadUint64(&m.afterOrderInfoV1Counter)
	// if default expectation was set then invocations count should be greater than zero
	if m.OrderInfoV1Mock.defaultExpectation != nil && afterOrderInfoV1Counter < 1 {
		if m.OrderInfoV1Mock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to OrderServiceV1ClientMock.OrderInfoV1 at\n%s", m.OrderInfoV1Mock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to OrderServiceV1ClientMock.OrderInfoV1 at\n%s with params: %#v", m.OrderInfoV1Mock.defaultExpectation.expectationOrigins.origin, *m.OrderInfoV1Mock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcOrderInfoV1 != nil && afterOrderInfoV1Counter < 1 {
		m.t.Errorf("Expected call to OrderServiceV1ClientMock.OrderInfoV1 at\n%s", m.funcOrderInfoV1Origin)
	}

	if !m.OrderInfoV1Mock.invocationsDone() && afterOrderInfoV1Counter > 0 {
		m.t.Errorf("Expected %d calls to OrderServiceV1ClientMock.OrderInfoV1 at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.OrderInfoV1Mock.expectedInvocations), m.OrderInfoV1Mock.expectedInvocationsOrigin, afterOrderInfoV1Counter)
	}
}

type mOrderServiceV1ClientMockOrderPayV1 struct {
	optional           bool
	mock               *OrderServiceV1ClientMock
	defaultExpectation *OrderServiceV1ClientMockOrderPayV1Expectation
	expectations       []*OrderServiceV1ClientMockOrderPayV1Expectation

	callArgs []*OrderServiceV1ClientMockOrderPayV1Params
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// OrderServiceV1ClientMockOrderPayV1Expectation specifies expectation struct of the OrderServiceV1Client.OrderPayV1
type OrderServiceV1ClientMockOrderPayV1Expectation struct {
	mock               *OrderServiceV1ClientMock
	params             *OrderServiceV1ClientMockOrderPayV1Params
	paramPtrs          *OrderServiceV1ClientMockOrderPayV1ParamPtrs
	expectationOrigins OrderServiceV1ClientMockOrderPayV1ExpectationOrigins
	results            *OrderServiceV1ClientMockOrderPayV1Results
	returnOrigin       string
	Counter            uint64
}

// OrderServiceV1ClientMockOrderPayV1Params contains parameters of the OrderServiceV1Client.OrderPayV1
type OrderServiceV1ClientMockOrderPayV1Params struct {
	ctx  context.Context
	in   *mm_orders.OrderPayRequest
	opts []grpc.CallOption
}

// OrderServiceV1ClientMockOrderPayV1ParamPtrs contains pointers to parameters of the OrderServiceV1Client.OrderPayV1
type OrderServiceV1ClientMockOrderPayV1ParamPtrs struct {
	ctx  *context.Context
	in   **mm_orders.OrderPayRequest
	opts *[]grpc.CallOption
}

// OrderServiceV1ClientMockOrderPayV1Results contains results of the OrderServiceV1Client.OrderPayV1
type OrderServiceV1ClientMockOrderPayV1Results struct {
	op1 *mm_orders.OrderPayResponse
	err error
}

// OrderServiceV1ClientMockOrderPayV1Origins contains origins of expectations of the OrderServiceV1Client.OrderPayV1
type OrderServiceV1ClientMockOrderPayV1ExpectationOrigins struct {
	origin     string
	originCtx  string
	originIn   string
	originOpts string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmOrderPayV1 *mOrderServiceV1ClientMockOrderPayV1) Optional() *mOrderServiceV1ClientMockOrderPayV1 {
	mmOrderPayV1.optional = true
	return mmOrderPayV1
}

// Expect sets up expected params for OrderServiceV1Client.OrderPayV1
func (mmOrderPayV1 *mOrderServiceV1ClientMockOrderPayV1) Expect(ctx context.Context, in *mm_orders.OrderPayRequest, opts ...grpc.CallOption) *mOrderServiceV1ClientMockOrderPayV1 {
	if mmOrderPayV1.mock.funcOrderPayV1 != nil {
		mmOrderPayV1.mock.t.Fatalf("OrderServiceV1ClientMock.OrderPayV1 mock is already set by Set")
	}

	if mmOrderPayV1.defaultExpectation == nil {
		mmOrderPayV1.defaultExpectation = &OrderServiceV1ClientMockOrderPayV1Expectation{}
	}

	if mmOrderPayV1.defaultExpectation.paramPtrs != nil {
		mmOrderPayV1.mock.t.Fatalf("OrderServiceV1ClientMock.OrderPayV1 mock is already set by ExpectParams functions")
	}

	mmOrderPayV1.defaultExpectation.params = &OrderServiceV1ClientMockOrderPayV1Params{ctx, in, opts}
	mmOrderPayV1.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmOrderPayV1.expectations {
		if minimock.Equal(e.params, mmOrderPayV1.defaultExpectation.params) {
			mmOrderPayV1.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmOrderPayV1.defaultExpectation.params)
		}
	}

	return mmOrderPayV1
}

// ExpectCtxParam1 sets up expected param ctx for OrderServiceV1Client.OrderPayV1
func (mmOrderPayV1 *mOrderServiceV1ClientMockOrderPayV1) ExpectCtxParam1(ctx context.Context) *mOrderServiceV1ClientMockOrderPayV1 {
	if mmOrderPayV1.mock.funcOrderPayV1 != nil {
		mmOrderPayV1.mock.t.Fatalf("OrderServiceV1ClientMock.OrderPayV1 mock is already set by Set")
	}

	if mmOrderPayV1.defaultExpectation == nil {
		mmOrderPayV1.defaultExpectation = &OrderServiceV1ClientMockOrderPayV1Expectation{}
	}

	if mmOrderPayV1.defaultExpectation.params != nil {
		mmOrderPayV1.mock.t.Fatalf("OrderServiceV1ClientMock.OrderPayV1 mock is already set by Expect")
	}

	if mmOrderPayV1.defaultExpectation.paramPtrs == nil {
		mmOrderPayV1.defaultExpectation.paramPtrs = &OrderServiceV1ClientMockOrderPayV1ParamPtrs{}
	}
	mmOrderPayV1.defaultExpectation.paramPtrs.ctx = &ctx
	mmOrderPayV1.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmOrderPayV1
}

// ExpectInParam2 sets up expected param in for OrderServiceV1Client.OrderPayV1
func (mmOrderPayV1 *mOrderServiceV1ClientMockOrderPayV1) ExpectInParam2(in *mm_orders.OrderPayRequest) *mOrderServiceV1ClientMockOrderPayV1 {
	if mmOrderPayV1.mock.funcOrderPayV1 != nil {
		mmOrderPayV1.mock.t.Fatalf("OrderServiceV1ClientMock.OrderPayV1 mock is already set by Set")
	}

	if mmOrderPayV1.defaultExpectation == nil {
		mmOrderPayV1.defaultExpectation = &OrderServiceV1ClientMockOrderPayV1Expectation{}
	}

	if mmOrderPayV1.defaultExpectation.params != nil {
		mmOrderPayV1.mock.t.Fatalf("OrderServiceV1ClientMock.OrderPayV1 mock is already set by Expect")
	}

	if mmOrderPayV1.defaultExpectation.paramPtrs == nil {
		mmOrderPayV1.defaultExpectation.paramPtrs = &OrderServiceV1ClientMockOrderPayV1ParamPtrs{}
	}
	mmOrderPayV1.defaultExpectation.paramPtrs.in = &in
	mmOrderPayV1.defaultExpectation.expectationOrigins.originIn = minimock.CallerInfo(1)

	return mmOrderPayV1
}

// ExpectOptsParam3 sets up expected param opts for OrderServiceV1Client.OrderPayV1
func (mmOrderPayV1 *mOrderServiceV1ClientMockOrderPayV1) ExpectOptsParam3(opts ...grpc.CallOption) *mOrderServiceV1ClientMockOrderPayV1 {
	if mmOrderPayV1.mock.funcOrderPayV1 != nil {
		mmOrderPayV1.mock.t.Fatalf("OrderServiceV1ClientMock.OrderPayV1 mock is already set by Set")
	}

	if mmOrderPayV1.defaultExpectation == nil {
		mmOrderPayV1.defaultExpectation = &OrderServiceV1ClientMockOrderPayV1Expectation{}
	}

	if mmOrderPayV1.defaultExpectation.params != nil {
		mmOrderPayV1.mock.t.Fatalf("OrderServiceV1ClientMock.OrderPayV1 mock is already set by Expect")
	}

	if mmOrderPayV1.defaultExpectation.paramPtrs == nil {
		mmOrderPayV1.defaultExpectation.paramPtrs = &OrderServiceV1ClientMockOrderPayV1ParamPtrs{}
	}
	mmOrderPayV1.defaultExpectation.paramPtrs.opts = &opts
	mmOrderPayV1.defaultExpectation.expectationOrigins.originOpts = minimock.CallerInfo(1)

	return mmOrderPayV1
}

// Inspect accepts an inspector function that has same arguments as the OrderServiceV1Client.OrderPayV1
func (mmOrderPayV1 *mOrderServiceV1ClientMockOrderPayV1) Inspect(f func(ctx context.Context, in *mm_orders.OrderPayRequest, opts ...grpc.CallOption)) *mOrderServiceV1ClientMockOrderPayV1 {
	if mmOrderPayV1.mock.inspectFuncOrderPayV1 != nil {
		mmOrderPayV1.mock.t.Fatalf("Inspect function is already set for OrderServiceV1ClientMock.OrderPayV1")
	}

	mmOrderPayV1.mock.inspectFuncOrderPayV1 = f

	return mmOrderPayV1
}

// Return sets up results that will be returned by OrderServiceV1Client.OrderPayV1
func (mmOrderPayV1 *mOrderServiceV1ClientMockOrderPayV1) Return(op1 *mm_orders.OrderPayResponse, err error) *OrderServiceV1ClientMock {
	if mmOrderPayV1.mock.funcOrderPayV1 != nil {
		mmOrderPayV1.mock.t.Fatalf("OrderServiceV1ClientMock.OrderPayV1 mock is already set by Set")
	}

	if mmOrderPayV1.defaultExpectation == nil {
		mmOrderPayV1.defaultExpectation = &OrderServiceV1ClientMockOrderPayV1Expectation{mock: mmOrderPayV1.mock}
	}
	mmOrderPayV1.defaultExpectation.results = &OrderServiceV1ClientMockOrderPayV1Results{op1, err}
	mmOrderPayV1.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmOrderPayV1.mock
}

// Set uses given function f to mock the OrderServiceV1Client.OrderPayV1 method
func (mmOrderPayV1 *mOrderServiceV1ClientMockOrderPayV1) Set(f func(ctx context.Context, in *mm_orders.OrderPayRequest, opts ...grpc.CallOption) (op1 *mm_orders.OrderPayResponse, err error)) *OrderServiceV1ClientMock {
	if mmOrderPayV1.defaultExpectation != nil {
		mmOrderPayV1.mock.t.Fatalf("Default expectation is already set for the OrderServiceV1Client.OrderPayV1 method")
	}

	if len(mmOrderPayV1.expectations) > 0 {
		mmOrderPayV1.mock.t.Fatalf("Some expectations are already set for the OrderServiceV1Client.OrderPayV1 method")
	}

	mmOrderPayV1.mock.funcOrderPayV1 = f
	mmOrderPayV1.mock.funcOrderPayV1Origin = minimock.CallerInfo(1)
	return mmOrderPayV1.mock
}

// When sets expectation for the OrderServiceV1Client.OrderPayV1 which will trigger the result defined by the following
// Then helper
func (mmOrderPayV1 *mOrderServiceV1ClientMockOrderPayV1) When(ctx context.Context, in *mm_orders.OrderPayRequest, opts ...grpc.CallOption) *OrderServiceV1ClientMockOrderPayV1Expectation {
	if mmOrderPayV1.mock.funcOrderPayV1 != nil {
		mmOrderPayV1.mock.t.Fatalf("OrderServiceV1ClientMock.OrderPayV1 mock is already set by Set")
	}

	expectation := &OrderServiceV1ClientMockOrderPayV1Expectation{
		mock:               mmOrderPayV1.mock,
		params:             &OrderServiceV1ClientMockOrderPayV1Params{ctx, in, opts},
		expectationOrigins: OrderServiceV1ClientMockOrderPayV1ExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmOrderPayV1.expectations = append(mmOrderPayV1.expectations, expectation)
	return expectation
}

// Then sets up OrderServiceV1Client.OrderPayV1 return parameters for the expectation previously defined by the When method
func (e *OrderServiceV1ClientMockOrderPayV1Expectation) Then(op1 *mm_orders.OrderPayResponse, err error) *OrderServiceV1ClientMock {
	e.results = &OrderServiceV1ClientMockOrderPayV1Results{op1, err}
	return e.mock
}

// Times sets number of times OrderServiceV1Client.OrderPayV1 should be invoked
func (mmOrderPayV1 *mOrderServiceV1ClientMockOrderPayV1) Times(n uint64) *mOrderServiceV1ClientMockOrderPayV1 {
	if n == 0 {
		mmOrderPayV1.mock.t.Fatalf("Times of OrderServiceV1ClientMock.OrderPayV1 mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmOrderPayV1.expectedInvocations, n)
	mmOrderPayV1.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmOrderPayV1
}

func (mmOrderPayV1 *mOrderServiceV1ClientMockOrderPayV1) invocationsDone() bool {
	if len(mmOrderPayV1.expectations) == 0 && mmOrderPayV1.defaultExpectation == nil && mmOrderPayV1.mock.funcOrderPayV1 == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmOrderPayV1.mock.afterOrderPayV1Counter)
	expectedInvocations := mm_atomic.LoadUint64(&mmOrderPayV1.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// OrderPayV1 implements mm_orders.OrderServiceV1Client
func (mmOrderPayV1 *OrderServiceV1ClientMock) OrderPayV1(ctx context.Context, in *mm_orders.OrderPayRequest, opts ...grpc.CallOption) (op1 *mm_orders.OrderPayResponse, err error) {
	mm_atomic.AddUint64(&mmOrderPayV1.beforeOrderPayV1Counter, 1)
	defer mm_atomic.AddUint64(&mmOrderPayV1.afterOrderPayV1Counter, 1)

	mmOrderPayV1.t.Helper()

	if mmOrderPayV1.inspectFuncOrderPayV1 != nil {
		mmOrderPayV1.inspectFuncOrderPayV1(ctx, in, opts...)
	}

	mm_params := OrderServiceV1ClientMockOrderPayV1Params{ctx, in, opts}

	// Record call args
	mmOrderPayV1.OrderPayV1Mock.mutex.Lock()
	mmOrderPayV1.OrderPayV1Mock.callArgs = append(mmOrderPayV1.OrderPayV1Mock.callArgs, &mm_params)
	mmOrderPayV1.OrderPayV1Mock.mutex.Unlock()

	for _, e := range mmOrderPayV1.OrderPayV1Mock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.op1, e.results.err
		}
	}

	if mmOrderPayV1.OrderPayV1Mock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmOrderPayV1.OrderPayV1Mock.defaultExpectation.Counter, 1)
		mm_want := mmOrderPayV1.OrderPayV1Mock.defaultExpectation.params
		mm_want_ptrs := mmOrderPayV1.OrderPayV1Mock.defaultExpectation.paramPtrs

		mm_got := OrderServiceV1ClientMockOrderPayV1Params{ctx, in, opts}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmOrderPayV1.t.Errorf("OrderServiceV1ClientMock.OrderPayV1 got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmOrderPayV1.OrderPayV1Mock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.in != nil && !minimock.Equal(*mm_want_ptrs.in, mm_got.in) {
				mmOrderPayV1.t.Errorf("OrderServiceV1ClientMock.OrderPayV1 got unexpected parameter in, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmOrderPayV1.OrderPayV1Mock.defaultExpectation.expectationOrigins.originIn, *mm_want_ptrs.in, mm_got.in, minimock.Diff(*mm_want_ptrs.in, mm_got.in))
			}

			if mm_want_ptrs.opts != nil && !minimock.Equal(*mm_want_ptrs.opts, mm_got.opts) {
				mmOrderPayV1.t.Errorf("OrderServiceV1ClientMock.OrderPayV1 got unexpected parameter opts, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmOrderPayV1.OrderPayV1Mock.defaultExpectation.expectationOrigins.originOpts, *mm_want_ptrs.opts, mm_got.opts, minimock.Diff(*mm_want_ptrs.opts, mm_got.opts))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmOrderPayV1.t.Errorf("OrderServiceV1ClientMock.OrderPayV1 got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmOrderPayV1.OrderPayV1Mock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmOrderPayV1.OrderPayV1Mock.defaultExpectation.results
		if mm_results == nil {
			mmOrderPayV1.t.Fatal("No results are set for the OrderServiceV1ClientMock.OrderPayV1")
		}
		return (*mm_results).op1, (*mm_results).err
	}
	if mmOrderPayV1.funcOrderPayV1 != nil {
		return mmOrderPayV1.funcOrderPayV1(ctx, in, opts...)
	}
	mmOrderPayV1.t.Fatalf("Unexpected call to OrderServiceV1ClientMock.OrderPayV1. %v %v %v", ctx, in, opts)
	return
}

// OrderPayV1AfterCounter returns a count of finished OrderServiceV1ClientMock.OrderPayV1 invocations
func (mmOrderPayV1 *OrderServiceV1ClientMock) OrderPayV1AfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmOrderPayV1.afterOrderPayV1Counter)
}

// OrderPayV1BeforeCounter returns a count of OrderServiceV1ClientMock.OrderPayV1 invocations
func (mmOrderPayV1 *OrderServiceV1ClientMock) OrderPayV1BeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmOrderPayV1.beforeOrderPayV1Counter)
}

// Calls returns a list of arguments used in each call to OrderServiceV1ClientMock.OrderPayV1.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmOrderPayV1 *mOrderServiceV1ClientMockOrderPayV1) Calls() []*OrderServiceV1ClientMockOrderPayV1Params {
	mmOrderPayV1.mutex.RLock()

	argCopy := make([]*OrderServiceV1ClientMockOrderPayV1Params, len(mmOrderPayV1.callArgs))
	copy(argCopy, mmOrderPayV1.callArgs)

	mmOrderPayV1.mutex.RUnlock()

	return argCopy
}

// MinimockOrderPayV1Done returns true if the count of the OrderPayV1 invocations corresponds
// the number of defined expectations
func (m *OrderServiceV1ClientMock) MinimockOrderPayV1Done() bool {
	if m.OrderPayV1Mock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.OrderPayV1Mock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.OrderPayV1Mock.invocationsDone()
}

// MinimockOrderPayV1Inspect logs each unmet expectation
func (m *OrderServiceV1ClientMock) MinimockOrderPayV1Inspect() {
	for _, e := range m.OrderPayV1Mock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to OrderServiceV1ClientMock.OrderPayV1 at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterOrderPayV1Counter := mm_atomic.LoadUint64(&m.afterOrderPayV1Counter)
	// if default expectation was set then invocations count should be greater than zero
	if m.OrderPayV1Mock.defaultExpectation != nil && afterOrderPayV1Counter < 1 {
		if m.OrderPayV1Mock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to OrderServiceV1ClientMock.OrderPayV1 at\n%s", m.OrderPayV1Mock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to OrderServiceV1ClientMock.OrderPayV1 at\n%s with params: %#v", m.OrderPayV1Mock.defaultExpectation.expectationOrigins.origin, *m.OrderPayV1Mock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcOrderPayV1 != nil && afterOrderPayV1Counter < 1 {
		m.t.Errorf("Expected call to OrderServiceV1ClientMock.OrderPayV1 at\n%s", m.funcOrderPayV1Origin)
	}

	if !m.OrderPayV1Mock.invocationsDone() && afterOrderPayV1Counter > 0 {
		m.t.Errorf("Expected %d calls to OrderServiceV1ClientMock.OrderPayV1 at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.OrderPayV1Mock.expectedInvocations), m.OrderPayV1Mock.expectedInvocationsOrigin, afterOrderPayV1Counter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *OrderServiceV1ClientMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockOrderCancelV1Inspect()

			m.MinimockOrderCreateV1Inspect()

			m.MinimockOrderInfoV1Inspect()

			m.MinimockOrderPayV1Inspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *OrderServiceV1ClientMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *OrderServiceV1ClientMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockOrderCancelV1Done() &&
		m.MinimockOrderCreateV1Done() &&
		m.MinimockOrderInfoV1Done() &&
		m.MinimockOrderPayV1Done()
}
