// Code generated by http://github.com/gojuno/minimock (v3.4.5). DO NOT EDIT.

package mocks

//go:generate minimock -i route256/cart/internal/service.RateLimiter -o rate_limiter_mock.go -n RateLimiterMock -p mocks

import (
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
)

// RateLimiterMock implements mm_service.RateLimiter
type RateLimiterMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcAcquire          func()
	funcAcquireOrigin    string
	inspectFuncAcquire   func()
	afterAcquireCounter  uint64
	beforeAcquireCounter uint64
	AcquireMock          mRateLimiterMockAcquire
}

// NewRateLimiterMock returns a mock for mm_service.RateLimiter
func NewRateLimiterMock(t minimock.Tester) *RateLimiterMock {
	m := &RateLimiterMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.AcquireMock = mRateLimiterMockAcquire{mock: m}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mRateLimiterMockAcquire struct {
	optional           bool
	mock               *RateLimiterMock
	defaultExpectation *RateLimiterMockAcquireExpectation
	expectations       []*RateLimiterMockAcquireExpectation

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RateLimiterMockAcquireExpectation specifies expectation struct of the RateLimiter.Acquire
type RateLimiterMockAcquireExpectation struct {
	mock *RateLimiterMock

	returnOrigin string
	Counter      uint64
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmAcquire *mRateLimiterMockAcquire) Optional() *mRateLimiterMockAcquire {
	mmAcquire.optional = true
	return mmAcquire
}

// Expect sets up expected params for RateLimiter.Acquire
func (mmAcquire *mRateLimiterMockAcquire) Expect() *mRateLimiterMockAcquire {
	if mmAcquire.mock.funcAcquire != nil {
		mmAcquire.mock.t.Fatalf("RateLimiterMock.Acquire mock is already set by Set")
	}

	if mmAcquire.defaultExpectation == nil {
		mmAcquire.defaultExpectation = &RateLimiterMockAcquireExpectation{}
	}

	return mmAcquire
}

// Inspect accepts an inspector function that has same arguments as the RateLimiter.Acquire
func (mmAcquire *mRateLimiterMockAcquire) Inspect(f func()) *mRateLimiterMockAcquire {
	if mmAcquire.mock.inspectFuncAcquire != nil {
		mmAcquire.mock.t.Fatalf("Inspect function is already set for RateLimiterMock.Acquire")
	}

	mmAcquire.mock.inspectFuncAcquire = f

	return mmAcquire
}

// Return sets up results that will be returned by RateLimiter.Acquire
func (mmAcquire *mRateLimiterMockAcquire) Return() *RateLimiterMock {
	if mmAcquire.mock.funcAcquire != nil {
		mmAcquire.mock.t.Fatalf("RateLimiterMock.Acquire mock is already set by Set")
	}

	if mmAcquire.defaultExpectation == nil {
		mmAcquire.defaultExpectation = &RateLimiterMockAcquireExpectation{mock: mmAcquire.mock}
	}

	mmAcquire.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmAcquire.mock
}

// Set uses given function f to mock the RateLimiter.Acquire method
func (mmAcquire *mRateLimiterMockAcquire) Set(f func()) *RateLimiterMock {
	if mmAcquire.defaultExpectation != nil {
		mmAcquire.mock.t.Fatalf("Default expectation is already set for the RateLimiter.Acquire method")
	}

	if len(mmAcquire.expectations) > 0 {
		mmAcquire.mock.t.Fatalf("Some expectations are already set for the RateLimiter.Acquire method")
	}

	mmAcquire.mock.funcAcquire = f
	mmAcquire.mock.funcAcquireOrigin = minimock.CallerInfo(1)
	return mmAcquire.mock
}

// Times sets number of times RateLimiter.Acquire should be invoked
func (mmAcquire *mRateLimiterMockAcquire) Times(n uint64) *mRateLimiterMockAcquire {
	if n == 0 {
		mmAcquire.mock.t.Fatalf("Times of RateLimiterMock.Acquire mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmAcquire.expectedInvocations, n)
	mmAcquire.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmAcquire
}

func (mmAcquire *mRateLimiterMockAcquire) invocationsDone() bool {
	if len(mmAcquire.expectations) == 0 && mmAcquire.defaultExpectation == nil && mmAcquire.mock.funcAcquire == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmAcquire.mock.afterAcquireCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmAcquire.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Acquire implements mm_service.RateLimiter
func (mmAcquire *RateLimiterMock) Acquire() {
	mm_atomic.AddUint64(&mmAcquire.beforeAcquireCounter, 1)
	defer mm_atomic.AddUint64(&mmAcquire.afterAcquireCounter, 1)

	mmAcquire.t.Helper()

	if mmAcquire.inspectFuncAcquire != nil {
		mmAcquire.inspectFuncAcquire()
	}

	if mmAcquire.AcquireMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmAcquire.AcquireMock.defaultExpectation.Counter, 1)

		return

	}
	if mmAcquire.funcAcquire != nil {
		mmAcquire.funcAcquire()
		return
	}
	mmAcquire.t.Fatalf("Unexpected call to RateLimiterMock.Acquire.")

}

// AcquireAfterCounter returns a count of finished RateLimiterMock.Acquire invocations
func (mmAcquire *RateLimiterMock) AcquireAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAcquire.afterAcquireCounter)
}

// AcquireBeforeCounter returns a count of RateLimiterMock.Acquire invocations
func (mmAcquire *RateLimiterMock) AcquireBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAcquire.beforeAcquireCounter)
}

// MinimockAcquireDone returns true if the count of the Acquire invocations corresponds
// the number of defined expectations
func (m *RateLimiterMock) MinimockAcquireDone() bool {
	if m.AcquireMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.AcquireMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.AcquireMock.invocationsDone()
}

// MinimockAcquireInspect logs each unmet expectation
func (m *RateLimiterMock) MinimockAcquireInspect() {
	for _, e := range m.AcquireMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to RateLimiterMock.Acquire")
		}
	}

	afterAcquireCounter := mm_atomic.LoadUint64(&m.afterAcquireCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.AcquireMock.defaultExpectation != nil && afterAcquireCounter < 1 {
		m.t.Errorf("Expected call to RateLimiterMock.Acquire at\n%s", m.AcquireMock.defaultExpectation.returnOrigin)
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAcquire != nil && afterAcquireCounter < 1 {
		m.t.Errorf("Expected call to RateLimiterMock.Acquire at\n%s", m.funcAcquireOrigin)
	}

	if !m.AcquireMock.invocationsDone() && afterAcquireCounter > 0 {
		m.t.Errorf("Expected %d calls to RateLimiterMock.Acquire at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.AcquireMock.expectedInvocations), m.AcquireMock.expectedInvocationsOrigin, afterAcquireCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *RateLimiterMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockAcquireInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *RateLimiterMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *RateLimiterMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockAcquireDone()
}
